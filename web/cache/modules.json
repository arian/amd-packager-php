{"Core\/DOM\/Node":{"id":"Core\/DOM\/Node","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/DOM\/Node.js","package":"Core","amd":true,"content":"\/*\n---\nname: DOM\ndescription: DOM\n...\n*\/\n\ndefine([\n\t'..\/Core\/Class', '..\/Utility\/Object', '..\/Utility\/Array', '..\/Utility\/String', '..\/Slick\/Finder', '..\/Slick\/Parser', '..\/Data\/Accessor'\n], function(Class, Object, Array, String, Finder, Parser, Accessor){\n\n\/\/ node\n\nvar Node = Class({\n\n\tinitialize: function(node){\n\t\tthis.node = node;\n\t},\n\t\n\tfind: function(expression){\n\t\treturn select(Finder.find(this.node, expression));\n\t},\n\t\n\tsearch: function(expression){\n\t\tvar elements = new Elements, nodes = Finder.search(this.node, expression);\n\t\tfor (var i = 0; i < nodes.length; i++) elements[elements.length++] = select(nodes[i]);\n\t\treturn elements;\n\t}\n\n});\n\nNode.prototype.valueOf = function(){\n\treturn this.node;\n};\n\nvar html = document.documentElement;\n\nNode.implement({\n\n\taddEventListener: ((html.addEventListener) ? function(type, fn){\n\t\tthis.node.addEventListener(type, fn, false);\n\t\treturn this;\n\t} : function(type, fn){\n\t\tthis.node.attachEvent('on' + type, fn);\n\t\treturn this;\n\t}),\n\n\tremoveEventListener: ((html.removeEventListener) ? function(type, fn){\n\t\tthis.node.removeEventListener(type, fn, false);\n\t\treturn this;\n\t} : function(type, fn){\n\t\tthis.node.detachEvent('on' + type, fn);\n\t\treturn this;\n\t})\n\n});\n\nvar wrappers = {}, matchers = [];\n\nClass.defineMutator('Matches', function(match){\n\tmatchers.push({_match: match, _class: this});\n});\n\n\/\/ select\n\nvar select = Node.select = function(node){\n\tif (node != null){\n\t\tif (typeof node == 'string') return hostDocument.find(node);\n\t\tif (node instanceof Node) return node;\n\t\tif (node === window) return hostWindow;\n\t\tif (node === document) return hostDocument;\n\t\tvar uid = node.uniqueNumber || Finder.uidOf(node), wrapper = wrappers[uid];\n\t\tif (wrapper) return wrapper;\n\t\tfor (var l = matchers.length; l--; l){\n\t\t\tvar current = matchers[l];\n\t\t\tif (Finder.match(node, current._match)) return (wrappers[uid] = new current._class(node));\n\t\t}\n\t}\n\treturn null;\n};\n\n\/\/ collect\n\nvar collect = Node.collect = function(){\n\tvar list = new Elements;\n\tfor (var i = 0, l = arguments.length; i < l; i++){\n\t\tvar argument = arguments[i];\n\t\tif (typeof argument == 'string') Finder.search(document, argument, list);\n\t\telse list.push(argument);\n\t}\n\treturn list;\n};\n\n\/\/ document\n\nvar Document = Node.Document = Class({\n\n\tExtends: Node,\n\t\n\tcreateElement: function(tag){\n\t\treturn select(this.node.createElement(tag));\n\t},\n\t\n\tcreateTextNode: function(text){\n\t\treturn this.node.createTextNode(text);\n\t},\n\t\n\tbuild: function(){\n\t\t\n\t}\n\n});\n\nDocument.prototype.toString = function(){\n\treturn '<document>';\n};\n\nvar hostDocument = new Document(document);\n\n\/\/ window\n\nvar Window = Node.Window = Class({Extends: Node});\n\nWindow.prototype.toString = function(){\n\treturn '<window>';\n};\n\nvar hostWindow = new Window(window);\n\n\/\/ element\n\nvar Element = Node.Element = new Class({\n\tExtends: Node,\n\tMatches: '*'\n});\n\n\/\/ element methods to elements\n\nvar elementImplement = Element.implement;\n\nElement.implement = function(key, fn){\n\tif (typeof key != 'string') for (var k in key) this.implement(k, key[k]); else {\n\t\tif (!Elements.prototype[key]) Elements.prototype[key] = function(){\n\t\t\tvar elements = new Elements, results = [];\n\t\t\tfor (var i = 0; i < this.length; i++){\n\t\t\t\tvar node = this[i], result = node[key].apply(node, arguments);\n\t\t\t\tif (elements && !(result instanceof Element)) elements = false;\n\t\t\t\tresults[i] = result;\n\t\t\t}\n\n\t\t\tif (elements){\n\t\t\t\telements.push.apply(elements, results);\n\t\t\t\treturn elements;\n\t\t\t}\n\t\t\t\n\t\t\treturn results;\n\t\t};\n\n\t\telementImplement.call(Element, key, fn);\n\t}\n};\n\n\/\/ elements\n\nvar Elements = Node.Elements = function(){\n\tthis.uids = {};\n\tif (arguments.length) this.push.apply(this, arguments);\n};\n\nElements.implement = function(key, fn){\n\tif (typeof key != 'string') for (var k in key) this.implement(k, key[k]); else {\n\t\tthis.prototype[key] = fn;\n\t}\n};\n\nElements.prototype = Object.create(Array.prototype);\n\nElements.implement({\n\t\n\tlength: 0,\n\t\n\tpush: function(){\n\t\tfor (var i = 0, l = arguments.length; i < l; i++){\n\t\t\tvar item = arguments[i], node = select(arguments[i]);\n\t\t\tif (node){\n\t\t\t\titem = node.valueOf();\n\t\t\t\tvar uid = item.uniqueNumber || Finder.uidOf(item);\n\t\t\t\tif (!this.uids[uid]) this[this.length++] = node;\n\t\t\t}\n\t\t}\n\t\treturn this.length;\n\t}\n\t\n});\n\n\/\/ standard methods\n\nElement.implement({\n\n\tappendChild: function(child){\n\t\tif ((child = select(child))) this.node.appendChild(child.valueOf());\n\t\treturn this;\n\t},\n\n\tsetAttribute: function(name, value){\n\t\tthis.node.setAttribute(name, value);\n\t\treturn this;\n\t},\n\n\tgetAttribute: function(name){\n\t\treturn this.node.getAttribute(name);\n\t},\n\t\n\tremoveAttribute: function(name){\n\t\tthis.node.removeAttribute(name);\n\t\treturn this;\n\t},\n\n\tcontains: function(node){\n\t\treturn ((node = select(node))) ? Slick.contains(this.node, node.valueOf()) : false;\n\t},\n\n\tmatch: function(expression){\n\t\treturn Slick.match(this.node, expression);\n\t}\n\n});\n\n\/\/ className methods\n\nvar classRegExps = {};\nvar classRegExpOf = function(string){\n\treturn classRegExps[string] || (classRegExps[string] = new RegExp('(^|\\\\s)' + Parser.escapeRegExp(string) + '(?:\\\\s|$)'));\n};\n\nElement.implement({\n\n\thasClass: function(className){\n\t\treturn classRegExpOf(className).test(this.node.className);\n\t},\n\n\taddClass: function(className){\n\t\tvar node = this.node;\n\t\tif (!this.hasClass(className)) node.className = String.clean(node.className + ' ' + className);\n\t\treturn this;\n\t},\n\n\tremoveClass: function(className){\n\t\tvar node = this.node;\n\t\tnode.className = String.clean(node.className.replace(classRegExpOf(className), '$1'));\n\t\treturn this;\n\t}\n\n});\n\n\/* Injections \/ Ejections *\/\n\nvar inserters = {\n\n\tbefore: function(context, element){\n\t\tvar parent = element.parentNode;\n\t\tif (parent) parent.insertBefore(context, element);\n\t},\n\n\tafter: function(context, element){\n\t\tvar parent = element.parentNode;\n\t\tif (parent) parent.insertBefore(context, element.nextSibling);\n\t},\n\n\tbottom: function(context, element){\n\t\telement.appendChild(context);\n\t},\n\n\ttop: function(context, element){\n\t\telement.insertBefore(context, element.firstChild);\n\t}\n\n};\n\nElement.implement({\n\n\tinject: function(element, where){\n\t\tif ((element = select(element))) inserters[where || 'bottom'](this.node, element.valueOf());\n\t\treturn this;\n\t},\n\n\teject: function(){\n\t\tvar parent = this.node.parentNode;\n\t\tif (parent) parent.removeChild(this.node);\n\t\treturn this;\n\t},\n\n\tadopt: function(){\n\t\tArray.forEach(arguments, function(element){\n\t\t\tif ((element = select(element))) this.node.appendChild(element.valueOf());\n\t\t}, this);\n\t\treturn this;\n\t},\n\n\tappendText: function(text, where){\n\t\tinserters[where || 'bottom'](document.createTextNode(text), this.node);\n\t\treturn this;\n\t},\n\n\tgrab: function(element, where){\n\t\tif ((element = select(element))) inserters[where || 'bottom'](element.valueOf(), this.node);\n\t\treturn this;\n\t},\n\n\treplace: function(element){\n\t\tif ((element = select(element))){\n\t\t\telement = element.valueOf();\n\t\t\telement.parentNode.replaceChild(this.node, element);\n\t\t}\n\t\treturn this;\n\t},\n\n\twrap: function(element, where){\n\t\treturn this.replace(element).grab(element, where);\n\t}\n\n});\n\nvar methods = {};\n\nObject.forEach(inserters, function(inserter, where){\n\n\tvar Where = String.capitalize(where);\n\n\tmethods['inject' + Where] = function(el){\n\t\treturn this.inject(el, where);\n\t};\n\n\tmethods['grab' + Where] = function(el){\n\t\treturn this.grab(el, where);\n\t};\n\n});\n\nElement.implement(methods);\n\n\/* Tree Walking *\/\n\nmethods = {\n\tfind: {\n\t\tgetNext: '~',\n\t\tgetPrevious: '!~',\n\t\tgetFirst: '^',\n\t\tgetLast: '!^',\n\t\tgetParent: '!'\n\t},\n\tsearch: {\n\t\tgetAllNext: '~',\n\t\tgetAllPrevious: '!~',\n\t\tgetSiblings: '~~',\n\t\tgetChildren: '>',\n\t\tgetParents: '!'\n\t}\n};\n\nObject.forEach(methods, function(getters, method){\n\tElement.implement(Object.map(getters, function(combinator){\n\t\treturn function(expression){\n\t\t\treturn this[method](combinator + (expression || '*'));\n\t\t};\n\t}));\n});\n\n\/* Attribute Getters, Setters, using Slick *\/\n\nAccessor.call(Element, 'Getter');\nAccessor.call(Element, 'Setter');\n\nvar properties = {};\n\nArray.forEach([\n\t'checked', 'defaultChecked', 'type', 'value', 'accessKey', 'cellPadding', 'cellSpacing', 'colSpan',\n\t'frameBorder', 'maxLength', 'readOnly', 'rowSpan', 'tabIndex', 'useMap',\n\t\/\/ Attributes\n\t'id', 'attributes', 'childNodes', 'className', 'clientHeight', 'clientLeft', 'clientTop', 'clientWidth', 'dir', 'firstChild',\n\t'lang', 'lastChild', 'name', 'nextSibling', 'nodeName', 'nodeType', 'nodeValue',\n\t'offsetHeight', 'offsetLeft', 'offsetParent', 'offsetTop', 'offsetWidth',\n\t'ownerDocument', 'parentNode', 'prefix', 'previousSibling', 'scrollHeight', 'scrollWidth', 'tabIndex', 'tagName',\n\t'textContent', 'innerHTML', 'title'\n], function(property){\n\tproperties[property] = property;\n});\n\nObject.append(properties, {\n\t'html': 'innerHTML',\n\t'class': 'className',\n\t'for': 'htmlFor',\n\t'text': (function(){\n\t\tvar temp = document.createElement('div');\n\t\treturn (temp.innerText == null) ? 'textContent' : 'innerText';\n\t})()\n});\n\nObject.forEach(properties, function(real, key){\n\tElement.defineSetter(key, function(value){\n\t\treturn this.node[real] = value;\n\t}).defineGetter(key, function(){\n\t\treturn this.node[real];\n\t});\n});\n\nvar booleans = ['compact', 'nowrap', 'ismap', 'declare', 'noshade', 'checked', 'disabled', 'multiple', 'readonly', 'selected', 'noresize', 'defer'];\n\nArray.forEach(booleans, function(bool){\n\tElement.defineSetter(bool, function(value){\n\t\treturn this.node[bool] = !!value;\n\t}).defineGetter(bool, function(){\n\t\treturn !!this.node[bool];\n\t});\n});\n\nElement.defineGetters({\n\n\t'class': function(){\n\t\tvar node = this.node;\n\t\treturn ('className' in node) ? node.className : node.getAttribute('class');\n\t},\n\n\t'for': function(){\n\t\tvar node = this.node;\n\t\treturn ('htmlFor' in node) ? node.htmlFor : node.getAttribute('for');\n\t},\n\n\t'href': function(){\n\t\tvar node = this.node;\n\t\treturn ('href' in node) ? node.getAttribute('href', 2) : node.getAttribute('href');\n\t},\n\n\t'style': function(){\n\t\tvar node = this.node;\n\t\treturn (node.style) ? node.style.cssText : node.getAttribute('style');\n\t}\n\n}).defineSetters({\n\n\t'class': function(value){\n\t\tvar node = this.node;\n\t\treturn ('className' in node) ? node.className = value : node.setAttribute('class', value);\n\t},\n\n\t'for': function(value){\n\t\tvar node = this.node;\n\t\treturn ('htmlFor' in node) ? node.htmlFor = value : node.setAttribute('for', value);\n\t},\n\n\t'style': function(value){\n\t\tvar node = this.node;\n\t\treturn (node.style) ? node.style.cssText = value : node.setAttribute('style', value);\n\t}\n\n});\n\n\/* get, set *\/\n\nElement.implement({\n\n\tset: function(name, value){\n\t\tif (typeof name != 'string') for (var k in name) this.set(k, name[k]); else {\n\t\t\tvar setter = Element.lookupSetter(name = String.camelCase(name));\n\t\t\tif (setter) setter.call(this, value);\n\t\t\telse if (value == null) this.node.removeAttribute(name);\n\t\t\telse this.node.setAttribute(name, value);\n\t\t}\n\t\treturn this;\n\t},\n\n\tget: function(name){\n\t\tif (arguments.length > 1) return Array.map(arguments, function(v, i){\n\t\t\treturn this.get(v);\n\t\t}, this);\n\t\tvar getter = Element.lookupGetter(name = String.camelCase(name));\n\t\tif (getter) return getter.call(this);\n\t\treturn this.node.getAttribute(name);\n\t}\n\n});\n\nElement.defineGetter('tag', function(){\n\treturn this.node.tagName.toLowerCase();\n});\n\n\/\/ return\n\nreturn Node;\n\n});\n","dependencies":["Core\/Core\/Class","Core\/Utility\/Object","Core\/Utility\/Array","Core\/Utility\/String","Core\/Slick\/Finder","Core\/Slick\/Parser","Core\/Data\/Accessor"]},"Core\/Core\/Class":{"id":"Core\/Core\/Class","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Core\/Class.js","package":"Core","amd":true,"content":"\/*\n---\nname: Class\ndescription: Contains the Class Function for easily creating, extending, and implementing reusable Classes.\n...\n*\/\n\ndefine(['..\/Utility\/typeOf', '..\/Host\/Object', '..\/Data\/Accessor', '..\/Utility\/merge'], function(typeOf, Object, Accessor){\n\nvar Class = function(params){\n\n\tif (!params) params = {};\n\t\n\tvar newClass = function(){\n\t\treturn (this.initialize) ? this.initialize.apply(this, arguments) : this;\n\t};\n\t\n\t\/\/Extends \"embedded\" mutator\n\tvar parent = (params.Extends) ? params.Extends : Class;\n\tdelete params.Extends;\n\tif (!parent.prototype instanceof Class) return new Error('\"Extends\" cannot be called with a function not inheriting from \"Class\"');\n\tvar instance = Object.create(parent.prototype);\n\tnewClass.parent = parent;\n\tnewClass.prototype = instance;\n\tnewClass.prototype.constructor = newClass;\n\n\tnewClass.implement = implement;\n\tnewClass.implement(params);\n\t\n\treturn newClass;\n};\n\nClass.prototype.parent = function(){\n\tif (!this.caller_) throw new Error('The method \"parent\" cannot be called.');\n\tvar name = this.caller_.name_, parent = this.caller_.owner_.parent;\n\tvar previous = (parent) ? parent.prototype[name] : null;\n\tif (!previous) throw new Error('The method \"' + name + '\" has no parent.');\n\treturn previous.apply(this, arguments);\n};\n\nvar classImplement = Class.implement = function(key, fn){\n\tif (typeof key != 'string') for (var k in key) classImplement.call(k, key[k]); else this.prototype[key] = fn;\n\treturn this;\n};\n\nvar wrap = function(self, key, method){\n\tif (method.origin_) method = method.origin_;\n\t\n\tvar wrapped = function(){\n\t\tif (method.protected_ && this.caller_ == null) throw new Error('The method \"' + key + '\" cannot be called.');\n\t\tvar old = this.caller_; this.caller_ = wrapped;\n\t\tvar result = method.apply(this, arguments);\n\t\tif (old != null) this.caller_ = old; else delete this._caller;\n\t\treturn result;\n\t};\n\t\n\twrapped.owner_ = self;\n\twrapped.name_ = key;\n\twrapped.origin_ = method;\n\t\n\treturn wrapped;\n};\n\nAccessor.call(Class, 'Mutator');\n\nvar implement_ = function(self, key, value, nowrap){\n\tvar mutator = Class.lookupMutator(key);\n\tif (mutator){\n\t\tvalue = mutator.call(self, value);\n\t\tif (value == null) return;\n\t}\n\tself.prototype[key] = (nowrap || typeOf(value) != 'function') ? value : wrap(self, key, value);\n};\n\nvar implement = function(item){\n\tswitch (typeOf(item)){\n\t\tcase 'string': implement_(this, item, arguments[1]); break;\n\t\tcase 'function':\n\t\t\tvar instance = Object.create(item.prototype);\n\t\t\tfor (var k in instance) implement_(this, k, instance[k], true);\n\t\tbreak;\n\t\tcase 'object': for (var o in item) implement_(this, o, item[o]); break;\n\t}\n\treturn this;\n};\n\nClass.defineMutator('Implements', function(items){\n\tif (typeOf(items) != 'array') items = [items];\n\tfor (var i = 0; i < items.length; i++) implement.call(this, items[i]);\n}).defineMutator(\/^protected\\s(\\w+)$\/, function(fn, name){\n\tfn.protected_ = true;\n\tthis.prototype[name] = wrap(this, name, fn);\n});\n\nreturn Class;\n\n});\n","dependencies":["Core\/Utility\/typeOf","Core\/Host\/Object","Core\/Data\/Accessor","Core\/Utility\/merge"]},"Core\/Utility\/typeOf":{"id":"Core\/Utility\/typeOf","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Utility\/typeOf.js","package":"Core","amd":true,"content":"\/*\n---\nname: typeOf\ndescription: type of\n...\n*\/\n\ndefine(function(){\n\t\nvar toString = Object.prototype.toString,\n\ttypes = {'[object Text]': 'textnode'},\n\t_types = 'Array,String,Function,Date,NodeList,Arguments,RegExp,Boolean'.split(',');\n\nfor (var i = _types.length; i--;) types['[object ' + _types[i] + ']'] = _types[i].toLowerCase();\n\nreturn function(item){\n\tif (item == null) return 'null';\n\n\tvar _class = toString.call(item), type = types[_class]; \n\tif (type) return type;\n\n\ttype = _class.slice(8, -1);\n\n\tif (type.slice(-7) == 'Element') return (types[_class] = 'element');\n\n\tif (type == 'Number') return isFinite(item) ? 'number' : 'null';\n\tif (type == 'Object'){\n\t\tif (item.nodeName){\n\t\t\tif (item.nodeType == 1) return 'element';\n\t\t\tif (item.nodeType == 3) return 'textnode';\n\t\t} else if (typeof item.length == 'number'){\n\t\t\tif (item.callee) return 'arguments';\n\t\t\tif ('item' in item) return 'nodelist';\n\t\t}\n\t}\n\n\treturn 'object';\n};\n\t\n});\n","dependencies":[]},"Core\/Host\/Object":{"id":"Core\/Host\/Object","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Host\/Object.js","package":"Core","amd":true,"content":"\/*\n---\nname: Object\ndescription: ES5 Object methods\n...\n*\/\n\ndefine(['..\/Core\/Host'], function(Host){\n\t\nvar Object_ = Host(Object), slice = Array.prototype.slice;\n\nvar prototypize = function(generic){\n\treturn (generic) ? function(){\n\t\treturn generic.apply(Object_, [this].concat(slice.call(arguments)));\n\t} : null;\n};\n\n\/\/methods that we want available in every environment\n\nObject_.implement({\n\n\tcreate: function(){\n\t\tvar F = function(){};\n\t\tF.prototype = this;\n\t\treturn new F;\n\t},\n\n\tkeys: function(){\n\t\tvar keys = [];\n\t\tfor (var key in this){\n\t\t\tif (this.hasOwnProperty(key)) keys.push(key);\n\t\t}\n\t\treturn keys;\n\t}\n\n});\n\n\/\/methods that we want available only on environments that already supports them on the native object\n\nvar names = 'defineProperty,defineProperties,getPrototypeOf,getOwnPropertyDescriptor,getOwnPropertyNames,preventExtensions,isExtensible,'\/\n'seal,isSealed,freeze,isFrozen'.split(',');\n\nfor (var i = 0; i < names.length; i++){\n\tvar name = names[i], method = Object[name];\n\tObject_.implement(name, prototypize(method));\n}\n\nreturn Object_;\n\n});\n","dependencies":["Core\/Core\/Host"]},"Core\/Core\/Host":{"id":"Core\/Core\/Host","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Core\/Host.js","package":"Core","amd":true,"content":"\/*\n---\nname: Host\ndescription: The Host object\n...\n*\/\n\ndefine(function(){\n\nvar slice = Array.prototype.slice;\n\n\/\/ Host class\n\nreturn function Host(guest){\n\n\tvar prototypes = {}, generics = {}, host = function(){\n\t\treturn guest.apply(guest, arguments);\n\t};\n\n\thost.install = function(object){\n\t\tobject = object || guest;\n\t\tfor (key in prototypes) if (!object.prototype[key]) object.prototype[key] = prototypes[key];\n\t\treturn this;\n\t};\n\n\tvar implement = host.implement = function(key, fn){\n\t\tif (typeof key != 'string') for (var k in key) implement.call(this, k, key[k]); else if (!this.prototype[key] && fn){\n\t\t\tvar proto = this.prototype[key] = prototypes[key] = (guest.prototype[key] || fn);\n\t\t\textend.call(this, key, function(){\n\t\t\t\tvar args = slice.call(arguments);\n\t\t\t\treturn proto.apply(args.shift(0), args);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t};\n\n\tvar extend = host.extend = function(key, fn){\n\t\tif (typeof key != 'string') for (var k in key) extend.call(this, k, key[k]);\n\t\telse if (!this[key] && fn) generics[key] = this[key] = (guest[key] || fn);\n\t\treturn this;\n\t};\n\n\treturn host;\n\n};\n\n});\n","dependencies":[]},"Core\/Data\/Accessor":{"id":"Core\/Data\/Accessor","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Data\/Accessor.js","package":"Core","amd":true,"content":"\/*\n---\nname: Accessor\ndescription: Access things\n...\n*\/\n\ndefine(['..\/Utility\/typeOf', '..\/Utility\/Object', '..\/Host\/Array'], function(typeOf, Object, Array){\n\nreturn function(singular, plural){\n\n\tvar accessor = {}, matchers = [];\n\n\tif (!plural) plural = singular + 's';\n\n\tvar define = 'define', lookup = 'lookup', match = 'match', each = 'each';\n\n\tvar defineSingular = this[define + singular] = function(key, value){\n\t\tif (typeOf(key) == 'regexp') matchers.push({'regexp': key, 'value': value, 'type': typeOf(value)});\n\t\telse accessor[key] = value;\n\t\treturn this;\n\t};\n\n\tvar definePlural = this[define + plural] = function(object){\n\t\tfor (var key in object) accessor[key] = object[key];\n\t\treturn this;\n\t};\n\n\tvar lookupSingular = this[lookup + singular] = function(key){\n\t\tif (accessor.hasOwnProperty(key)) return accessor[key];\n\t\tfor (var l = matchers.length; l--; l){\n\t\t\tvar matcher = matchers[l], matched = key.match(matcher.regexp);\n\t\t\tif (matched && (matched = matched.slice(1))){\n\t\t\t\tif (matcher.type == 'function') return function(){\n\t\t\t\t\treturn matcher.value.apply(this, Array.slice(arguments).concat(matched));\n\t\t\t\t}; else return matcher.value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\tvar lookupPlural = this[lookup + plural] = function(){\n\t\tvar results = {};\n\t\tfor (var i = 0; i < arguments.length; i++){\n\t\t\tvar argument = arguments[i];\n\t\t\tresults[argument] = lookupSingular(argument);\n\t\t}\n\t\treturn result;\n\t};\n\n\tvar eachSingular = this[each + singular] = function(fn, bind){\n\t\tObject.forEach(accessor, fn, bind);\n\t};\n\n};\n\n});\n","dependencies":["Core\/Utility\/typeOf","Core\/Utility\/Object","Core\/Host\/Array"]},"Core\/Utility\/Object":{"id":"Core\/Utility\/Object","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Utility\/Object.js","package":"Core","amd":true,"content":"\/*\n---\nname: Object\ndescription: custom Object prototypes and generics\n...\n*\/\n\ndefine(['..\/Host\/Object'], function(Object){\n\nObject.extend({\n\n\tisEnumerable: function(self){\n\t\treturn (self != null && typeof self == 'object' && typeof self.length == 'number');\n\t}\n\n});\n\nObject.implement({\n\t\n\tforEach: function(fn, context){\n\t\tfor (var key in this){\n\t\t\tif (this.hasOwnProperty(key)) fn.call(context, this[key], key, this);\n\t\t}\n\t},\n\n\tgetLength: function(){\n\t\tvar length = 0;\n\t\tfor (var key in this) length++;\n\t\treturn length;\n\t},\n\n\tappend: function(){\n\t\tfor (var i = 0, l = arguments.length; i < l; i++){\n\t\t\tvar extended = arguments[i] || {};\n\t\t\tfor (var key in extended) this[key] = extended[key];\n\t\t}\n\t\treturn this;\n\t},\n\n\tsubset: function(keys){\n\t\tvar results = {};\n\t\tfor (var i = 0, l = keys.length; i < l; i++){\n\t\t\tvar k = keys[i], value = this[k];\n\t\t\tresults[k] = (value != null) ? value : null;\n\t\t}\n\t\treturn results;\n\t},\n\n\tmap: function(fn, bind){\n\t\tvar results = {};\n\t\tfor (var key in this) results[key] = fn.call(bind, this[key], key, this);\n\t\treturn results;\n\t},\n\n\tfilter: function(fn, bind){\n\t\tvar results = {};\n\t\tfor (var key in this){\n\t\t\tif (fn.call(bind, this[key], key, this)) results[key] = this[key];\n\t\t}\n\t\treturn results;\n\t},\n\n\tevery: function(fn, bind){\n\t\tfor (var key in this){\n\t\t\tif (!fn.call(bind, this[key], key)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tsome: function(fn, bind){\n\t\tfor (var key in this){\n\t\t\tif (fn.call(bind, this[key], key)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tvalues: function(){\n\t\tvar values = [];\n\t\tfor (var key in this){\n\t\t\tif (this.hasOwnProperty(key)) values.push(this[key]);\n\t\t}\n\t\treturn values;\n\t},\n\n\tkeyOf: function(value){\n\t\tfor (var key in this){\n\t\t\tif (this.hasOwnProperty(key) && this[key] === value) return key;\n\t\t}\n\t\treturn null;\n\t},\n\n\tcontains: function(value){\n\t\treturn Object.keyOf(this, value) != null;\n\t}\n\n});\n\nreturn Object;\n\n});\n","dependencies":["Core\/Host\/Object"]},"Core\/Host\/Array":{"id":"Core\/Host\/Array","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Host\/Array.js","package":"Core","amd":true,"content":"\/*\n---\nname: Array\ndescription: ES5 Array methods\n...\n*\/\n\ndefine(['..\/Core\/Host'], function(Host){\n\n\/\/methods that we want available only on environments that already supports them on the native object\n\nvar names = 'pop,push,reverse,shift,sort,splice,unshift,concat,join,slice,lastIndexOf,reduce,reduceRight'.split(','),\n\ti = names.length, proto = Array.prototype, Array_ = Host(Array);\n\nwhile (i--) Array_.implement(names[i], proto[names[i]]);\n\nreturn Array_.implement({\n\n\t\/\/methods that we want available in every environment\n\n\tfilter: function(fn, bind){\n\t\tvar results = [];\n\t\tfor (var i = 0, l = this.length; i < l; i++){\n\t\t\tif ((i in this) && fn.call(bind, this[i], i, this)) results.push(this[i]);\n\t\t}\n\t\treturn results;\n\t},\n\n\tindexOf: function(item, from){\n\t\tfor (var l = this.length, i = (from < 0) ? Math.max(0, l + from) : from || 0; i < l; i++){\n\t\t\tif (this[i] === item) return i;\n\t\t}\n\t\treturn -1;\n\t},\n\n\tmap: function(fn, bind){\n\t\tvar results = [];\n\t\tfor (var i = 0, l = this.length; i < l; i++){\n\t\t\tif (i in this) results[i] = fn.call(bind, this[i], i, this);\n\t\t}\n\t\treturn results;\n\t},\n\n\tevery: function(fn, bind){\n\t\tfor (var i = 0, l = this.length; i < l; i++){\n\t\t\tif ((i in this) && !fn.call(bind, this[i], i, this)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tsome: function(fn, bind){\n\t\tfor (var i = 0, l = this.length; i < l; i++){\n\t\t\tif ((i in this) && fn.call(bind, this[i], i, this)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tforEach: function(fn, context){\n\t\tfor (var i = 0, l = this.length; i < l; i++){\n\t\t\tif (i in this) fn.call(context, this[i], i, this);\n\t\t}\n\t}\n\n});\n\t\n});\n","dependencies":["Core\/Core\/Host"]},"Core\/Utility\/merge":{"id":"Core\/Utility\/merge","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Utility\/merge.js","package":"Core","amd":true,"content":"\/*\n---\nname: merge\ndescription: merge things\n...\n*\/\n\ndefine(['.\/typeOf', '..\/Host\/Object'], function(typeOf, Object){\n\t\nvar merge = function(self, key, value){\n\tif (typeof key == 'string'){\n\t\tif (typeOf(self[key]) == 'object' && typeOf(value) == 'object') merge(self[key], value);\n\t\telse self[key] = value;\n\t} else for (var i = 1, l = arguments.length; i < l; i++){\n\t\tvar object = arguments[i];\n\t\tfor (var k in object) merge(self, k, object[k]);\n\t}\n\treturn self;\n};\n\nObject.extend('merge', merge).implement('merge', function(key, value){\n\treturn merge(this, key, value);\n});\n\nreturn merge;\n\t\n});\n","dependencies":["Core\/Utility\/typeOf","Core\/Host\/Object"]},"Core\/Utility\/Array":{"id":"Core\/Utility\/Array","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Utility\/Array.js","package":"Core","amd":true,"content":"\/*\n---\nname: Array\ndescription: Custom Array prototypes and generics.\n...\n*\/\n\ndefine(['..\/Host\/Array'], function(Array){\n\nArray.implement({\n\n\tinvoke: function(name){\n\t\tvar args = Array.slice(arguments, 1), results = [];\n\t\tfor (var i = 0, j = this.length; i < j; i++){\n\t\t\tvar item = this[i];\n\t\t\tresults.push(item[name].apply(item, args));\n\t\t}\n\t\treturn results;\n\t},\n\n\tappend: function(array){\n\t\tthis.push.apply(this, array);\n\t\treturn this;\n\t},\n\n\tcontains: function(item, from){\n\t\treturn Array.indexOf(this, item, from) != -1;\n\t},\n\n\tlast: function(){\n\t\tvar length = this.length;\n\t\treturn (length) ? this[length - 1] : null;\n\t},\n\n\trandom: function(){\n\t\tvar length = this.length;\n\t\treturn (length) ? this[Math.floor(Math.random() * length)] : null;\n\t},\n\n\tinclude: function(item){\n\t\tif (!Array.contains(this, item)) this.push(item);\n\t\treturn this;\n\t},\n\n\terase: function(item){\n\t\tfor (var i = this.length; i--; i){\n\t\t\tif (this[i] === item) this.splice(i, 1);\n\t\t}\n\t\treturn this;\n\t},\n\n\titem: function(at){\n\t\tvar length = this.length;\n\t\tif (at < 0) at = (at % length) + length;\n\t\treturn (at < 0 || at >= length || this[at] == null) ? null : this[at];\n\t}\n\n});\n\nreturn Array;\n\t\n});\n","dependencies":["Core\/Host\/Array"]},"Core\/Utility\/String":{"id":"Core\/Utility\/String","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Utility\/String.js","package":"Core","amd":true,"content":"\/*\n---\nname: String\ndescription: custom String prototypes and generics.\n...\n*\/\n\ndefine(['..\/Host\/String'], function(String){\n\nString.implement({\n\n\tcontains: function(string, separator){\n\t\treturn ((separator) ? (separator + this + separator).indexOf(separator + string + separator) : (this + '').indexOf(string)) > -1;\n\t},\n\n\tclean: function(){\n\t\treturn String.trim((this + '').replace(\/\\s+\/g, ' '));\n\t},\n\n\tcamelCase: function(){\n\t\treturn (this + '').replace(\/-\\D\/g, function(match){\n\t\t\treturn match.charAt(1).toUpperCase();\n\t\t});\n\t},\n\n\thyphenate: function(){\n\t\treturn (this + '').replace(\/[A-Z]\/g, function(match){\n\t\t\treturn '-' + match.toLowerCase();\n\t\t});\n\t},\n\n\tcapitalize: function(){\n\t\treturn (this + '').replace(\/\\b[a-z]\/g, function(match){\n\t\t\treturn match.toUpperCase();\n\t\t});\n\t}\n\n});\n\nreturn String;\n\n});\n","dependencies":["Core\/Host\/String"]},"Core\/Host\/String":{"id":"Core\/Host\/String","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Host\/String.js","package":"Core","amd":true,"content":"\/*\n---\nname: String\ndescription: ES5 String methods\n...\n*\/\n\ndefine(['..\/Core\/Host'], function(Host){\n\nvar names = 'charAt,charCodeAt,concat,indexOf,lastIndexOf,match,quote,replace,search,slice,split,substr,substring,toLowerCase,toUpperCase'.split(','),\n\ti = names.length, String_ = Host(String), proto = String.prototype;\n\nwhile (i--) String_.implement(names[i], proto[names[i]]);\n\nString_.implement('trim', function(){\n\treturn (this + '').replace(\/^\\s+|\\s+$\/g, '');\n});\n\nreturn String_;\n\n});\n","dependencies":["Core\/Core\/Host"]},"Core\/Slick\/Finder":{"id":"Core\/Slick\/Finder","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Slick\/Finder.js","package":"Core","amd":true,"content":"\/*\n---\nname: Finder\ndescription: The new, superfast css selector engine.\n...\n*\/\n\ndefine(['.\/Parser'], function(Parser){\n\t\nvar Finder = {}, local = {},\n\tfeaturesCache = {},\n\ttoString = Object.prototype.toString;\n\n\/\/ Feature \/ Bug detection\n\nlocal.isNativeCode = function(fn){\n\treturn (\/\\{\\s*\\[native code\\]\\s*\\}\/).test('' + fn);\n};\n\nlocal.isXML = function(document){\n\treturn (!!document.xmlVersion) || (!!document.xml) || (toString.call(document) == '[object XMLDocument]') ||\n\t(document.nodeType == 9 && document.documentElement.nodeName != 'HTML');\n};\n\nlocal.setDocument = function(document){\n\n\t\/\/ convert elements \/ window arguments to document. if document cannot be extrapolated, the function returns.\n\tvar nodeType = document.nodeType;\n\tif (nodeType == 9); \/\/ document\n\telse if (nodeType) document = document.ownerDocument; \/\/ node\n\telse if (document.navigator) document = document.document; \/\/ window\n\telse return;\n\n\t\/\/ check if it's the old document\n\n\tif (this.document === document) return;\n\tthis.document = document;\n\n\t\/\/ check if we have done feature detection on this document before\n\n\tvar root = document.documentElement,\n\t\trootUid = this.getUIDXML(root),\n\t\tfeatures = featuresCache[rootUid],\n\t\tfeature;\n\n\tif (features){\n\t\tfor (feature in features){\n\t\t\tthis[feature] = features[feature];\n\t\t}\n\t\treturn;\n\t}\n\n\tfeatures = featuresCache[rootUid] = {};\n\n\tfeatures.root = root;\n\tfeatures.isXMLDocument = this.isXML(document);\n\n\tfeatures.brokenStarGEBTN\n\t= features.starSelectsClosedQSA\n\t= features.idGetsName\n\t= features.brokenMixedCaseQSA\n\t= features.brokenGEBCN\n\t= features.brokenCheckedQSA\n\t= features.brokenEmptyAttributeQSA\n\t= features.isHTMLDocument\n\t= features.nativeMatchesSelector\n\t= false;\n\n\tvar starSelectsClosed, starSelectsComments,\n\t\tbrokenSecondClassNameGEBCN, cachedGetElementsByClassName,\n\t\tbrokenFormAttributeGetter;\n\n\tvar selected, id = 'slick_uniqueid';\n\tvar testNode = document.createElement('div');\n\t\n\tvar testRoot = document.body || document.getElementsByTagName('body')[0] || root;\n\ttestRoot.appendChild(testNode);\n\n\t\/\/ on non-HTML documents innerHTML and getElementsById doesnt work properly\n\ttry {\n\t\ttestNode.innerHTML = '<a id=\"'+id+'\"><\/a>';\n\t\tfeatures.isHTMLDocument = !!document.getElementById(id);\n\t} catch(e){};\n\n\tif (features.isHTMLDocument){\n\n\t\ttestNode.style.display = 'none';\n\n\t\t\/\/ IE returns comment nodes for getElementsByTagName('*') for some documents\n\t\ttestNode.appendChild(document.createComment(''));\n\t\tstarSelectsComments = (testNode.getElementsByTagName('*').length > 1);\n\n\t\t\/\/ IE returns closed nodes (EG:\"<\/foo>\") for getElementsByTagName('*') for some documents\n\t\ttry {\n\t\t\ttestNode.innerHTML = 'foo<\/foo>';\n\t\t\tselected = testNode.getElementsByTagName('*');\n\t\t\tstarSelectsClosed = (selected && !!selected.length && selected[0].nodeName.charAt(0) == '\/');\n\t\t} catch(e){};\n\n\t\tfeatures.brokenStarGEBTN = starSelectsComments || starSelectsClosed;\n\n\t\t\/\/ IE returns elements with the name instead of just id for getElementsById for some documents\n\t\ttry {\n\t\t\ttestNode.innerHTML = '<a name=\"'+ id +'\"><\/a><b id=\"'+ id +'\"><\/b>';\n\t\t\tfeatures.idGetsName = document.getElementById(id) === testNode.firstChild;\n\t\t} catch(e){};\n\n\t\tif (testNode.getElementsByClassName){\n\n\t\t\t\/\/ Safari 3.2 getElementsByClassName caches results\n\t\t\ttry {\n\t\t\t\ttestNode.innerHTML = '<a class=\"f\"><\/a><a class=\"b\"><\/a>';\n\t\t\t\ttestNode.getElementsByClassName('b').length;\n\t\t\t\ttestNode.firstChild.className = 'b';\n\t\t\t\tcachedGetElementsByClassName = (testNode.getElementsByClassName('b').length != 2);\n\t\t\t} catch(e){};\n\n\t\t\t\/\/ Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one\n\t\t\ttry {\n\t\t\t\ttestNode.innerHTML = '<a class=\"a\"><\/a><a class=\"f b a\"><\/a>';\n\t\t\t\tbrokenSecondClassNameGEBCN = (testNode.getElementsByClassName('a').length != 2);\n\t\t\t} catch(e){};\n\n\t\t\tfeatures.brokenGEBCN = cachedGetElementsByClassName || brokenSecondClassNameGEBCN;\n\t\t}\n\t\t\n\t\tif (testNode.querySelectorAll){\n\t\t\t\/\/ IE 8 returns closed nodes (EG:\"<\/foo>\") for querySelectorAll('*') for some documents\n\t\t\ttry {\n\t\t\t\ttestNode.innerHTML = 'foo<\/foo>';\n\t\t\t\tselected = testNode.querySelectorAll('*');\n\t\t\t\tfeatures.starSelectsClosedQSA = (selected && !!selected.length && selected[0].nodeName.charAt(0) == '\/');\n\t\t\t} catch(e){};\n\n\t\t\t\/\/ Safari 3.2 querySelectorAll doesnt work with mixedcase on quirksmode\n\t\t\ttry {\n\t\t\t\ttestNode.innerHTML = '<a class=\"MiX\"><\/a>';\n\t\t\t\tfeatures.brokenMixedCaseQSA = !testNode.querySelectorAll('.MiX').length;\n\t\t\t} catch(e){};\n\n\t\t\t\/\/ Webkit and Opera dont return selected options on querySelectorAll\n\t\t\ttry {\n\t\t\t\ttestNode.innerHTML = '<select><option selected=\"selected\">a<\/option><\/select>';\n\t\t\t\tfeatures.brokenCheckedQSA = (testNode.querySelectorAll(':checked').length == 0);\n\t\t\t} catch(e){};\n\n\t\t\t\/\/ IE returns incorrect results for attr[*^$]=\"\" selectors on querySelectorAll\n\t\t\ttry {\n\t\t\t\ttestNode.innerHTML = '<a class=\"\"><\/a>';\n\t\t\t\tfeatures.brokenEmptyAttributeQSA = (testNode.querySelectorAll('[class*=\"\"]').length != 0);\n\t\t\t} catch(e){};\n\n\t\t}\n\n\t\t\/\/ IE6-7, if a form has an input of id x, form.getAttribute(x) returns a reference to the input\n\t\ttry {\n\t\t\ttestNode.innerHTML = '<form action=\"s\"><input id=\"action\"\/><\/form>';\n\t\t\tbrokenFormAttributeGetter = (testNode.firstChild.getAttribute('action') != 's');\n\t\t} catch(e){};\n\n\t\t\/\/ native matchesSelector function\n\n\t\tfeatures.nativeMatchesSelector = root.matchesSelector || \/*root.msMatchesSelector ||*\/ root.mozMatchesSelector || root.webkitMatchesSelector;\n\t\tif (features.nativeMatchesSelector) try {\n\t\t\t\/\/ if matchesSelector trows errors on incorrect sintaxes we can use it\n\t\t\tfeatures.nativeMatchesSelector.call(root, ':slick');\n\t\t\tfeatures.nativeMatchesSelector = null;\n\t\t} catch(e){};\n\n\t}\n\n\ttry {\n\t\troot.slick_expando = 1;\n\t\tdelete root.slick_expando;\n\t\tfeatures.getUID = this.getUIDHTML;\n\t} catch(e) {\n\t\tfeatures.getUID = this.getUIDXML;\n\t}\n\n\ttestRoot.removeChild(testNode);\n\ttestNode = selected = testRoot = null;\n\n\t\/\/ getAttribute\n\n\tfeatures.getAttribute = (features.isHTMLDocument && brokenFormAttributeGetter) ? function(node, name){\n\t\tvar method = this.attributeGetters[name];\n\t\tif (method) return method.call(node);\n\t\tvar attributeNode = node.getAttributeNode(name);\n\t\treturn (attributeNode) ? attributeNode.nodeValue : null;\n\t} : function(node, name){\n\t\tvar method = this.attributeGetters[name];\n\t\treturn (method) ? method.call(node) : node.getAttribute(name);\n\t};\n\n\t\/\/ hasAttribute\n\n\tfeatures.hasAttribute = (root && this.isNativeCode(root.hasAttribute)) ? function(node, attribute) {\n\t\treturn node.hasAttribute(attribute);\n\t} : function(node, attribute) {\n\t\tnode = node.getAttributeNode(attribute);\n\t\treturn !!(node && (node.specified || node.nodeValue));\n\t};\n\n\t\/\/ contains\n\t\/\/ FIXME: Add specs: local.contains should be different for xml and html documents?\n\tfeatures.contains = (root && this.isNativeCode(root.contains)) ? function(context, node){\n\t\treturn context.contains(node);\n\t} : (root && root.compareDocumentPosition) ? function(context, node){\n\t\treturn context === node || !!(context.compareDocumentPosition(node) & 16);\n\t} : function(context, node){\n\t\tif (node) do {\n\t\t\tif (node === context) return true;\n\t\t} while ((node = node.parentNode));\n\t\treturn false;\n\t};\n\n\t\/\/ document order sorting\n\t\/\/ credits to Sizzle (http:\/\/sizzlejs.com\/)\n\n\tfeatures.documentSorter = (root.compareDocumentPosition) ? function(a, b){\n\t\tif (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0;\n\t\treturn a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;\n\t} : ('sourceIndex' in root) ? function(a, b){\n\t\tif (!a.sourceIndex || !b.sourceIndex) return 0;\n\t\treturn a.sourceIndex - b.sourceIndex;\n\t} : (document.createRange) ? function(a, b){\n\t\tif (!a.ownerDocument || !b.ownerDocument) return 0;\n\t\tvar aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();\n\t\taRange.setStart(a, 0);\n\t\taRange.setEnd(a, 0);\n\t\tbRange.setStart(b, 0);\n\t\tbRange.setEnd(b, 0);\n\t\treturn aRange.compareBoundaryPoints(Range.START_TO_END, bRange);\n\t} : null ;\n\n\troot = null;\n\n\tfor (feature in features){\n\t\tthis[feature] = features[feature];\n\t}\n};\n\n\/\/ Main Method\n\nvar reSimpleSelector = \/^([#.]?)((?:[\\w-]+|\\*))$\/,\n\treEmptyAttribute = \/\\[.+[*$^]=(?:\"\"|'')?\\]\/,\n\tqsaFailExpCache = {};\n\nlocal.search = function(context, expression, append, first){\n\n\tvar found = this.found = (first) ? null : (append || []);\n\t\n\tif (!context) return found;\n\telse if (context.navigator) context = context.document; \/\/ Convert the node from a window to a document\n\telse if (!context.nodeType) return found;\n\n\t\/\/ setup\n\n\tvar parsed, i,\n\t\tuniques = this.uniques = {},\n\t\thasOthers = !!(append && append.length),\n\t\tcontextIsDocument = (context.nodeType == 9);\n\n\tif (this.document !== (contextIsDocument ? context : context.ownerDocument)) this.setDocument(context);\n\n\t\/\/ avoid duplicating items already in the append array\n\tif (hasOthers) for (i = found.length; i--;) uniques[this.getUID(found[i])] = true;\n\n\t\/\/ expression checks\n\n\tif (typeof expression == 'string'){ \/\/ expression is a string\n\n\t\t\/*<simple-selectors-override>*\/\n\t\tvar simpleSelector = expression.match(reSimpleSelector);\n\t\tsimpleSelectors: if (simpleSelector) {\n\n\t\t\tvar symbol = simpleSelector[1],\n\t\t\t\tname = simpleSelector[2],\n\t\t\t\tnode, nodes;\n\n\t\t\tif (!symbol){\n\n\t\t\t\tif (name == '*' && this.brokenStarGEBTN) break simpleSelectors;\n\t\t\t\tnodes = context.getElementsByTagName(name);\n\t\t\t\tif (first) return nodes[0] || null;\n\t\t\t\tfor (i = 0; node = nodes[i++];){\n\t\t\t\t\tif (!(hasOthers && uniques[this.getUID(node)])) found.push(node);\n\t\t\t\t}\n\n\t\t\t} else if (symbol == '#'){\n\n\t\t\t\tif (!this.isHTMLDocument || !contextIsDocument) break simpleSelectors;\n\t\t\t\tnode = context.getElementById(name);\n\t\t\t\tif (!node) return found;\n\t\t\t\tif (this.idGetsName && node.getAttributeNode('id').nodeValue != name) break simpleSelectors;\n\t\t\t\tif (first) return node || null;\n\t\t\t\tif (!(hasOthers && uniques[this.getUID(node)])) found.push(node);\n\n\t\t\t} else if (symbol == '.'){\n\n\t\t\t\tif (!this.isHTMLDocument || ((!context.getElementsByClassName || this.brokenGEBCN) && context.querySelectorAll)) break simpleSelectors;\n\t\t\t\tif (context.getElementsByClassName && !this.brokenGEBCN){\n\t\t\t\t\tnodes = context.getElementsByClassName(name);\n\t\t\t\t\tif (first) return nodes[0] || null;\n\t\t\t\t\tfor (i = 0; node = nodes[i++];){\n\t\t\t\t\t\tif (!(hasOthers && uniques[this.getUID(node)])) found.push(node);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar matchClass = new RegExp('(^|\\\\s)'+ Parser.escapeRegExp(name) +'(\\\\s|$)');\n\t\t\t\t\tnodes = context.getElementsByTagName('*');\n\t\t\t\t\tfor (i = 0; node = nodes[i++];){\n\t\t\t\t\t\tclassName = node.className;\n\t\t\t\t\t\tif (!(className && matchClass.test(className))) continue;\n\t\t\t\t\t\tif (first) return node;\n\t\t\t\t\t\tif (!(hasOthers && uniques[this.getUID(node)])) found.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (hasOthers) this.sort(found);\n\t\t\treturn (first) ? null : found;\n\n\t\t}\n\t\t\/*<\/simple-selectors-override>*\/\n\n\t\t\/*<query-selector-override>*\/\n\t\tquerySelector: if (context.querySelectorAll) {\n\n\t\t\tif (!this.isHTMLDocument || this.brokenMixedCaseQSA || qsaFailExpCache[expression] ||\n\t\t\t(this.brokenCheckedQSA && expression.indexOf(':checked') > -1) ||\n\t\t\t(this.brokenEmptyAttributeQSA && reEmptyAttribute.test(expression)) || Finder.disableQSA) break querySelector;\n\n\t\t\tvar _expression = expression;\n\t\t\tif (!contextIsDocument){\n\t\t\t\t\/\/ non-document rooted QSA\n\t\t\t\t\/\/ credits to Andrew Dupont\n\t\t\t\tvar currentId = context.getAttribute('id'), slickid = 'slickid__';\n\t\t\t\tcontext.setAttribute('id', slickid);\n\t\t\t\t_expression = '#' + slickid + ' ' + _expression;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (first) return context.querySelector(_expression) || null;\n\t\t\t\telse nodes = context.querySelectorAll(_expression);\n\t\t\t} catch(e) {\n\t\t\t\tqsaFailExpCache[expression] = 1;\n\t\t\t\tbreak querySelector;\n\t\t\t} finally {\n\t\t\t\tif (!contextIsDocument){\n\t\t\t\t\tif (currentId) context.setAttribute('id', currentId);\n\t\t\t\t\telse context.removeAttribute('id');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.starSelectsClosedQSA) for (i = 0; node = nodes[i++];){\n\t\t\t\tif (node.nodeName > '@' && !(hasOthers && uniques[this.getUID(node)])) found.push(node);\n\t\t\t} else for (i = 0; node = nodes[i++];){\n\t\t\t\tif (!(hasOthers && uniques[this.getUID(node)])) found.push(node);\n\t\t\t}\n\n\t\t\tif (hasOthers) this.sort(found);\n\t\t\treturn found;\n\n\t\t}\n\t\t\/*<\/query-selector-override>*\/\n\n\t\tparsed = Parser.parse(expression);\n\t\tif (!parsed.length) return found;\n\t} else if (expression == null){ \/\/ there is no expression\n\t\treturn found;\n\t} else if (expression.Slick){ \/\/ expression is a parsed Slick object\n\t\tparsed = expression;\n\t} else if (this.contains(context.documentElement || context, expression)){ \/\/ expression is a node\n\t\t(found) ? found.push(expression) : found = expression;\n\t\treturn found;\n\t} else { \/\/ other junk\n\t\treturn found;\n\t}\n\n\t\/*<pseudo-selectors>*\/\/*<nth-pseudo-selectors>*\/\n\n\t\/\/ cache elements for the nth selectors\n\n\tthis.posNTH = {};\n\tthis.posNTHLast = {};\n\tthis.posNTHType = {};\n\tthis.posNTHTypeLast = {};\n\n\t\/*<\/nth-pseudo-selectors>*\/\/*<\/pseudo-selectors>*\/\n\n\t\/\/ if append is null and there is only a single selector with one expression use pushArray, else use pushUID\n\tthis.push = (!hasOthers && (first || (parsed.length == 1 && parsed.expressions[0].length == 1))) ? this.pushArray : this.pushUID;\n\n\tif (found == null) found = [];\n\n\t\/\/ default engine\n\n\tvar j, m, n;\n\tvar combinator, tag, id, classList, classes, attributes, pseudos;\n\tvar currentItems, currentExpression, currentBit, lastBit, expressions = parsed.expressions;\n\n\tsearch: for (i = 0; (currentExpression = expressions[i]); i++) for (j = 0; (currentBit = currentExpression[j]); j++){\n\n\t\tcombinator = 'combinator:' + currentBit.combinator;\n\t\tif (!this[combinator]) continue search;\n\n\t\ttag        = (this.isXMLDocument) ? currentBit.tag : currentBit.tag.toUpperCase();\n\t\tid         = currentBit.id;\n\t\tclassList  = currentBit.classList;\n\t\tclasses    = currentBit.classes;\n\t\tattributes = currentBit.attributes;\n\t\tpseudos    = currentBit.pseudos;\n\t\tlastBit    = (j === (currentExpression.length - 1));\n\n\t\tthis.bitUniques = {};\n\n\t\tif (lastBit){\n\t\t\tthis.uniques = uniques;\n\t\t\tthis.found = found;\n\t\t} else {\n\t\t\tthis.uniques = {};\n\t\t\tthis.found = [];\n\t\t}\n\n\t\tif (j === 0){\n\t\t\tthis[combinator](context, tag, id, classes, attributes, pseudos, classList);\n\t\t\tif (first && lastBit && found.length) break search;\n\t\t} else {\n\t\t\tif (first && lastBit) for (m = 0, n = currentItems.length; m < n; m++){\n\t\t\t\tthis[combinator](currentItems[m], tag, id, classes, attributes, pseudos, classList);\n\t\t\t\tif (found.length) break search;\n\t\t\t} else for (m = 0, n = currentItems.length; m < n; m++) this[combinator](currentItems[m], tag, id, classes, attributes, pseudos, classList);\n\t\t}\n\n\t\tcurrentItems = this.found;\n\t}\n\n\t\/\/ should sort if there are nodes in append and if you pass multiple expressions.\n\tif (hasOthers || (parsed.expressions.length > 1)) this.sort(found);\n\n\treturn (first) ? (found[0] || null) : found;\n};\n\n\/\/ Utils\n\nlocal.uidx = 1;\nlocal.uidk = 'slick-uniqueid';\n\nlocal.getUIDXML = function(node){\n\tvar uid = node.getAttribute(this.uidk);\n\tif (!uid){\n\t\tuid = this.uidx++;\n\t\tnode.setAttribute(this.uidk, uid);\n\t}\n\treturn uid;\n};\n\nlocal.getUIDHTML = function(node){\n\treturn node.uniqueNumber || (node.uniqueNumber = this.uidx++);\n};\n\n\/\/ sort based on the setDocument documentSorter method.\n\nlocal.sort = function(results){\n\tif (!this.documentSorter) return results;\n\tresults.sort(this.documentSorter);\n\treturn results;\n};\n\n\/*<pseudo-selectors>*\/\/*<nth-pseudo-selectors>*\/\n\nlocal.cacheNTH = {};\n\nlocal.matchNTH = \/^([+-]?\\d*)?([a-z]+)?([+-]\\d+)?$\/;\n\nlocal.parseNTHArgument = function(argument){\n\tvar parsed = argument.match(this.matchNTH);\n\tif (!parsed) return false;\n\tvar special = parsed[2] || false;\n\tvar a = parsed[1] || 1;\n\tif (a == '-') a = -1;\n\tvar b = +parsed[3] || 0;\n\tparsed =\n\t\t(special == 'n')\t? {a: a, b: b} :\n\t\t(special == 'odd')\t? {a: 2, b: 1} :\n\t\t(special == 'even')\t? {a: 2, b: 0} : {a: 0, b: a};\n\n\treturn (this.cacheNTH[argument] = parsed);\n};\n\nlocal.createNTHPseudo = function(child, sibling, positions, ofType){\n\treturn function(node, argument){\n\t\tvar uid = this.getUID(node);\n\t\tif (!this[positions][uid]){\n\t\t\tvar parent = node.parentNode;\n\t\t\tif (!parent) return false;\n\t\t\tvar el = parent[child], count = 1;\n\t\t\tif (ofType){\n\t\t\t\tvar nodeName = node.nodeName;\n\t\t\t\tdo {\n\t\t\t\t\tif (el.nodeName != nodeName) continue;\n\t\t\t\t\tthis[positions][this.getUID(el)] = count++;\n\t\t\t\t} while ((el = el[sibling]));\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif (el.nodeType != 1) continue;\n\t\t\t\t\tthis[positions][this.getUID(el)] = count++;\n\t\t\t\t} while ((el = el[sibling]));\n\t\t\t}\n\t\t}\n\t\targument = argument || 'n';\n\t\tvar parsed = this.cacheNTH[argument] || this.parseNTHArgument(argument);\n\t\tif (!parsed) return false;\n\t\tvar a = parsed.a, b = parsed.b, pos = this[positions][uid];\n\t\tif (a == 0) return b == pos;\n\t\tif (a > 0){\n\t\t\tif (pos < b) return false;\n\t\t} else {\n\t\t\tif (b < pos) return false;\n\t\t}\n\t\treturn ((pos - b) % a) == 0;\n\t};\n};\n\n\/*<\/nth-pseudo-selectors>*\/\/*<\/pseudo-selectors>*\/\n\nlocal.pushArray = function(node, tag, id, classes, attributes, pseudos){\n\tif (this.matchSelector(node, tag, id, classes, attributes, pseudos)) this.found.push(node);\n};\n\nlocal.pushUID = function(node, tag, id, classes, attributes, pseudos){\n\tvar uid = this.getUID(node);\n\tif (!this.uniques[uid] && this.matchSelector(node, tag, id, classes, attributes, pseudos)){\n\t\tthis.uniques[uid] = true;\n\t\tthis.found.push(node);\n\t}\n};\n\nlocal.matchNode = function(node, selector){\n\tif (this.isHTMLDocument && this.nativeMatchesSelector){\n\t\ttry {\n\t\t\treturn this.nativeMatchesSelector.call(node, selector.replace(\/\\[([^=]+)=\\s*([^'\"\\]]+?)\\s*\\]\/g, '[$1=\"$2\"]'));\n\t\t} catch(matchError) {}\n\t}\n\t\n\tvar parsed = Parser.parse(selector);\n\tif (!parsed) return true;\n\n\t\/\/ simple (single) selectors\n\tvar expressions = parsed.expressions, reversedExpressions, simpleExpCounter = 0, i;\n\tfor (i = 0; (currentExpression = expressions[i]); i++){\n\t\tif (currentExpression.length == 1){\n\t\t\tvar exp = currentExpression[0];\n\t\t\tif (this.matchSelector(node, (this.isXMLDocument) ? exp.tag : exp.tag.toUpperCase(), exp.id, exp.classes, exp.attributes, exp.pseudos)) return true;\n\t\t\tsimpleExpCounter++;\n\t\t}\n\t}\n\n\tif (simpleExpCounter == parsed.length) return false;\n\n\tvar nodes = this.search(this.document, parsed), item;\n\tfor (i = 0; item = nodes[i++];){\n\t\tif (item === node) return true;\n\t}\n\treturn false;\n};\n\nlocal.matchPseudo = function(node, name, argument){\n\tvar pseudoName = 'pseudo:' + name;\n\tif (this[pseudoName]) return this[pseudoName](node, argument);\n\tvar attribute = this.getAttribute(node, name);\n\treturn (argument) ? argument == attribute : !!attribute;\n};\n\nlocal.matchSelector = function(node, tag, id, classes, attributes, pseudos){\n\tif (tag){\n\t\tvar nodeName = (this.isXMLDocument) ? node.nodeName : node.nodeName.toUpperCase();\n\t\tif (tag == '*'){\n\t\t\tif (nodeName < '@') return false; \/\/ Fix for comment nodes and closed nodes\n\t\t} else {\n\t\t\tif (nodeName != tag) return false;\n\t\t}\n\t}\n\n\tif (id && node.getAttribute('id') != id) return false;\n\n\tvar i, part, cls;\n\tif (classes) for (i = classes.length; i--;){\n\t\tcls = node.getAttribute('class') || node.className;\n\t\tif (!(cls && classes[i].regexp.test(cls))) return false;\n\t}\n\tif (attributes) for (i = attributes.length; i--;){\n\t\tpart = attributes[i];\n\t\tif (part.operator ? !part.test(this.getAttribute(node, part.key)) : !this.hasAttribute(node, part.key)) return false;\n\t}\n\tif (pseudos) for (i = pseudos.length; i--;){\n\t\tpart = pseudos[i];\n\t\tif (!this.matchPseudo(node, part.key, part.value)) return false;\n\t}\n\treturn true;\n};\n\nvar combinators = {\n\n\t' ': function(node, tag, id, classes, attributes, pseudos, classList){ \/\/ all child nodes, any level\n\n\t\tvar i, item, children;\n\n\t\tif (this.isHTMLDocument){\n\t\t\tgetById: if (id){\n\t\t\t\titem = this.document.getElementById(id);\n\t\t\t\tif ((!item && node.all) || (this.idGetsName && item && item.getAttributeNode('id').nodeValue != id)){\n\t\t\t\t\t\/\/ all[id] returns all the elements with that name or id inside node\n\t\t\t\t\t\/\/ if theres just one it will return the element, else it will be a collection\n\t\t\t\t\tchildren = node.all[id];\n\t\t\t\t\tif (!children) return;\n\t\t\t\t\tif (!children[0]) children = [children];\n\t\t\t\t\tfor (i = 0; item = children[i++];){\n\t\t\t\t\t\tvar idNode = item.getAttributeNode('id');\n\t\t\t\t\t\tif (idNode && idNode.nodeValue == id){\n\t\t\t\t\t\t\tthis.push(item, tag, null, classes, attributes, pseudos);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!item){\n\t\t\t\t\t\/\/ if the context is in the dom we return, else we will try GEBTN, breaking the getById label\n\t\t\t\t\tif (this.contains(this.root, node)) return;\n\t\t\t\t\telse break getById;\n\t\t\t\t} else if (this.document !== node && !this.contains(node, item)) return;\n\t\t\t\tthis.push(item, tag, null, classes, attributes, pseudos);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgetByClass: if (classes && node.getElementsByClassName && !this.brokenGEBCN){\n\t\t\t\tchildren = node.getElementsByClassName(classList.join(' '));\n\t\t\t\tif (!(children && children.length)) break getByClass;\n\t\t\t\tfor (i = 0; item = children[i++];) this.push(item, tag, id, null, attributes, pseudos);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tgetByTag: {\n\t\t\tchildren = node.getElementsByTagName(tag);\n\t\t\tif (!(children && children.length)) break getByTag;\n\t\t\tif (!this.brokenStarGEBTN) tag = null;\n\t\t\tfor (i = 0; item = children[i++];) this.push(item, tag, id, classes, attributes, pseudos);\n\t\t}\n\t},\n\n\t'>': function(node, tag, id, classes, attributes, pseudos){ \/\/ direct children\n\t\tif ((node = node.firstChild)) do {\n\t\t\tif (node.nodeType == 1) this.push(node, tag, id, classes, attributes, pseudos);\n\t\t} while ((node = node.nextSibling));\n\t},\n\n\t'+': function(node, tag, id, classes, attributes, pseudos){ \/\/ next sibling\n\t\twhile ((node = node.nextSibling)) if (node.nodeType == 1){\n\t\t\tthis.push(node, tag, id, classes, attributes, pseudos);\n\t\t\tbreak;\n\t\t}\n\t},\n\n\t'^': function(node, tag, id, classes, attributes, pseudos){ \/\/ first child\n\t\tnode = node.firstChild;\n\t\tif (node){\n\t\t\tif (node.nodeType == 1) this.push(node, tag, id, classes, attributes, pseudos);\n\t\t\telse this['combinator:+'](node, tag, id, classes, attributes, pseudos);\n\t\t}\n\t},\n\n\t'~': function(node, tag, id, classes, attributes, pseudos){ \/\/ next siblings\n\t\twhile ((node = node.nextSibling)){\n\t\t\tif (node.nodeType != 1) continue;\n\t\t\tvar uid = this.getUID(node);\n\t\t\tif (this.bitUniques[uid]) break;\n\t\t\tthis.bitUniques[uid] = true;\n\t\t\tthis.push(node, tag, id, classes, attributes, pseudos);\n\t\t}\n\t},\n\n\t'++': function(node, tag, id, classes, attributes, pseudos){ \/\/ next sibling and previous sibling\n\t\tthis['combinator:+'](node, tag, id, classes, attributes, pseudos);\n\t\tthis['combinator:!+'](node, tag, id, classes, attributes, pseudos);\n\t},\n\n\t'~~': function(node, tag, id, classes, attributes, pseudos){ \/\/ next siblings and previous siblings\n\t\tthis['combinator:~'](node, tag, id, classes, attributes, pseudos);\n\t\tthis['combinator:!~'](node, tag, id, classes, attributes, pseudos);\n\t},\n\n\t'!': function(node, tag, id, classes, attributes, pseudos){ \/\/ all parent nodes up to document\n\t\twhile ((node = node.parentNode)) if (node !== this.document) this.push(node, tag, id, classes, attributes, pseudos);\n\t},\n\n\t'!>': function(node, tag, id, classes, attributes, pseudos){ \/\/ direct parent (one level)\n\t\tnode = node.parentNode;\n\t\tif (node !== this.document) this.push(node, tag, id, classes, attributes, pseudos);\n\t},\n\n\t'!+': function(node, tag, id, classes, attributes, pseudos){ \/\/ previous sibling\n\t\twhile ((node = node.previousSibling)) if (node.nodeType == 1){\n\t\t\tthis.push(node, tag, id, classes, attributes, pseudos);\n\t\t\tbreak;\n\t\t}\n\t},\n\n\t'!^': function(node, tag, id, classes, attributes, pseudos){ \/\/ last child\n\t\tnode = node.lastChild;\n\t\tif (node){\n\t\t\tif (node.nodeType == 1) this.push(node, tag, id, classes, attributes, pseudos);\n\t\t\telse this['combinator:!+'](node, tag, id, classes, attributes, pseudos);\n\t\t}\n\t},\n\n\t'!~': function(node, tag, id, classes, attributes, pseudos){ \/\/ previous siblings\n\t\twhile ((node = node.previousSibling)){\n\t\t\tif (node.nodeType != 1) continue;\n\t\t\tvar uid = this.getUID(node);\n\t\t\tif (this.bitUniques[uid]) break;\n\t\t\tthis.bitUniques[uid] = true;\n\t\t\tthis.push(node, tag, id, classes, attributes, pseudos);\n\t\t}\n\t}\n\n};\n\nfor (var c in combinators) local['combinator:' + c] = combinators[c];\n\nvar pseudos = {\n\n\t\/*<pseudo-selectors>*\/\n\n\t'empty': function(node){\n\t\tvar child = node.firstChild;\n\t\treturn !(child && child.nodeType == 1) && !(node.innerText || node.textContent || '').length;\n\t},\n\n\t'not': function(node, expression){\n\t\treturn !this.matchNode(node, expression);\n\t},\n\n\t'contains': function(node, text){\n\t\treturn (node.innerText || node.textContent || '').indexOf(text) > -1;\n\t},\n\n\t'first-child': function(node){\n\t\twhile ((node = node.previousSibling)) if (node.nodeType == 1) return false;\n\t\treturn true;\n\t},\n\n\t'last-child': function(node){\n\t\twhile ((node = node.nextSibling)) if (node.nodeType == 1) return false;\n\t\treturn true;\n\t},\n\n\t'only-child': function(node){\n\t\tvar prev = node;\n\t\twhile ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false;\n\t\tvar next = node;\n\t\twhile ((next = next.nextSibling)) if (next.nodeType == 1) return false;\n\t\treturn true;\n\t},\n\n\t\/*<nth-pseudo-selectors>*\/\n\n\t'nth-child': local.createNTHPseudo('firstChild', 'nextSibling', 'posNTH'),\n\n\t'nth-last-child': local.createNTHPseudo('lastChild', 'previousSibling', 'posNTHLast'),\n\n\t'nth-of-type': local.createNTHPseudo('firstChild', 'nextSibling', 'posNTHType', true),\n\n\t'nth-last-of-type': local.createNTHPseudo('lastChild', 'previousSibling', 'posNTHTypeLast', true),\n\n\t'index': function(node, index){\n\t\treturn this['pseudo:nth-child'](node, '' + index + 1);\n\t},\n\n\t'even': function(node){\n\t\treturn this['pseudo:nth-child'](node, '2n');\n\t},\n\n\t'odd': function(node){\n\t\treturn this['pseudo:nth-child'](node, '2n+1');\n\t},\n\n\t\/*<\/nth-pseudo-selectors>*\/\n\n\t\/*<of-type-pseudo-selectors>*\/\n\n\t'first-of-type': function(node){\n\t\tvar nodeName = node.nodeName;\n\t\twhile ((node = node.previousSibling)) if (node.nodeName == nodeName) return false;\n\t\treturn true;\n\t},\n\n\t'last-of-type': function(node){\n\t\tvar nodeName = node.nodeName;\n\t\twhile ((node = node.nextSibling)) if (node.nodeName == nodeName) return false;\n\t\treturn true;\n\t},\n\n\t'only-of-type': function(node){\n\t\tvar prev = node, nodeName = node.nodeName;\n\t\twhile ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false;\n\t\tvar next = node;\n\t\twhile ((next = next.nextSibling)) if (next.nodeName == nodeName) return false;\n\t\treturn true;\n\t},\n\n\t\/*<\/of-type-pseudo-selectors>*\/\n\n\t\/\/ custom pseudos\n\n\t'enabled': function(node){\n\t\treturn !node.disabled;\n\t},\n\n\t'disabled': function(node){\n\t\treturn node.disabled;\n\t},\n\n\t'checked': function(node){\n\t\treturn node.checked || node.selected;\n\t},\n\n\t'focus': function(node){\n\t\treturn this.isHTMLDocument && this.document.activeElement === node && (node.href || node.type || this.hasAttribute(node, 'tabindex'));\n\t},\n\n\t'root': function(node){\n\t\treturn (node === this.root);\n\t},\n\t\n\t'selected': function(node){\n\t\treturn node.selected;\n\t}\n\n\t\/*<\/pseudo-selectors>*\/\n};\n\nfor (var p in pseudos) local['pseudo:' + p] = pseudos[p];\n\n\/\/ attributes methods\n\nlocal.attributeGetters = {\n\n\t'class': function(){\n\t\treturn this.getAttribute('class') || this.className;\n\t},\n\n\t'for': function(){\n\t\treturn ('htmlFor' in this) ? this.htmlFor : this.getAttribute('for');\n\t},\n\n\t'href': function(){\n\t\treturn ('href' in this) ? this.getAttribute('href', 2) : this.getAttribute('href');\n\t},\n\n\t'style': function(){\n\t\treturn (this.style) ? this.style.cssText : this.getAttribute('style');\n\t},\n\t\n\t'tabindex': function(){\n\t\tvar attributeNode = this.getAttributeNode('tabindex');\n\t\treturn (attributeNode && attributeNode.specified) ? attributeNode.nodeValue : null;\n\t},\n\n\t'type': function(){\n\t\treturn this.getAttribute('type');\n\t}\n\n};\n\n\/\/ Slick\n\nFinder.version = '1.1.5';\n\n\/\/ Slick finder\n\nFinder.search = function(context, expression, append){\n\treturn local.search(context, expression, append);\n};\n\nFinder.find = function(context, expression){\n\treturn local.search(context, expression, null, true);\n};\n\n\/\/ Slick containment checker\n\nFinder.contains = function(container, node){\n\tlocal.setDocument(container);\n\treturn local.contains(container, node);\n};\n\n\/\/ Slick attribute getter\n\nFinder.getAttribute = function(node, name){\n\treturn local.getAttribute(node, name);\n};\n\n\/\/ Slick matcher\n\nFinder.match = function(node, selector){\n\tif (!(node && selector)) return false;\n\tif (!selector || selector === node) return true;\n\tlocal.setDocument(node);\n\treturn local.matchNode(node, selector);\n};\n\n\/\/ Slick attribute accessor\n\nFinder.defineAttributeGetter = function(name, fn){\n\tlocal.attributeGetters[name] = fn;\n\treturn this;\n};\n\nFinder.lookupAttributeGetter = function(name){\n\treturn local.attributeGetters[name];\n};\n\n\/\/ Slick pseudo accessor\n\nFinder.definePseudo = function(name, fn){\n\tlocal['pseudo:' + name] = function(node, argument){\n\t\treturn fn.call(node, argument);\n\t};\n\treturn this;\n};\n\nFinder.lookupPseudo = function(name){\n\tvar pseudo = local['pseudo:' + name];\n\tif (pseudo) return function(argument){\n\t\treturn pseudo.call(this, argument);\n\t};\n\treturn null;\n};\n\nFinder.isXML = local.isXML;\n\nFinder.uidOf = function(node){\n\treturn local.getUIDHTML(node);\n};\n\nreturn Finder;\n\n});\n","dependencies":["Core\/Slick\/Parser"]},"Core\/Slick\/Parser":{"id":"Core\/Slick\/Parser","url":"\/home\/arian\/www\/MooTools\/core2-define\/Source\/Slick\/Parser.js","package":"Core","amd":true,"content":"\/*\n---\nname: Parser\ndescription: Standalone CSS3 Selector parser\n...\n*\/\n\ndefine(function(){\n\nvar parsed,\n\tseparatorIndex,\n\tcombinatorIndex,\n\treversed,\n\tcache = {},\n\treverseCache = {},\n\treUnescape = \/\\\\\/g;\n\nvar parse = function(expression, isReversed){\n\tif (expression == null) return null;\n\tif (expression.Slick === true) return expression;\n\texpression = ('' + expression).replace(\/^\\s+|\\s+$\/g, '');\n\treversed = !!isReversed;\n\tvar currentCache = (reversed) ? reverseCache : cache;\n\tif (currentCache[expression]) return currentCache[expression];\n\tparsed = {\n\t\tSlick: true,\n\t\texpressions: [],\n\t\traw: expression,\n\t\treverse: function(){\n\t\t\treturn parse(this.raw, true);\n\t\t}\n\t};\n\tseparatorIndex = -1;\n\twhile (expression != (expression = expression.replace(regexp, parser)));\n\tparsed.length = parsed.expressions.length;\n\treturn currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;\n};\n\nvar reverseCombinator = function(combinator){\n\tif (combinator === '!') return ' ';\n\telse if (combinator === ' ') return '!';\n\telse if ((\/^!\/).test(combinator)) return combinator.replace(\/^!\/, '');\n\telse return '!' + combinator;\n};\n\nvar reverse = function(expression){\n\tvar expressions = expression.expressions;\n\tfor (var i = 0; i < expressions.length; i++){\n\t\tvar exp = expressions[i];\n\t\tvar last = {parts: [], tag: '*', combinator: reverseCombinator(exp[0].combinator)};\n\n\t\tfor (var j = 0; j < exp.length; j++){\n\t\t\tvar cexp = exp[j];\n\t\t\tif (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';\n\t\t\tcexp.combinator = cexp.reverseCombinator;\n\t\t\tdelete cexp.reverseCombinator;\n\t\t}\n\n\t\texp.reverse().push(last);\n\t}\n\treturn expression;\n};\n\nvar escapeRegExp = function(string){\/\/ Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http:\/\/stevenlevithan.com\/regex\/xregexp\/> MIT License\n\treturn string.replace(\/[-[\\]{}()*+?.\\\\^$|,#\\s]\/g, function(match){\n\t\treturn '\\\\' + match;\n\t});\n};\n\nvar regexp = new RegExp(\n\/*\n#!\/usr\/bin\/env ruby\nputs \"\\t\\t\" + DATA.read.gsub(\/\\(\\?x\\)|\\s+#.*$|\\s+|\\\\$|\\\\n\/,'')\n__END__\n\t\"(?x)^(?:\\\n\t  \\\\s* ( , ) \\\\s*               # Separator          \\n\\\n\t| \\\\s* ( <combinator>+ ) \\\\s*   # Combinator         \\n\\\n\t|      ( \\\\s+ )                 # CombinatorChildren \\n\\\n\t|      ( <unicode>+ | \\\\* )     # Tag                \\n\\\n\t| \\\\#  ( <unicode>+       )     # ID                 \\n\\\n\t| \\\\.  ( <unicode>+       )     # ClassName          \\n\\\n\t|                               # Attribute          \\n\\\n\t\\\\[  \\\n\t\t\\\\s* (<unicode1>+)  (?:  \\\n\t\t\t\\\\s* ([*^$!~|]?=)  (?:  \\\n\t\t\t\t\\\\s* (?:\\\n\t\t\t\t\t([\\\"']?)(.*?)\\\\9 \\\n\t\t\t\t)\\\n\t\t\t)  \\\n\t\t)?  \\\\s*  \\\n\t\\\\](?!\\\\]) \\n\\\n\t|   :+ ( <unicode>+ )(?:\\\n\t\\\\( (?:\\\n\t\t(?:([\\\"'])([^\\\\12]*)\\\\12)|((?:\\\\([^)]+\\\\)|[^()]*)+)\\\n\t) \\\\)\\\n\t)?\\\n\t)\"\n*\/\n\t\"^(?:\\\\s*(,)\\\\s*|\\\\s*(<combinator>+)\\\\s*|(\\\\s+)|(<unicode>+|\\\\*)|\\\\#(<unicode>+)|\\\\.(<unicode>+)|\\\\[\\\\s*(<unicode1>+)(?:\\\\s*([*^$!~|]?=)(?:\\\\s*(?:([\\\"']?)(.*?)\\\\9)))?\\\\s*\\\\](?!\\\\])|(:+)(<unicode>+)(?:\\\\((?:(?:([\\\"'])([^\\\\13]*)\\\\13)|((?:\\\\([^)]+\\\\)|[^()]*)+))\\\\))?)\"\n\t.replace(\/<combinator>\/, '[' + escapeRegExp(\">+~`!@$%^&={}\\\\;<\/\") + ']')\n\t.replace(\/<unicode>\/g, '(?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\n\t.replace(\/<unicode1>\/g, '(?:[:\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\n);\n\nfunction parser(\n\trawMatch,\n\n\tseparator,\n\tcombinator,\n\tcombinatorChildren,\n\n\ttagName,\n\tid,\n\tclassName,\n\n\tattributeKey,\n\tattributeOperator,\n\tattributeQuote,\n\tattributeValue,\n\n\tpseudoMarker,\n\tpseudoClass,\n\tpseudoQuote,\n\tpseudoClassQuotedValue,\n\tpseudoClassValue\n){\n\tif (separator || separatorIndex === -1){\n\t\tparsed.expressions[++separatorIndex] = [];\n\t\tcombinatorIndex = -1;\n\t\tif (separator) return '';\n\t}\n\n\tif (combinator || combinatorChildren || combinatorIndex === -1){\n\t\tcombinator = combinator || ' ';\n\t\tvar currentSeparator = parsed.expressions[separatorIndex];\n\t\tif (reversed && currentSeparator[combinatorIndex])\n\t\t\tcurrentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);\n\t\tcurrentSeparator[++combinatorIndex] = {combinator: combinator, tag: '*'};\n\t}\n\n\tvar currentParsed = parsed.expressions[separatorIndex][combinatorIndex];\n\n\tif (tagName){\n\t\tcurrentParsed.tag = tagName.replace(reUnescape, '');\n\n\t} else if (id){\n\t\tcurrentParsed.id = id.replace(reUnescape, '');\n\n\t} else if (className){\n\t\tclassName = className.replace(reUnescape, '');\n\n\t\tif (!currentParsed.classList) currentParsed.classList = [];\n\t\tif (!currentParsed.classes) currentParsed.classes = [];\n\t\tcurrentParsed.classList.push(className);\n\t\tcurrentParsed.classes.push({\n\t\t\tvalue: className,\n\t\t\tregexp: new RegExp('(^|\\\\s)' + escapeRegExp(className) + '(\\\\s|$)')\n\t\t});\n\n\t} else if (pseudoClass){\n\t\tpseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;\n\t\tpseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;\n\n\t\tif (!currentParsed.pseudos) currentParsed.pseudos = [];\n\t\tcurrentParsed.pseudos.push({\n\t\t\tkey: pseudoClass.replace(reUnescape, ''),\n\t\t\tvalue: pseudoClassValue,\n\t\t\ttype: pseudoMarker.length == 1 ? 'class' : 'element'\n\t\t});\n\n\t} else if (attributeKey){\n\t\tattributeKey = attributeKey.replace(reUnescape, '');\n\t\tattributeValue = (attributeValue || '').replace(reUnescape, '');\n\n\t\tvar test, regexp;\n\n\t\tswitch (attributeOperator){\n\t\t\tcase '^=' : regexp = new RegExp(       '^'+ escapeRegExp(attributeValue)            ); break;\n\t\t\tcase '$=' : regexp = new RegExp(            escapeRegExp(attributeValue) +'$'       ); break;\n\t\t\tcase '~=' : regexp = new RegExp( '(^|\\\\s)'+ escapeRegExp(attributeValue) +'(\\\\s|$)' ); break;\n\t\t\tcase '|=' : regexp = new RegExp(       '^'+ escapeRegExp(attributeValue) +'(-|$)'   ); break;\n\t\t\tcase  '=' : test = function(value){\n\t\t\t\treturn attributeValue == value;\n\t\t\t}; break;\n\t\t\tcase '*=' : test = function(value){\n\t\t\t\treturn value && value.indexOf(attributeValue) > -1;\n\t\t\t}; break;\n\t\t\tcase '!=' : test = function(value){\n\t\t\t\treturn attributeValue != value;\n\t\t\t}; break;\n\t\t\tdefault   : test = function(value){\n\t\t\t\treturn !!value;\n\t\t\t};\n\t\t}\n\n\t\tif (attributeValue == '' && (\/^[*$^]=$\/).test(attributeOperator)) test = function(){\n\t\t\treturn false;\n\t\t};\n\n\t\tif (!test) test = function(value){\n\t\t\treturn value && regexp.test(value);\n\t\t};\n\n\t\tif (!currentParsed.attributes) currentParsed.attributes = [];\n\t\tcurrentParsed.attributes.push({\n\t\t\tkey: attributeKey,\n\t\t\toperator: attributeOperator,\n\t\t\tvalue: attributeValue,\n\t\t\ttest: test\n\t\t});\n\n\t}\n\n\treturn '';\n};\n\nreturn {parse: parse, escapeRegExp: escapeRegExp};\n\n});\n","dependencies":[]},"Centaur\/App":{"id":"Centaur\/App","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/App.js","package":"Centaur","amd":true,"content":"\ndefine([\n\t'.\/Base\/Super',\n\t'.\/Base\/Notify',\n\t'.\/Base\/History',\n\t'.\/Base\/Element\/Match',\n\t'.\/Modules\/Module.Feed',\n\t'.\/Modules\/Module.Article',\n\t'.\/Modules\/Module.Config',\n\t'.\/Modules\/Module.Font'\n], function(Super, Notify, History, Match, Module){\n\nvar App = new Super(null, {\n\n\tinit: function(wrapper){\n\t\tthis.wrapper = typeof wrapper == 'string' ? document.querySelector(wrapper) : wrapper;\n\n\t\t\/\/ Implement notification system\n\t\tNotify.call(this);\n\n\t\t\/\/ Global Event Listener\n\t\tthis.listen('*', function(){\n\t\t\tif (\/(\\.load\\.fail)$\/.test(arguments[arguments.length - 1])){\n\t\t\t\tconsole.log('Failed to load some file');\n\t\t\t}\n\t\t});\n\n\t\tthis.states = {};\n\n\t\tthis.state = [];\n\t\tvar defaultState = ['feed'];\n\n\t\tvar self = this;\n\t\tHistory.listen(function(state){\n\t\t\tif (!state.length) state = defaultState;\n\t\t\tif (self.state.join() != state.join()){\n\t\t\t\tself.view(state[0], state.slice(1));\n\t\t\t\tself.notify('statechange', [self.state, state]);\n\t\t\t\tself.notify('statechange.' + state[0], [state.slice(1)]);\n\t\t\t}\n\t\t\tself.state = state;\n\t\t});\n\n\t},\n\n\tregister: function(states, module){\n\t\tif (typeof states == 'string') states = [states];\n\t\tstates.forEach(function(state){\n\t\t\t(this.states[state] || (this.states[state] = [])).push(module);\n\t\t}, this);\n\t},\n\n\tview: function(view, args){\n\t\tvar states = this.states,\n\t\t\toldstate = states[this.state[0]] || [],\n\t\t\tnewstate = states[view] || [];\n\n\t\tvar unload = oldstate.filter(function(module){\n\t\t\tvar index = newstate.indexOf(module);\n\t\t\tif (index != -1) newstate.splice(index, 1);\n\t\t\treturn index == -1;\n\t\t});\n\n\t\tunload.forEach(function(module){\n\t\t\tmodule.unload();\n\t\t});\n\n\t\tnewstate.forEach(function(module){\n\t\t\tmodule.load.apply(module, args);\n\t\t});\n\n\t\treturn this;\n\t},\n\n\tsetMainContent: function(fragment, slideDirection){\n\t\tvar wrapper = this.wrapper, current = wrapper.childNodes;\n\n\t\tif (!slideDirection) slideDirection = this.slideDirection;\n\n\t\tvar sli = 'slideLeftIn', slo = 'slideLeftOut',\n\t\t\tsri = 'slideRightIn', sro = 'slideRightOut',\n\t\t\tslideIn = slideDirection == 'left' ? sli : sri,\n\t\t\tslideOut = slideDirection == 'left' ? slo : sro,\n\t\t\tfadeIn = 'fadeIn';\n\n\t\tvar oldies = [];\n\t\tfor (var l = current.length; l--;) (function(old){\n\t\t\tif (!old.tagName || old.tagName.toLowerCase() != 'div' || old.classList.contains('sliding')) return;\n\t\t\toldies.push(old);\n\t\t\tvar cl = old.classList;\n\t\t\told.addEventListener('webkitAnimationEnd', function(){\n\t\t\t\tif (old.parentNode) old.parentNode.removeChild(old);\n\t\t\t}, true);\n\t\t\tcl.add(slideOut);\n\t\t\tcl.add('sliding');\n\t\t})(current[l]);\n\n\t\tcurrent = document.createElement('div');\n\n\t\tvar cls = oldies.length ? slideIn : fadeIn;\n\t\tcurrent.classList.add(cls);\n\t\tcurrent.addEventListener('webkitAnimationEnd', function(){\n\t\t\tcurrent.classList.remove(cls);\n\t\t\tcurrent.removeEventListener('webkitAnimationEnd', arguments.callee);\n\t\t}, true);\n\n\t\tcurrent.appendChild(fragment);\n\t\tthis.wrapper.appendChild(current);\n\t}\n\n});\n\nwindow.addEventListener('DOMContentLoaded', function(){\n\n\tvar app = new App('#wrapper');\n\tapp.register('feed', new Module.Feed(app));\n\tapp.register('article', new Module.Article(app));\n\n\tdocument.body.addEventListener('click', function(event){\n\t\tvar href, target = Match(event.target, function(element){\n\t\t\treturn Match.matchesSelector(element, 'a')\n\t\t\t\t&& (href = element.getAttribute('href'))\n\t\t\t\t&& href.slice(0, 2) == '#!';\n\t\t}, true);\n\t\tif (target){\n\t\t\tevent.preventDefault();\n\t\t\tapp.slideDirection = target.dataset.dir || null;\n\t\t\tHistory.push(href);\n\t\t}\n\t}, false);\n\n}, false);\n\n});\n","dependencies":["Centaur\/Base\/Super","Centaur\/Base\/Notify","Centaur\/Base\/History","Centaur\/Base\/Element\/Match","Centaur\/Modules\/Module.Feed","Centaur\/Modules\/Module.Article","Centaur\/Modules\/Module.Config","Centaur\/Modules\/Module.Font"]},"Centaur\/Base\/Super":{"id":"Centaur\/Base\/Super","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Base\/Super.js","package":"Centaur","amd":true,"content":"\ndefine(function(){\n\nvar _super = function(){};\n\nreturn function(parent, proto){\n\n\tvar klass = function Super(){\n\t\tif (this.init) this.init.apply(this, arguments);\n\t};\n\n\tif (!parent) parent = _super;\n\tklass.prototype = Object.create(parent.prototype);\n\tfor (var key in proto) klass.prototype[key] = proto[key];\n\n\tklass.prototype.parent = function(method, args){\n\t\tvar _method = parent && parent.prototype[method];\n\t\tif (_method){\n\t\t\tvar _parent = this.parent;\n\t\t\tthis.parent = parent.prototype.parent;\n\t\t\tvar value = _method.apply(this, args);\n\t\t\tthis.parent = _parent;\n\t\t\treturn value;\n\t\t}\n\t\treturn this;\n\t};\n\n\treturn klass;\n};\n\n});\n","dependencies":[]},"Centaur\/Base\/Notify":{"id":"Centaur\/Base\/Notify","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Base\/Notify.js","package":"Centaur","amd":true,"content":"\ndefine(function(){\n\nreturn function(){\n\n\tvar _events = {};\n\tvar _uid = Date.now();\n\n\tvar listen = this.listen = function(name, fn){\n\t\tif (typeof name != 'string') for (var _name in name) listen.call(this, _name, name[_name]); else {\n\t\t\tvar events = _events[name] || (_events[name] = {});\n\t\t\tevents[_uid++] = fn;\n\t\t}\n\t\treturn this;\n\t};\n\n\tvar notify = this.notify = function(name, args){\n\t\tif (args != null && !Array.isArray(args)) throw Error('notify args is not an array');\n\n\t\tvar events = {};\n\t\tif (typeof name == 'string'){\n\t\t\tevents = _events[name] || {};\n\t\t} else if (Array.isArray(name)){\n\t\t\tfor (var i = 0, l = name.length; i < l; i++) notify.call(this, name[i], args);\n\t\t\treturn this;\n\t\t} else {\n\t\t\tevents = {};\n\t\t\tfor (var _name in _events) if (name.test(_name)) notify.call(this, _name, args);\n\t\t\treturn this;\n\t\t}\n\n\t\tvar _sevents = _events['*'];\n\t\tfor (var _suid in _sevents) if (!events[_suid]) events[_suid] = _sevents[_suid];\n\t\targs = (args || []).concat(name);\n\n\t\tfor (var uid in events) events[uid] && events[uid].apply(this, args);\n\t\treturn this;\n\t};\n\n\tvar ignore = this.ignore = function(name, fn){\n\t\tif (typeof name != 'string') for (var _name in name) ignore.call(this, _name, name[_name]); else {\n\t\t\tvar events = _events[name];\n\t\t\tif (!events) return this;\n\t\t\tfor (var uid in events) if (events[uid] == fn) delete events[uid];\n\t\t}\n\t\treturn this;\n\t};\n\n};\n\n});\n","dependencies":[]},"Centaur\/Base\/History":{"id":"Centaur\/Base\/History","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Base\/History.js","package":"Centaur","amd":true,"content":"\ndefine(function(){\n\nvar parse = function(hash){\n\tvar state = hash.split('\/');\n\tif (state[0] == '#!') state.shift();\n\tif (state[0] == '') state.shift();\n\treturn state;\n};\n\nvar currentState = parse(location.hash);\nvar listeners = [];\n\nvar History = {\n\n\tpush: function(state){\n\t\tif (typeof state == 'string') state = parse(state);\n\t\tvar url = '#!\/' + state.join('\/');\n\t\tlocation.hash = url;\n\t\treturn this;\n\t},\n\n\tlisten: function(fn, onAdd){\n\t\tif (listeners.indexOf(fn) == -1){\n\t\t\tlisteners.push(fn);\n\t\t\tif (onAdd != false) setTimeout(fn.bind(History, currentState), 1);\n\t\t}\n\t\treturn this;\n\t},\n\n\tignore: function(fn){\n\t\tvar index = listeners.indexOf(fn);\n\t\tif (index != -1) listeners.splice(index, 1);\n\t\treturn this;\n\t}\n\n};\n\nwindow.addEventListener('hashchange', function(){\n\tcurrentState = parse(location.hash);\n\tlisteners.forEach(function(fn){\n\t\tsetTimeout(fn.bind(History, currentState), 1);\n\t});\n}, false);\n\nreturn History;\n\n});\n","dependencies":[]},"Centaur\/Base\/Element\/Match":{"id":"Centaur\/Base\/Element\/Match","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Base\/Element\/Match.js","package":"Centaur","amd":true,"content":"\ndefine(function(){\n\nvar bubbleUp = function(element, matcher){\n\tfor (; element; element = element.parentNode) if (matcher(element)) return element;\n\treturn false;\n};\n\nvar proto = Element.prototype, _matches = proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector;\nvar matchesSelector = function(element, selector){\n\treturn element && element.tagName && (typeof selector == 'string') && _matches.call(element, selector);\n};\n\nvar Match = function Match(element, matcher, bubble){\n\tif (typeof matcher == 'string'){\n\t\tvar _matcher = matcher;\n\t\tmatcher = function(el){\n\t\t\treturn matchesSelector(el, _matcher);\n\t\t};\n\t}\n\tif (bubble) return bubbleUp(element, matcher);\n\treturn matcher(element) ? element : false;\n};\n\nMatch.matchesSelector = matchesSelector;\n\nreturn Match;\n\n});\n","dependencies":[]},"Centaur\/Modules\/Module.Feed":{"id":"Centaur\/Modules\/Module.Feed","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Modules\/Module.Feed.js","package":"Centaur","amd":true,"content":"\ndefine([\n\t'.\/Module',\n\t'..\/Sources\/Source.Feed',\n\t'..\/Sinks\/Sink.Feed',\n\t'..\/Base\/Super'\n], function(Module, Source, Sink, Super){\n\nModule.Feed = new Super(Module, {\n\n\tinit: function(options){\n\t\tthis.parent('init', [options]);\n\n\t\tthis.source = new Source.Feed(this.app);\n\t\tthis.sink = new Sink.Feed(this.app);\n\n\t\tvar self = this, app = this.app;\n\t\tthis.bound = {\n\t\t\t'source.feed.load': function(data){\n\t\t\t\tself.sink.setData(data);\n\t\t\t\tself.sink.load('fixtures\/rss.xsl');\n\t\t\t},\n\t\t\t'sink.feed.transform': function(fragment){\n\t\t\t\tapp.setMainContent(fragment);\n\t\t\t},\n\t\t\t'statechange.feed': function(newstate){\n\t\t\t\tself.source.load();\n\t\t\t}\n\t\t};\n\t},\n\n\tload: function(){\n\t\tthis.app.listen(this.bound);\n\t},\n\n\tunload: function(){\n\t\tthis.app.ignore(this.bound);\n\t}\n\n});\n\nreturn Module;\n\n});\n","dependencies":["Centaur\/Modules\/Module","Centaur\/Sources\/Source.Feed","Centaur\/Sinks\/Sink.Feed","Centaur\/Base\/Super"]},"Centaur\/Modules\/Module":{"id":"Centaur\/Modules\/Module","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Modules\/Module.js","package":"Centaur","amd":true,"content":"\ndefine(['..\/Base\/Super', '..\/Base\/Utility\/merge'], function(Super, merge){\n\nreturn new Super(null, {\n\n\tinit: function(app, options){\n\t\tthis.app = app;\n\t\tthis.options = merge(this.options || {}, options);\n\t},\n\n\tload: function(){},\n\n\tunload: function(){}\n\n});\n\n});\n","dependencies":["Centaur\/Base\/Super","Centaur\/Base\/Utility\/merge"]},"Centaur\/Base\/Utility\/merge":{"id":"Centaur\/Base\/Utility\/merge","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Base\/Utility\/merge.js","package":"Centaur","amd":true,"content":"\ndefine(function(){\n\nvar toString = Object.prototype.toString;\nvar isObject = function(value){\n\treturn toString.call(value) == '[object Object]';\n};\n\nvar merge = function(self, key, value){\n\tif (typeof key == 'string'){\n\t\tif (isObject(self[key])  && isObject(value)) merge(self[key], value);\n\t\telse self[key] = value;\n\t} else for (var i = 1, l = arguments.length; i < l; i++){\n\t\tvar object = arguments[i];\n\t\tfor (var k in object) merge(self, k, object[k]);\n\t}\n\treturn self;\n};\n\nreturn merge;\n\n});","dependencies":[]},"Centaur\/Sources\/Source.Feed":{"id":"Centaur\/Sources\/Source.Feed","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sources\/Source.Feed.js","package":"Centaur","amd":true,"content":"\ndefine(['.\/Source.Request', '..\/Base\/Super', '..\/Base\/Utility\/pair'], function(Source, Super, pair){\n\nSource.Feed = new Super(Source.Request, {\n\n\tstorageKey: 'source.feed',\n\tnotifyKey: 'source.feed',\n\n\toptions: {\n\t\turl: 'fixtures\/rss.xml',\n\t\texpireInterval: 60000 \/\/ 60 sec.\n\t},\n\n\tinit: function(app, options){\n\t\tthis.parent('init', [app, options]);\n\t\tthis.url = this.options.url;\n\t},\n\n\t_parse: function(text, xml){\n\t\tvar data = {};\n\t\tthis._summary(data, xml);\n\t\tthis._items(data, xml);\n\t\treturn data;\n\t},\n\n\t_summary: function(data, xml){\n\t\t['title', 'description', 'link', 'lastBuildDate', 'pubDate'].forEach(function(tag){\n\t\t\tvar element = xml.querySelector('channel > ' + tag);\n\t\t\tdata[tag] = element && element.textContent || null;\n\t\t});\n\t},\n\n\t_items: function(data, xml){\n\t\tvar items = data.items = [];\n\n\t\tvar tags = ['title', 'description', 'link', 'guid', 'pubDate'];\n\t\tvar elements = pair(tags, function(tag){\n\t\t\treturn xml.querySelectorAll('channel item ' + tag);\n\t\t});\n\n\t\tfor (var i = 0, l = elements.title.length; i < l; i++){\n\t\t\tvar item = {};\n\t\t\ttags.forEach(function(tag){\n\t\t\t\tvar element = elements[tag][i];\n\t\t\t\titem[tag] = element && element.textContent || null;\n\t\t\t});\n\t\t\titems.push(item);\n\t\t}\n\t}\n\n});\n\nreturn Source;\n\n});\n","dependencies":["Centaur\/Sources\/Source.Request","Centaur\/Base\/Super","Centaur\/Base\/Utility\/pair"]},"Centaur\/Sources\/Source.Request":{"id":"Centaur\/Sources\/Source.Request","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sources\/Source.Request.js","package":"Centaur","amd":true,"content":"\ndefine(['.\/Source', '..\/Base\/Request', '..\/Base\/Super'], function(Source, Request, Super){\n\nSource.Request = new Super(Source, {\n\n\tinit: function(app, options){\n\t\tthis.parent('init', [app, options]);\n\t\tthis.request = new Request();\n\t},\n\n\t_fetch: function(){\n\t\tvar self = this;\n\t\tthis.request.send(this.url, function(text, xml){\n\t\t\tself.text = text;\n\t\t\tif (!xml) self.app.notify(self.notifyKey + 'load.fail');\n\t\t\telse {\n\t\t\t\tself.xml = xml;\n\t\t\t\tvar data = self._parse(text, xml);\n\t\t\t\tself._store(data);\n\t\t\t\tself.app.notify(self.notifyKey + '.load', [data, text, xml]);\n\t\t\t}\n\t\t}, function(){\n\t\t\tself.app.notify(self.notifyKey + '.load.fail');\n\t\t});\n\t},\n\n\t_parse: function(text, xml){}\n\n});\n\nreturn Source;\n\n});\n","dependencies":["Centaur\/Sources\/Source","Centaur\/Base\/Request","Centaur\/Base\/Super"]},"Centaur\/Sources\/Source":{"id":"Centaur\/Sources\/Source","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sources\/Source.js","package":"Centaur","amd":true,"content":"\ndefine(['..\/Base\/Storage', '..\/Base\/Super', '..\/Base\/Utility\/merge'], function(Storage, Super, merge){\n\nreturn new Super(null, {\n\n\tstorageKey: 'source',\n\tnotifyKey: 'source',\n\n\texpire: null,\n\n\toptions: {\n\t\texpireInterval: null\n\t},\n\n\tinit: function(app, options){\n\t\tthis.app = app;\n\t\tthis.options = merge(this.options || {}, options);\n\t\tthis.storage = new Storage(this.storageKey);\n\t},\n\n\t\/\/ Will fire notify.key.load or notify.key.load.fail\n\tload: function(url, nocache){\n\t\tif (url) this.url = url;\n\t\tif (!this.url) throw new Error('The url property should be set first!');\n\t\tvar data = this.storage.get(this.url),\n\t\t\toptions = this.options,\n\t\t\tinterval = options.expireInterval,\n\t\t\tnow = Date.now();\n\t\tif (data == null\n\t\t\t|| data.data == null\n\t\t\t|| nocache\n\t\t\t|| (interval && data.time + interval < now)\n\t\t) this._fetch();\n\t\telse this.app.notify(this.notifyKey + '.load', [data.data]);\n\t},\n\n\t\/\/ MUST fire notify.key.load or notify.load.fail\n\t_fetch: function(){\n\t\tthis.data = {};\n\t\tthis.app.notify(this.notifyKey + '.load', [this.data]);\n\t},\n\n\t_store: function(data){\n\t\tthis.data = data;\n\t\ttry {\n\t\t\tthis.storage.set(this.url, {\n\t\t\t\tdata: data,\n\t\t\t\ttime: Date.now()\n\t\t\t});\n\t\t} catch (e){\n\t\t\tif (e == QUOTA_EXCEEDED_ERR) this.app.notify('source.store.quota_exceeded', [e]);\n\t\t\telse throw e;\n\t\t}\n\t}\n\n});\n\n});\n","dependencies":["Centaur\/Base\/Storage","Centaur\/Base\/Super","Centaur\/Base\/Utility\/merge"]},"Centaur\/Base\/Storage":{"id":"Centaur\/Base\/Storage","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Base\/Storage.js","package":"Centaur","amd":true,"content":"\ndefine(function(){\n\nreturn function(namespace){\n\n\tif (!namespace) namespace = 'storage';\n\n\tvar json = localStorage.getItem(namespace);\n\tvar storage = (json ? JSON.parse(json) : {}) || {};\n\n\tvar save = function(){\n\t\tjson = JSON.stringify(storage);\n\t\tlocalStorage.setItem(namespace, json);\n\t\treturn this;\n\t};\n\n\tthis.get = function(key){\n\t\tif (typeof key != 'string'){\n\t\t\tvar result = {}, l = key.length;\n\t\t\tfor (;l--;) result[key[l]] = this.get(key[l]);\n\t\t\treturn result;\n\t\t}\n\t\treturn storage[key] || null;\n\t};\n\n\tthis.set = function(key, value){\n\t\tif (typeof key != 'string') for (var i in key) this.set(i, key[i]); else {\n\t\t\tstorage[key] = value;\n\t\t\tsave();\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.erase = function(key){\n\t\tif (typeof key != 'string') for (var i = key.length; i--;) this.erase(key[i]); else {\n\t\t\tdelete storage[key];\n\t\t\tsave();\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.destroy = function(){\n\t\tlocalStorage.removeItem(namespace);\n\t\treturn this;\n\t};\n\n};\n\n});\n","dependencies":[]},"Centaur\/Base\/Request":{"id":"Centaur\/Base\/Request","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Base\/Request.js","package":"Centaur","amd":true,"content":"\ndefine(function(){\n\nvar Request = function(){\n\tthis.xhr = new XMLHttpRequest();\n};\n\nRequest.prototype = {\n\n\tstateChange: function(success, fail){\n\t\tif (!this.busy) return;\n\t\tif (this.xhr.readyState == 4){\n\t\t\tif (this.xhr.status == 200) success.call(this, this.xhr.responseText, this.xhr.responseXML);\n\t\t\telse if (fail) fail.call(this, this.xhr, this.xhr.resonseText);\n\t\t\tthis.busy = false;\n\t\t}\n\t},\n\n\tsend: function(url, success, fail){\n\t\tif (this.busy) this.abort();\n\t\tthis.xhr.onreadystatechange = this.stateChange.bind(this, success, fail);\n\t\tthis.xhr.open('get', url, true);\n\t\tthis.xhr.send(null);\n\t\tthis.busy = true;\n\t\treturn this;\n\t},\n\n\tabort: function(){\n\t\tthis.xhr.abort();\n\t\treturn this;\n\t}\n\n};\n\nreturn Request;\n\n});\n","dependencies":[]},"Centaur\/Base\/Utility\/pair":{"id":"Centaur\/Base\/Utility\/pair","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Base\/Utility\/pair.js","package":"Centaur","amd":true,"content":"\ndefine(function(){\n\nreturn function(array, fn, bind){\n\tvar object = {};\n\tfor (var i = 0, l = array.length; i < l; i++){\n\t\tif (i in array) object[array[i]] = fn.call(bind, array[i], i, array);\n\t}\n\treturn object;\n};\n\n});\n","dependencies":[]},"Centaur\/Sinks\/Sink.Feed":{"id":"Centaur\/Sinks\/Sink.Feed","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sinks\/Sink.Feed.js","package":"Centaur","amd":true,"content":"\ndefine(['.\/Sink', '..\/Base\/Super'], function(Sink, Super){\n\nSink.Feed = new Super(Sink, {\n\n\tstorageKey: 'sink.feed',\n\tnotifyKey: 'sink.feed',\n\n\t_parse: function(){\n\t\tthis.doc = this.parent('_parse', ['rss']);\n\t\tvar channel = this._inject(this.doc.documentElement, 'channel');\n\t\tthis._injectObject(channel, this.data);\n\t\treturn this.doc;\n\t}\n\n});\n\nreturn Sink;\n\n});\n","dependencies":["Centaur\/Sinks\/Sink","Centaur\/Base\/Super"]},"Centaur\/Sinks\/Sink":{"id":"Centaur\/Sinks\/Sink","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sinks\/Sink.js","package":"Centaur","amd":true,"content":"\ndefine(['..\/Base\/Super', '..\/Base\/Request', '..\/Base\/Storage'], function(Super, Request, Storage){\n\nreturn Super(null, {\n\n\tstorageKey: 'sink',\n\tnotifyKey: 'sink',\n\n\tinit: function(app){\n\t\tthis.app = app;\n\t\tthis.processor = new XSLTProcessor();\n\t\tthis.request = new Request();\n\t\tthis.storage = new Storage(this.storageKey);\n\t\tthis.app.listen(this.notifyKey + '.load', this._transform.bind(this));\n\t},\n\n\tsetData: function(data){\n\t\tthis.data = data;\n\t\treturn this;\n\t},\n\n\tload: function(url, nocache){\n\t\tif (!url) url = this.url;\n\t\tif (!url) throw new Error('A Sink has to have a XSL url');\n\n\t\tif (this.data == null) throw new Error('set the data first with sink.setData');\n\n\t\tvar xslText = this.storage.get(url);\n\t\tif (!nocache && xslText){\n\t\t\tvar parser = new DOMParser();\n\t\t\tvar xsl = parser.parseFromString(xslText, 'text\/xml');\n\t\t\tthis.app.notify(this.notifyKey + '.load', [url, xsl]);\n\t\t} else {\n\t\t\tvar self = this;\n\t\t\tthis.request.send(url, function(text, xsl){\n\t\t\t\tself.storage.set(url, text);\n\t\t\t\tself.app.notify(self.notifyKey + '.load', [url, xsl]);\n\t\t\t}, function(){\n\t\t\t\tself.app.notify(self.notifyKey + '.load.fail', [url]);\n\t\t\t});\n\t\t}\n\t},\n\n\t_transform: function(url, xsl){\n\t\tthis.processor.importStylesheet(xsl);\n\t\tvar fragment = this.processor.transformToFragment(this._parse(), document);\n\t\tthis.app.notify(this.notifyKey + '.transform', [fragment]);\n\t},\n\n\t_parse: function(qualifiedNameStr){\n\t\tthis.doc = document.implementation.createDocument('', qualifiedNameStr || 'html', null);\n\t\treturn this.doc;\n\t},\n\n\t_injectObject: function(parent, object){\n\t\tfor (var tag in object){\n\t\t\tif (typeof object[tag] == 'string') this._inject(parent, tag, object[tag]);\n\t\t\telse for (var list = object[tag], i = 0, l = list.length; i < l; i++){\n\t\t\t\tvar singular = tag.slice(0, -1);\n\t\t\t\tvar item = this._inject(parent, singular);\n\t\t\t\tthis._injectObject(item, list[i]);\n\t\t\t}\n\t\t}\n\t},\n\n\t_inject: function(parent, tag, text){\n\t\tvar element = this.doc.createElement(tag);\n\t\tif (text) element.appendChild(this.doc.createTextNode(text));\n\t\tparent.appendChild(element);\n\t\treturn element;\n\t}\n\n});\n\n});\n","dependencies":["Centaur\/Base\/Super","Centaur\/Base\/Request","Centaur\/Base\/Storage"]},"Centaur\/Modules\/Module.Article":{"id":"Centaur\/Modules\/Module.Article","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Modules\/Module.Article.js","package":"Centaur","amd":true,"content":"\ndefine([\n\t'.\/Module',\n\t'..\/Sources\/Source.Article',\n\t'..\/Sinks\/Sink.Article',\n\t'..\/Base\/Super'\n], function(Module, Source, Sink, Super){\n\nModule.Article = new Super(Module, {\n\n\tinit: function(options){\n\t\tthis.parent('init', [options]);\n\n\t\tthis.sink = new Sink.Article(this.app);\n\t\tthis.source = new Source.Article(this.app);\n\n\t\tvar self = this, app = this.app;\n\t\tthis.bound = {\n\t\t\t'source.article.load': function(data){\n\t\t\t\tself.sink.setData(data);\n\t\t\t\tself.sink.load('fixtures\/article.xsl');\n\t\t\t},\n\t\t\t'sink.article.transform': function(fragment){\n\t\t\t\tapp.setMainContent(fragment);\n\t\t\t},\n\t\t\t'statechange.article': function(newstate){\n\t\t\t\tself.source.load(newstate[0]);\n\t\t\t}\n\t\t};\n\n\t},\n\n\tload: function(){\n\t\tthis.app.listen(this.bound);\n\t},\n\n\tunload: function(){\n\t\tthis.app.ignore(this.bound);\n\t}\n\n});\n\nreturn Module;\n\n});\n","dependencies":["Centaur\/Modules\/Module","Centaur\/Sources\/Source.Article","Centaur\/Sinks\/Sink.Article","Centaur\/Base\/Super"]},"Centaur\/Sources\/Source.Article":{"id":"Centaur\/Sources\/Source.Article","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sources\/Source.Article.js","package":"Centaur","amd":true,"content":"\ndefine(['.\/Source.Request', '..\/Base\/Super', '..\/Base\/Utility\/pair'], function(Source, Super, pair){\n\nvar slice = Array.prototype.slice;\n\nSource.Article = new Super(Source.Request, {\n\n\tstorageKey: 'source.article',\n\tnotifyKey: 'source.article',\n\n\toptions: {\n\t\turl: 'fixtures\/article_{guid}.xml'\n\t},\n\n\tinit: function(app, options){\n\t\tthis.parent('init', [app, options]);\n\t},\n\n\tload: function(id){\n\t\tthis.url = this.options.url.replace('{guid}', id);\n\t\tthis.parent('load', slice.call(arguments, 1));\n\t},\n\n\t_parse: function(text, xml){\n\n\t\tvar data = pair(['category', 'title', 'description', 'link', 'guid', 'pubDate'], function(tag){\n\t\t\tvar element = xml.querySelector('article ' + tag);\n\t\t\treturn element && element.textContent || '';\n\t\t});\n\n\t\treturn data;\n\t}\n\n});\n\nreturn Source;\n\n});\n","dependencies":["Centaur\/Sources\/Source.Request","Centaur\/Base\/Super","Centaur\/Base\/Utility\/pair"]},"Centaur\/Sinks\/Sink.Article":{"id":"Centaur\/Sinks\/Sink.Article","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sinks\/Sink.Article.js","package":"Centaur","amd":true,"content":"\ndefine(['.\/Sink', '..\/Base\/Super'], function(Sink, Super){\n\nSink.Article = new Super(Sink, {\n\n\tstorageKey: 'sink.article',\n\tnotifyKey: 'sink.article',\n\n\t_parse: function(){\n\t\tthis.doc = this.parent('_parse', ['article']);\n\t\tthis._injectObject(this.doc.documentElement, this.data);\n\t\treturn this.doc;\n\t}\n\n});\n\nreturn Sink;\n\n});\n","dependencies":["Centaur\/Sinks\/Sink","Centaur\/Base\/Super"]},"Centaur\/Modules\/Module.Config":{"id":"Centaur\/Modules\/Module.Config","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Modules\/Module.Config.js","package":"Centaur","amd":true,"content":"\ndefine([\n\t'.\/Module',\n\t'..\/Sources\/Source.Config',\n\t'..\/Sinks\/Sink.Config',\n\t'..\/Base\/Super'\n], function(Module, Source, Sink, Super){\n\nModule.Article = new Super(Module, {\n\n\tinit: function(options){\n\t\tthis.parent('init', [options]);\n\n\t\tthis.sink = new Sink.Article(this.app);\n\t\tthis.source = new Source.Article(this.app);\n\n\t\tvar self = this, app = this.app;\n\t\tthis.bound = {\n\t\t\t'source.article.load': function(data){\n\t\t\t\tself.sink.setData(data);\n\t\t\t\tself.sink.load('fixtures\/article.xsl');\n\t\t\t},\n\t\t\t'sink.article.transform': function(fragment){\n\t\t\t\tapp.setMainContent(fragment);\n\t\t\t},\n\t\t\t'statechange.article': function(newstate){\n\t\t\t\tself.source.load(newstate[0]);\n\t\t\t}\n\t\t};\n\n\t},\n\n\tload: function(){\n\t\tthis.app.listen(this.bound);\n\t},\n\n\tunload: function(){\n\t\tthis.app.ignore(this.bound);\n\t}\n\n});\n\nreturn Module;\n\n});\n","dependencies":["Centaur\/Modules\/Module","Centaur\/Sources\/Source.Config","Centaur\/Sinks\/Sink.Config","Centaur\/Base\/Super"]},"Centaur\/Sources\/Source.Config":{"id":"Centaur\/Sources\/Source.Config","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sources\/Source.Config.js","package":"Centaur","amd":true,"content":"\ndefine(['.\/Source.Request', '..\/Base\/Super', '..\/Base\/Utility\/pair'], function(Source, Super, pair){\n\nvar slice = Array.prototype.slice;\n\nSource.Article = new Super(Source.Request, {\n\n\tstorageKey: 'source.article',\n\tnotifyKey: 'source.article',\n\n\toptions: {\n\t\turl: 'fixtures\/article_{guid}.xml'\n\t},\n\n\tinit: function(app, options){\n\t\tthis.parent('init', [app, options]);\n\t},\n\n\tload: function(id){\n\t\tthis.url = this.options.url.replace('{guid}', id);\n\t\tthis.parent('load', slice.call(arguments, 1));\n\t},\n\n\t_parse: function(text, xml){\n\n\t\tvar data = pair(['category', 'title', 'description', 'link', 'guid', 'pubDate'], function(tag){\n\t\t\tvar element = xml.querySelector('article ' + tag);\n\t\t\treturn element && element.textContent || '';\n\t\t});\n\n\t\treturn data;\n\t}\n\n});\n\nreturn Source;\n\n});\n","dependencies":["Centaur\/Sources\/Source.Request","Centaur\/Base\/Super","Centaur\/Base\/Utility\/pair"]},"Centaur\/Sinks\/Sink.Config":{"id":"Centaur\/Sinks\/Sink.Config","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sinks\/Sink.Config.js","package":"Centaur","amd":true,"content":"\ndefine(['.\/Sink', '..\/Base\/Super'], function(Sink, Super){\n\nSink.Article = new Super(Sink, {\n\n\tstorageKey: 'sink.article',\n\tnotifyKey: 'sink.article',\n\n\t_parse: function(){\n\t\tthis.doc = this.parent('_parse', ['article']);\n\t\tthis._injectObject(this.doc.documentElement, this.data);\n\t\treturn this.doc;\n\t}\n\n});\n\nreturn Sink;\n\n});\n","dependencies":["Centaur\/Sinks\/Sink","Centaur\/Base\/Super"]},"Centaur\/Modules\/Module.Font":{"id":"Centaur\/Modules\/Module.Font","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Modules\/Module.Font.js","package":"Centaur","amd":true,"content":"\ndefine([\n\t'.\/Module',\n\t'..\/Sources\/Source.Font',\n\t'..\/Sinks\/Sink.Font',\n\t'..\/Base\/Super'\n], function(Module, Source, Sink, Super){\n\nModule.Article = new Super(Module, {\n\n\tinit: function(options){\n\t\tthis.parent('init', [options]);\n\n\t\tthis.sink = new Sink.Article(this.app);\n\t\tthis.source = new Source.Article(this.app);\n\n\t\tvar self = this, app = this.app;\n\t\tthis.bound = {\n\t\t\t'source.article.load': function(data){\n\t\t\t\tself.sink.setData(data);\n\t\t\t\tself.sink.load('fixtures\/article.xsl');\n\t\t\t},\n\t\t\t'sink.article.transform': function(fragment){\n\t\t\t\tapp.setMainContent(fragment);\n\t\t\t},\n\t\t\t'statechange.article': function(newstate){\n\t\t\t\tself.source.load(newstate[0]);\n\t\t\t}\n\t\t};\n\n\t},\n\n\tload: function(){\n\t\tthis.app.listen(this.bound);\n\t},\n\n\tunload: function(){\n\t\tthis.app.ignore(this.bound);\n\t}\n\n});\n\nreturn Module;\n\n});\n","dependencies":["Centaur\/Modules\/Module","Centaur\/Sources\/Source.Font","Centaur\/Sinks\/Sink.Font","Centaur\/Base\/Super"]},"Centaur\/Sources\/Source.Font":{"id":"Centaur\/Sources\/Source.Font","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sources\/Source.Font.js","package":"Centaur","amd":true,"content":"\ndefine(['.\/Source.Request', '..\/Base\/Super', '..\/Base\/Utility\/pair'], function(Source, Super, pair){\n\nvar slice = Array.prototype.slice;\n\nSource.Article = new Super(Source.Request, {\n\n\tstorageKey: 'source.article',\n\tnotifyKey: 'source.article',\n\n\toptions: {\n\t\turl: 'fixtures\/article_{guid}.xml'\n\t},\n\n\tinit: function(app, options){\n\t\tthis.parent('init', [app, options]);\n\t},\n\n\tload: function(id){\n\t\tthis.url = this.options.url.replace('{guid}', id);\n\t\tthis.parent('load', slice.call(arguments, 1));\n\t},\n\n\t_parse: function(text, xml){\n\n\t\tvar data = pair(['category', 'title', 'description', 'link', 'guid', 'pubDate'], function(tag){\n\t\t\tvar element = xml.querySelector('article ' + tag);\n\t\t\treturn element && element.textContent || '';\n\t\t});\n\n\t\treturn data;\n\t}\n\n});\n\nreturn Source;\n\n});\n","dependencies":["Centaur\/Sources\/Source.Request","Centaur\/Base\/Super","Centaur\/Base\/Utility\/pair"]},"Centaur\/Sinks\/Sink.Font":{"id":"Centaur\/Sinks\/Sink.Font","url":"\/home\/arian\/www\/abacus\/centaur\/Source\/Sinks\/Sink.Font.js","package":"Centaur","amd":true,"content":"\ndefine(['.\/Sink', '..\/Base\/Super'], function(Sink, Super){\n\nSink.Article = new Super(Sink, {\n\n\tstorageKey: 'sink.article',\n\tnotifyKey: 'sink.article',\n\n\t_parse: function(){\n\t\tthis.doc = this.parent('_parse', ['article']);\n\t\tthis._injectObject(this.doc.documentElement, this.data);\n\t\treturn this.doc;\n\t}\n\n});\n\nreturn Sink;\n\n});\n","dependencies":["Centaur\/Sinks\/Sink","Centaur\/Base\/Super"]},"dojo\/array":{"id":"dojo\/array","url":"\/home\/arian\/www\/MooTools\/dojo\/array.js","package":"dojo","amd":true,"content":"define([\".\/_base\/kernel\"], function(dojo){\n\tfunction _getParts(arr, obj, cb){\n\t\treturn [\n\t\t\t(typeof arr == \"string\") ? arr.split(\"\") : arr,\n\t\t\tobj || dojo.global,\n\t\t\t\/\/ FIXME: cache the anonymous functions we create here?\n\t\t\t(typeof cb == \"string\") ? new Function(\"item\", \"index\", \"array\", cb) : cb\n\t\t];\n\t}\n\n\tfunction _everyOrSome(\/*Boolean*\/every, \/*Array|String*\/arr, \/*Function|String*\/callback, \/*Object?*\/thisObject){\n\t\tvar _p = _getParts(arr, thisObject, callback); arr = _p[0];\n\t\tfor(var i=0,l=arr.length; i<l; ++i){\n\t\t\tvar result = !!_p[2].call(_p[1], arr[i], i, arr);\n\t\t\tif(every ^ result){\n\t\t\t\treturn result; \/\/ Boolean\n\t\t\t}\n\t\t}\n\t\treturn every; \/\/ Boolean\n\t}\n\n\t\/*===== dojo.array.indexOf = =====*\/ \n\tfunction indexOf(\/*Array*\/arr, \/*Object*\/value, \/*Integer?*\/fromIndex, \/*Boolean?*\/findLast){\n\t\t\/\/ summary:\n\t\t\/\/\t\tlocates the first index of the provided value in the\n\t\t\/\/\t\tpassed array. If the value is not found, -1 is returned.\n\t\t\/\/ description:\n\t\t\/\/\t\tThis method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript\n\t\t\/\/\t\t1.6's indexOf skips the holes in the sparse array.\n\t\t\/\/\t\tFor details on this method, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/indexOf\n\t\tif(!arr || !arr.length){ return -1; }\n\t\tif(findLast){\n\t\t\treturn array.lastIndexOf(arr, value, fromIndex);\n\t\t}\n\n\t\tvar end = arr.length, i = 0, u;\n\n\t\tif(fromIndex === u){ fromIndex = i; }\n\t\tif(fromIndex >= 0){\n\t\t\ti = fromIndex;\n\t\t}else{\n\t\t\ti = end + fromIndex;\n\t\t\ti = i > 0 ? i : 0;\n\t\t}\n\t\tfor(;i<end; i++){\n\t\t\tif(arr[i] == value){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\/*===== dojo.array.lastIndexOf = =====*\/ \n\tfunction lastIndexOf(\/*Array*\/arr, \/*Object*\/value, \/*Integer?*\/fromIndex){\n\t\t\/\/ summary:\n\t\t\/\/\t\tlocates the last index of the provided value in the passed\n\t\t\/\/\t\tarray. If the value is not found, -1 is returned.\n\t\t\/\/ description:\n\t\t\/\/\t\tThis method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript\n\t\t\/\/\t\t1.6's lastIndexOf skips the holes in the sparse array.\n\t\t\/\/\t\tFor details on this method, see:\n\t\t\/\/ \t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/lastIndexOf\n\t\tif(!arr || !arr.length){ return -1; }\n\n\t\tvar end = 0, i = arr.length, u;\n\n\t\tif(fromIndex === u){ fromIndex = i; }\n\t\tif(fromIndex >= 0){\n\t\t\ti = i - 1;\n\t\t\ti = fromIndex < i ? fromIndex : i;\n\t\t}else{\n\t\t\ti = i + fromIndex;\n\t\t}\n\t\tfor(;i>=end; i--){\n\t\t\tif(arr[i] == value){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\/*===== dojo.array.forEach = =====*\/\n\tfunction forEach(\/*Array|String*\/arr, \/*Function|String*\/callback, \/*Object?*\/thisObject){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tfor every item in arr, callback is invoked. Return values are ignored.\n\t\t\/\/\t\tIf you want to break out of the loop, consider using dojo.every() or dojo.some().\n\t\t\/\/\t\tforEach does not allow breaking out of the loop over the items in arr.\n\t\t\/\/\tarr:\n\t\t\/\/\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t\/\/\tcallback:\n\t\t\/\/\t\ta function is invoked with three arguments: item, index, and array\n\t\t\/\/\tthisObject:\n\t\t\/\/\t\tmay be used to scope the call to callback\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tThis function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, this implemenation passes the \"holes\" in the sparse array to\n\t\t\/\/\t\tthe callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.\n\t\t\/\/\t\tFor more details, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/forEach\n\t\t\/\/\texample:\n\t\t\/\/\t| \/\/ log out all members of the array:\n\t\t\/\/\t| dojo.forEach(\n\t\t\/\/\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\/\/\t|\t\tfunction(item){\n\t\t\/\/\t|\t\t\tconsole.log(item);\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t| );\n\t\t\/\/\texample:\n\t\t\/\/\t| \/\/ log out the members and their indexes\n\t\t\/\/\t| dojo.forEach(\n\t\t\/\/\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\/\/\t|\t\tfunction(item, idx, arr){\n\t\t\/\/\t|\t\t\tconsole.log(item, \"at index:\", idx);\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t| );\n\t\t\/\/\texample:\n\t\t\/\/\t| \/\/ use a scoped object member as the callback\n\t\t\/\/\t|\n\t\t\/\/\t| var obj = {\n\t\t\/\/\t|\t\tprefix: \"logged via obj.callback:\",\n\t\t\/\/\t|\t\tcallback: function(item){\n\t\t\/\/\t|\t\t\tconsole.log(this.prefix, item);\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t| };\n\t\t\/\/\t|\n\t\t\/\/\t| \/\/ specifying the scope function executes the callback in that scope\n\t\t\/\/\t| dojo.forEach(\n\t\t\/\/\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\/\/\t|\t\tobj.callback,\n\t\t\/\/\t|\t\tobj\n\t\t\/\/\t| );\n\t\t\/\/\t|\n\t\t\/\/\t| \/\/ alternately, we can accomplish the same thing with dojo.hitch()\n\t\t\/\/\t| dojo.forEach(\n\t\t\/\/\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\/\/\t|\t\tdojo.hitch(obj, \"callback\")\n\t\t\/\/\t| );\n\n\t\t\/\/ match the behavior of the built-in forEach WRT empty arrs\n\t\tif(!arr || !arr.length){ return; }\n\n\t\t\/\/ FIXME: there are several ways of handilng thisObject. Is\n\t\t\/\/ dojo.global always the default context?\n\t\tvar _p = _getParts(arr, thisObject, callback); arr = _p[0];\n\t\tfor(var i=0,l=arr.length; i<l; ++i){\n\t\t\t_p[2].call(_p[1], arr[i], i, arr);\n\t\t}\n\t}\n\n\t\/*===== dojo.array.every = =====*\/ \n\tfunction every(\/*Array|String*\/arr, \/*Function|String*\/callback, \/*Object?*\/thisObject){\n\t\t\/\/ summary:\n\t\t\/\/\t\tDetermines whether or not every item in arr satisfies the\n\t\t\/\/\t\tcondition implemented by callback.\n\t\t\/\/ arr:\n\t\t\/\/\t\tthe array to iterate on. If a string, operates on individual characters.\n\t\t\/\/ callback:\n\t\t\/\/\t\ta function is invoked with three arguments: item, index,\n\t\t\/\/\t\tand array and returns true if the condition is met.\n\t\t\/\/ thisObject:\n\t\t\/\/\t\tmay be used to scope the call to callback\n\t\t\/\/ description:\n\t\t\/\/\t\tThis function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, this implemenation passes the \"holes\" in the sparse array to\n\t\t\/\/\t\tthe callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.\n\t\t\/\/\t\tFor more details, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/every\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ returns false\n\t\t\/\/\t| dojo.every([1, 2, 3, 4], function(item){ return item>1; });\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ returns true\n\t\t\/\/\t| dojo.every([1, 2, 3, 4], function(item){ return item>0; });\n\t\treturn _everyOrSome(true, arr, callback, thisObject); \/\/ Boolean\n\t}\n\n\t\/*===== dojo.array.lastIndexOf = =====*\/ \n\tfunction some(\/*Array|String*\/arr, \/*Function|String*\/callback, \/*Object?*\/thisObject){\n\t\t\/\/ summary:\n\t\t\/\/\t\tDetermines whether or not any item in arr satisfies the\n\t\t\/\/\t\tcondition implemented by callback.\n\t\t\/\/ arr:\n\t\t\/\/\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t\/\/ callback:\n\t\t\/\/\t\ta function is invoked with three arguments: item, index,\n\t\t\/\/\t\tand array and returns true if the condition is met.\n\t\t\/\/ thisObject:\n\t\t\/\/\t\tmay be used to scope the call to callback\n\t\t\/\/ description:\n\t\t\/\/\t\tThis function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, this implemenation passes the \"holes\" in the sparse array to\n\t\t\/\/\t\tthe callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.\n\t\t\/\/\t\tFor more details, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/some\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ is true\n\t\t\/\/\t| dojo.some([1, 2, 3, 4], function(item){ return item>1; });\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ is false\n\t\t\/\/\t| dojo.some([1, 2, 3, 4], function(item){ return item<1; });\n\t\treturn _everyOrSome(false, arr, callback, thisObject); \/\/ Boolean\n\t}\n\n\t\/*===== dojo.array.map = =====*\/ \n\tfunction map(\/*Array|String*\/arr, \/*Function|String*\/callback, \/*Function?*\/thisObject){\n\t\t\/\/ summary:\n\t\t\/\/\t\tapplies callback to each element of arr and returns\n\t\t\/\/\t\tan Array with the results\n\t\t\/\/ arr:\n\t\t\/\/\t\tthe array to iterate on. If a string, operates on\n\t\t\/\/\t\tindividual characters.\n\t\t\/\/ callback:\n\t\t\/\/\t\ta function is invoked with three arguments, (item, index,\n\t\t\/\/\t\tarray),\t and returns a value\n\t\t\/\/ thisObject:\n\t\t\/\/\t\tmay be used to scope the call to callback\n\t\t\/\/ description:\n\t\t\/\/\t\tThis function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, this implemenation passes the \"holes\" in the sparse array to\n\t\t\/\/\t\tthe callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.\n\t\t\/\/\t\tFor more details, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/map\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ returns [2, 3, 4, 5]\n\t\t\/\/\t| dojo.map([1, 2, 3, 4], function(item){ return item+1 });\n\n\t\tvar _p = _getParts(arr, thisObject, callback); arr = _p[0];\n\t\tvar outArr = (arguments[3] ? (new arguments[3]()) : []);\n\t\tfor(var i=0,l=arr.length; i<l; ++i){\n\t\t\toutArr.push(_p[2].call(_p[1], arr[i], i, arr));\n\t\t}\n\t\treturn outArr; \/\/ Array\n\t}\n\n\t\/*===== dojo.array.filter = =====*\/ \n\tfunction filter(\/*Array*\/arr, \/*Function|String*\/callback, \/*Object?*\/thisObject){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns a new Array with those items from arr that match the\n\t\t\/\/\t\tcondition implemented by callback.\n\t\t\/\/ arr:\n\t\t\/\/\t\tthe array to iterate over.\n\t\t\/\/ callback:\n\t\t\/\/\t\ta function that is invoked with three arguments (item,\n\t\t\/\/\t\tindex, array). The return of this function is expected to\n\t\t\/\/\t\tbe a boolean which determines whether the passed-in item\n\t\t\/\/\t\twill be included in the returned array.\n\t\t\/\/ thisObject:\n\t\t\/\/\t\tmay be used to scope the call to callback\n\t\t\/\/ description:\n\t\t\/\/\t\tThis function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, this implemenation passes the \"holes\" in the sparse array to\n\t\t\/\/\t\tthe callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\n\t\t\/\/\t\tFor more details, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/filter\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ returns [2, 3, 4]\n\t\t\/\/\t| dojo.filter([1, 2, 3, 4], function(item){ return item>1; });\n\n\t\tvar _p = _getParts(arr, thisObject, callback); arr = _p[0];\n\t\tvar outArr = [];\n\t\tfor(var i=0,l=arr.length; i<l; ++i){\n\t\t\tif(_p[2].call(_p[1], arr[i], i, arr)){\n\t\t\t\toutArr.push(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn outArr; \/\/ Array\n\t}\n\n\tvar array = {\n\t\tindexOf: indexOf,\n\t\tlastIndexOf: lastIndexOf,\n\t\tforEach: forEach,\n\t\tevery: every,\n\t\tsome: some,\n\t\tmap: map,\n\t\tfilter: filter\n\t};\n\n\t\/*===== return dojo.array; =====*\/\n\treturn array;\n});\n","dependencies":["dojo\/_base\/kernel"]},"dojo\/_base\/kernel":{"id":"dojo\/_base\/kernel","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/kernel.js","package":"dojo","amd":true,"content":"define([\"..\/has\", \".\/config\", \"require\", \"module\"], function(has, config, require, module){\n\t\/\/ module:\n\t\/\/\t\tdojo\/_base\/kernel\n\t\/\/ summary:\n\t\/\/\t\tThis module is the foundational module of the dojo boot sequence; it defines the dojo object.\n\tvar\n\t\t\/\/ loop variables for this module\n\t\ti, p,\n\n\t\t\/\/ create dojo, dijit, and dojox\n\t\t\/\/ FIXME: in 2.0 remove dijit, dojox being created by dojo\n\t\tdijit = {},\n\t\tdojox = {},\n\t\tdojo = {\n\t\t\t\/\/ notice dojo takes ownership of the value of the config module\n\t\t\tconfig:config,\n\t\t\tglobal:this,\n\t\t\tdijit:dijit,\n\t\t\tdojox:dojox\n\t\t};\n\n\n\t\/\/ Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide\n\t\/\/ a _scopeName property for the dojo, dijit, and dojox root object so those packages can create\n\t\/\/ unique names in the global space.\n\t\/\/\n\t\/\/ Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,\n\t\/\/ where global when in fact they are either global under different names or not global at all. In v1.6-, the\n\t\/\/ config variable \"scopeMap\" was used to map names as used within a module to global names. This has been\n\t\/\/ subsumed by the dojo packageMap configuration variable which relocates packages to different names. See\n\t\/\/ http:\/\/livedocs.dojotoolkit.org\/developer\/design\/loader#legacy-cross-domain-mode for details.\n\t\/\/\n\t\/\/ The following computations contort the packageMap for this dojo instance into a scopeMap.\n\tvar scopeMap =\n\t\t\t\/\/ a map from a name used in a legacy module to the (global variable name, object addressed by that name)\n\t\t\t\/\/ always map dojo, dijit, and dojox\n\t\t\t{\n\t\t\t\tdojo:[\"dojo\", dojo],\n\t\t\t\tdijit:[\"dijit\", dijit],\n\t\t\t\tdojox:[\"dojox\", dojox]\n\t\t\t},\n\n\t\tpackageMap =\n\t\t\t\/\/ the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config\n\t\t\t(require.packs && require.packs[module.id.match(\/[^\\\/]+\/)[0]].packageMap) || {},\n\n\t\titem;\n\n\t\/\/ process all mapped top-level names for this instance of dojo\n\tfor(p in packageMap){\n\t\tif(scopeMap[p]){\n\t\t\t\/\/ mapped dojo, dijit, or dojox\n\t\t\tscopeMap[p][0] = packageMap[p];\n\t\t}else{\n\t\t\t\/\/ some other top-level name\n\t\t\tscopeMap[p] = [packageMap[p], {}];\n\t\t}\n\t}\n\n\t\/\/ publish those names to _scopeName and, optionally, the global namespace\n\tfor(p in scopeMap){\n\t\titem = scopeMap[p];\n\t\titem[1]._scopeName = item[0];\n\t\tif(!config.noGlobals){\n\t\t\tthis[item[0]] = item[1];\n\t\t}\n\t}\n\tdojo.scopeMap = scopeMap;\n\n\t\/\/ FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated\n\tdojo.baseUrl = dojo.config.baseUrl = require.baseUrl;\n\tdojo.isAsync = !has(\"dojo-loader\") || require.async;\n\tdojo.locale = config.locale;\n\n\t\/*=====\n\t\tdojo.version = function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tVersion number of the Dojo Toolkit\n\t\t\t\/\/ major: Integer\n\t\t\t\/\/\t\tMajor version. If total version is \"1.2.0beta1\", will be 1\n\t\t\t\/\/ minor: Integer\n\t\t\t\/\/\t\tMinor version. If total version is \"1.2.0beta1\", will be 2\n\t\t\t\/\/ patch: Integer\n\t\t\t\/\/\t\tPatch version. If total version is \"1.2.0beta1\", will be 0\n\t\t\t\/\/ flag: String\n\t\t\t\/\/\t\tDescriptor flag. If total version is \"1.2.0beta1\", will be \"beta1\"\n\t\t\t\/\/ revision: Number\n\t\t\t\/\/\t\tThe SVN rev from which dojo was pulled\n\t\t\tthis.major = 0;\n\t\t\tthis.minor = 0;\n\t\t\tthis.patch = 0;\n\t\t\tthis.flag = \"\";\n\t\t\tthis.revision = 0;\n\t\t}\n\t=====*\/\n\tvar rev = \"$Rev: 23930 $\".match(\/\\d+\/);\n\tdojo.version = {\n\t\tmajor: 1, minor: 7, patch: 0, flag: \"dev\",\n\t\trevision: rev ? +rev[0] : NaN,\n\t\ttoString: function(){\n\t\t\tvar v = dojo.version;\n\t\t\treturn v.major + \".\" + v.minor + \".\" + v.patch + v.flag + \" (\" + v.revision + \")\";\t\/\/ String\n\t\t}\n\t};\n\n\tif(has(\"dojo-loader\")){\n\t\tdojo.eval = require.eval;\n\t}else{\n\t\tvar eval_ =\n\t\t\t\/\/ use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution\n\t\t\tnew Function(\"__text\", \"return eval(__text);\");\n\n\t\tdojo.eval = function(text, hint){\n\t\t\t\/\/ note: the four forward-slashes make the firebug hint work in ie9\n\t\t\treturn eval_(text + \"\\r\\n\/\/\/\/@ sourceURL=\" + hint);\n\t\t};\n\t}\n\n\tif(has(\"host-rhino\")){\n\t\tdojo.exit = function(exitcode){\n\t\t\tquit(exitcode);\n\t\t};\n\t} else{\n\t\tdojo.exit = function(){\n\t\t};\n\t}\n\n\thas.add(\"dojo-guarantee-console\",\n\t\t\/\/ ensure that console.log, console.warn, etc. are defined\n\t\t1\n\t);\n\tif(has(\"dojo-guarantee-console\")){\n\t\ttypeof console != \"undefined\" || (console = {});\n\t\t\/\/\tBe careful to leave 'log' always at the end\n\t\tvar cn = [\n\t\t\t\"assert\", \"count\", \"debug\", \"dir\", \"dirxml\", \"error\", \"group\",\n\t\t\t\"groupEnd\", \"info\", \"profile\", \"profileEnd\", \"time\", \"timeEnd\",\n\t\t\t\"trace\", \"warn\", \"log\"\n\t\t];\n\t\tvar tn;\n\t\ti = 0;\n\t\twhile((tn = cn[i++])){\n\t\t\tif(!console[tn]){\n\t\t\t\t(function(){\n\t\t\t\t\tvar tcn = tn + \"\";\n\t\t\t\t\tconsole[tcn] = ('log' in console) ? function(){\n\t\t\t\t\t\tvar a = Array.apply({}, arguments);\n\t\t\t\t\t\ta.unshift(tcn + \":\");\n\t\t\t\t\t\tconsole[\"log\"](a.join(\" \"));\n\t\t\t\t\t} : function(){};\n\t\t\t\t\tconsole[tcn]._fake = true;\n\t\t\t\t})();\n\t\t\t}\n\t\t}\n\t}\n\n\thas.add(\"dojo-debug-messages\",\n\t\t\/\/ include dojo.deprecated\/dojo.experimental implementations\n\t\t1\n\t);\n\tif(has(\"dojo-debug-messages\")){\n\t\tdojo.deprecated = function(\/*String*\/ behaviour, \/*String?*\/ extra, \/*String?*\/ removal){\n\t\t\t\/\/\tsummary:\n\t\t\t\/\/\t\tLog a debug message to indicate that a behavior has been\n\t\t\t\/\/\t\tdeprecated.\n\t\t\t\/\/\tbehaviour: String\n\t\t\t\/\/\t\tThe API or behavior being deprecated. Usually in the form\n\t\t\t\/\/\t\tof \"myApp.someFunction()\".\n\t\t\t\/\/\textra: String?\n\t\t\t\/\/\t\tText to append to the message. Often provides advice on a\n\t\t\t\/\/\t\tnew function or facility to achieve the same goal during\n\t\t\t\/\/\t\tthe deprecation period.\n\t\t\t\/\/\tremoval: String?\n\t\t\t\/\/\t\tText to indicate when in the future the behavior will be\n\t\t\t\/\/\t\tremoved. Usually a version number.\n\t\t\t\/\/\texample:\n\t\t\t\/\/\t| dojo.deprecated(\"myApp.getTemp()\", \"use myApp.getLocaleTemp() instead\", \"1.0\");\n\n\t\t\tvar message = \"DEPRECATED: \" + behaviour;\n\t\t\tif(extra){ message += \" \" + extra; }\n\t\t\tif(removal){ message += \" -- will be removed in version: \" + removal; }\n\t\t\tconsole.warn(message);\n\t\t};\n\n\t\tdojo.experimental = function(\/* String *\/ moduleName, \/* String? *\/ extra){\n\t\t\t\/\/\tsummary: Marks code as experimental.\n\t\t\t\/\/\tdescription:\n\t\t\t\/\/\t\tThis can be used to mark a function, file, or module as\n\t\t\t\/\/\t\texperimental.\t Experimental code is not ready to be used, and the\n\t\t\t\/\/\t\tAPIs are subject to change without notice.\tExperimental code may be\n\t\t\t\/\/\t\tcompleted deleted without going through the normal deprecation\n\t\t\t\/\/\t\tprocess.\n\t\t\t\/\/\tmoduleName: String\n\t\t\t\/\/\t\tThe name of a module, or the name of a module file or a specific\n\t\t\t\/\/\t\tfunction\n\t\t\t\/\/\textra: String?\n\t\t\t\/\/\t\tsome additional message for the user\n\t\t\t\/\/\texample:\n\t\t\t\/\/\t| dojo.experimental(\"dojo.data.Result\");\n\t\t\t\/\/\texample:\n\t\t\t\/\/\t| dojo.experimental(\"dojo.weather.toKelvin()\", \"PENDING approval from NOAA\");\n\t\t\tvar message = \"EXPERIMENTAL: \" + moduleName + \" -- APIs subject to change without notice.\";\n\t\t\tif(extra){ message += \" \" + extra; }\n\t\t\tconsole.warn(message);\n\t\t};\n\t}\n\n\thas.add(\"dojo-modulePaths\",\n\t\t\/\/ consume dojo.modulePaths processing\n\t\t1\n\t);\n\tif(has(\"dojo-modulePaths\")){\n\t\t\/\/ notice that modulePaths won't be applied to any require's before the dojo\/_base\/kernel factory is run;\n\t\t\/\/ this is the v1.6- behavior.\n\t\tif(config.modulePaths){\n\t\t\tdojo.deprecated(\"dojo.modulePaths\", \"use paths configuration\");\n\t\t\tvar paths = {};\n\t\t\tfor(p in config.modulePaths){\n\t\t\t\tpaths[p.replace(\/\\.\/g, \"\/\")] = config.modulePaths[p];\n\t\t\t}\n\t\t\trequire({paths:paths});\n\t\t}\n\t}\n\n\thas.add(\"dojo-moduleUrl\",\n\t\t\/\/ include dojo.moduleUrl\n\t\t1\n\t);\n\tif(has(\"dojo-moduleUrl\")){\n\t\tdojo.moduleUrl = function(\/*String*\/module, \/*String?*\/url){\n\t\t\t\/\/\tsummary:\n\t\t\t\/\/\t\tReturns a URL relative to a module.\n\t\t\t\/\/\texample:\n\t\t\t\/\/\t|\tvar pngPath = dojo.moduleUrl(\"acme\",\"images\/small.png\");\n\t\t\t\/\/\t|\tconsole.dir(pngPath); \/\/ list the object properties\n\t\t\t\/\/\t|\t\/\/ create an image and set it's source to pngPath's value:\n\t\t\t\/\/\t|\tvar img = document.createElement(\"img\");\n\t\t\t\/\/\t|\timg.src = pngPath;\n\t\t\t\/\/\t|\t\/\/ add our image to the document\n\t\t\t\/\/\t|\tdojo.body().appendChild(img);\n\t\t\t\/\/\texample:\n\t\t\t\/\/\t\tyou may de-reference as far as you like down the package\n\t\t\t\/\/\t\thierarchy.  This is sometimes handy to avoid lenghty relative\n\t\t\t\/\/\t\turls or for building portable sub-packages. In this example,\n\t\t\t\/\/\t\tthe `acme.widget` and `acme.util` directories may be located\n\t\t\t\/\/\t\tunder different roots (see `dojo.registerModulePath`) but the\n\t\t\t\/\/\t\tthe modules which reference them can be unaware of their\n\t\t\t\/\/\t\trelative locations on the filesystem:\n\t\t\t\/\/\t|\t\/\/ somewhere in a configuration block\n\t\t\t\/\/\t|\tdojo.registerModulePath(\"acme.widget\", \"..\/..\/acme\/widget\");\n\t\t\t\/\/\t|\tdojo.registerModulePath(\"acme.util\", \"..\/..\/util\");\n\t\t\t\/\/\t|\n\t\t\t\/\/\t|\t\/\/ ...\n\t\t\t\/\/\t|\n\t\t\t\/\/\t|\t\/\/ code in a module using acme resources\n\t\t\t\/\/\t|\tvar tmpltPath = dojo.moduleUrl(\"acme.widget\",\"templates\/template.html\");\n\t\t\t\/\/\t|\tvar dataPath = dojo.moduleUrl(\"acme.util\",\"resources\/data.json\");\n\n\t\t\tdojo.deprecated(\"dojo.moduleUrl()\", \"use require.toUrl\", \"2.0\");\n\n\t\t\t\/\/ require.toUrl requires a filetype; therefore, just append the suffix \"\/*.*\" to guarantee a filetype, then\n\t\t\t\/\/ remove the suffix from the result. This way clients can request a url w\/out a filetype. This should be\n\t\t\t\/\/ rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).\n\t\t\t\/\/ Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.\n\t\t\tvar result = null;\n\t\t\tif(module){\n\t\t\t\tresult = require.toUrl(module.replace(\/\\.\/g, \"\/\") + (url ? (\"\/\" + url) : \"\") + \"\/*.*\").replace(\/\\\/\\*\\.\\*\/, \"\") + (url ? \"\" : \"\/\");\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}\n\n\treturn dojo;\n});\n","dependencies":["dojo\/has","dojo\/_base\/config","require","module"]},"dojo\/has":{"id":"dojo\/has","url":"\/home\/arian\/www\/MooTools\/dojo\/has.js","package":"dojo","amd":true,"content":"define([\"require\"], function(require) {\n\t\/\/ module:\n\t\/\/\t\tdojo\/has\n\t\/\/ summary:\n\t\/\/\t\tDefines the has.js API and several feature tests used by dojo.\n\t\/\/ description:\n\t\/\/\t\tThis module defines the has API as described by the project has.js with the following additional features:\n\t\/\/\n\t\/\/\t\t\t* the has test cache is exposed at has.cache.\n\t\/\/\t\t\t* the method has.add includes a forth parameter that controls whether or not existing tests are replaced\n\t\/\/\t\t\t* the loader's has cache may be optionally copied into this module's has cahce.\n\t\/\/\n\t\/\/\t\tThis module adopted from https:\/\/github.com\/phiggins42\/has.js; thanks has.js team!\n\n\t\/\/ try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one\n\t\/\/ WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail\n\tvar has = require.has || function(){};\n\tif(!has(\"dojo-has-api\")){\n\t\t\/\/ notice the condition is written so that if has(\"dojo-has-api\") is transformed to 1 during a build\n\t\t\/\/ the conditional will be (!1 && typeof has==\"function\") which is statically false and the closure\n\t\t\/\/ compiler will discard the block.\n\t\tvar\n\t\t\tisBrowser =\n\t\t\t\t\/\/ the most fundamental decision: are we in the browser?\n\t\t\t\ttypeof window != \"undefined\" &&\n\t\t\t\ttypeof location != \"undefined\" &&\n\t\t\t\ttypeof document != \"undefined\" &&\n\t\t\t\twindow.location == location && window.document == document,\n\n\t\t\t\/\/ has API variables\n\t\t\tglobal = this,\n\t\t\tdoc = isBrowser && document,\n\t\t\telement = doc && doc.createElement(\"DiV\"),\n\t\t\tcache = {};\n\n\t\thas = \/*===== dojo.has= =====*\/ function(name){\n\t\t\t\/\/\tsummary:\n\t\t\t\/\/\t\tReturn the current value of the named feature.\n\t\t\t\/\/\n\t\t\t\/\/\tname: String|Integer\n\t\t\t\/\/\t\tThe name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t\/\/\n\t\t\t\/\/\tdescription:\n\t\t\t\/\/\t\tReturns the value of the feature named by name. The feature must have been\n\t\t\t\/\/\t\tpreviously added to the cache by has.add.\n\n\t\t\treturn cache[name] = typeof cache[name] == \"function\" ? cache[name](global, doc, element) : cache[name]; \/\/ Boolean\n\t\t};\n\n\t\thas.cache = cache;\n\n\t\thas.add = \/*====== dojo.has.add= ======*\/ function(name, test, now, force){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t Register a new feature test for some named feature.\n\t\t\t\/\/\n\t\t\t\/\/ name: String|Integer\n\t\t\t\/\/\t The name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t\/\/\n\t\t\t\/\/ test: Function\n\t\t\t\/\/\t A test function to register. If a function, queued for testing until actually\n\t\t\t\/\/\t needed. The test function should return a boolean indicating\n\t\t\t\/\/\t the presence of a feature or bug.\n\t\t\t\/\/\n\t\t\t\/\/ now: Boolean?\n\t\t\t\/\/\t Optional. Omit if `test` is not a function. Provides a way to immediately\n\t\t\t\/\/\t run the test and cache the result.\n\t\t\t\/\/\n\t\t\t\/\/ force: Boolean?\n\t\t\t\/\/\t Optional. If the test already exists and force is truthy, then the existing\n\t\t\t\/\/\t test will be replaced; otherwise, add does not replace an existing test (that\n\t\t\t\/\/\t is, by default, the first test advice wins).\n\t\t\t\/\/\n\t\t\t\/\/ example:\n\t\t\t\/\/\t\t\tA redundant test, testFn with immediate execution:\n\t\t\t\/\/\t|\t\t\t\thas.add(\"javascript\", function(){ return true; }, true);\n\t\t\t\/\/\n\t\t\t\/\/ example:\n\t\t\t\/\/\t\t\tAgain with the redundantness. You can do this in your tests, but we should\n\t\t\t\/\/\t\t\tnot be doing this in any internal has.js tests\n\t\t\t\/\/\t|\t\t\t\thas.add(\"javascript\", true);\n\t\t\t\/\/\n\t\t\t\/\/ example:\n\t\t\t\/\/\t\t\tThree things are passed to the testFunction. `global`, `document`, and a generic element\n\t\t\t\/\/\t\t\tfrom which to work your test should the need arise.\n\t\t\t\/\/\t|\t\t\t\thas.add(\"bug-byid\", function(g, d, el){\n\t\t\t\/\/\t|\t\t\t\t\t\t\/\/ g\t== global, typically window, yadda yadda\n\t\t\t\/\/\t|\t\t\t\t\t\t\/\/ d\t== document object\n\t\t\t\/\/\t|\t\t\t\t\t\t\/\/ el == the generic element. a `has` element.\n\t\t\t\/\/\t|\t\t\t\t\t\treturn false; \/\/ fake test, byid-when-form-has-name-matching-an-id is slightly longer\n\t\t\t\/\/\t|\t\t\t\t});\n\n\t\t\t(typeof cache[name]==\"undefined\" || force) && (cache[name]= test);\n\t\t\treturn now && has(name);\n\t\t};\n\n\t\t\/\/ since we're operating under a loader that doesn't provide a has API, we must explicitly initialize\n\t\t\/\/ has as it would have otherwise been initialized by the dojo loader; use has.add to the builder\n\t\t\/\/ can optimize these away iff desired\n\t\thas.add(\"host-browser\", isBrowser);\n\t\thas.add(\"dom\", isBrowser);\n\t\thas.add(\"dojo-dom-ready-api\", 1);\n\t\thas.add(\"dojo-sniff\", 1);\n\t}\n\n\tif(has(\"host-browser\")){\n\t\tvar agent = navigator.userAgent;\n\t\t\/\/ Common application level tests\n\t\thas.add(\"dom-addeventlistener\", !!document.addEventListener);\n\t\thas.add(\"touch\", \"ontouchstart\" in document);\n\t\t\/\/ I don't know if any of these tests are really correct, just a rough guess\n\t\thas.add(\"device-width\", screen.availWidth || innerWidth);\n\t\thas.add(\"agent-ios\", !!agent.match(\/iPhone|iP[ao]d\/));\n\t\thas.add(\"agent-android\", agent.indexOf(\"android\") > 1);\n\t}\n\n\thas.clearElement = \/*===== dojo.has.clearElement= ======*\/ function(element) {\n\t\t\/\/ summary:\n\t\t\/\/\t Deletes the contents of the element passed to test functions.\n\t\telement.innerHTML= \"\";\n\t\treturn element;\n\t};\n\n\thas.load = \/*===== dojo.has.load= ======*\/ function(id, parentRequire, loaded){\n\t\t\/\/ summary:\n\t\t\/\/\t Conditional loading of AMD modules based on a has feature test value.\n\t\t\/\/\n\t\t\/\/ id: String\n\t\t\/\/\t Gives the has feature name, a module to load when the feature exists, and optionally a module\n\t\t\/\/\t to load when the feature is false. The string had the format `\"feature-name!path\/to\/module!path\/to\/other\/module\"`\n\t\t\/\/\n\t\t\/\/ parentRequire: Function\n\t\t\/\/\t The loader require function with respect to the module that contained the plugin resource in it's\n\t\t\/\/\t dependency list.\n\t\t\/\/\n\t\t\/\/ loaded: Function\n\t\t\/\/\t Callback to loader that consumes result of plugin demand.\n\n\t\tvar\n\t\t\ttokens = id.match(\/[\\?:]|[^:\\?]*\/g), i = 0,\n\t\t\tget = function(skip){\n\t\t\t\tvar term = tokens[i++];\n\t\t\t\tif(term == \":\"){\n\t\t\t\t\t\/\/ empty string module name, resolves to undefined\n\t\t\t\t\treturn undefined;\n\t\t\t\t}else{\n\t\t\t\t\t\/\/ postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t\t\t\t\tif(tokens[i++] == \"?\"){\n\t\t\t\t\t\tif(!skip && has(term)){\n\t\t\t\t\t\t\t\/\/ matched the feature, get the first value from the options\n\t\t\t\t\t\t\treturn get();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\/\/ did not match, get the second value, passing over the first\n\t\t\t\t\t\t\tget(true);\n\t\t\t\t\t\t\treturn get(skip);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ a module\n\t\t\t\t\treturn term;\n\t\t\t\t}\n\t\t\t};\n\t\tid = get();\n\t\tif(id){\n\t\t\tparentRequire([id], loaded);\n\t\t}else{\n\t\t\tloaded();\n\t\t}\n\t};\n\n\treturn has;\n});\n","dependencies":["require"]},"dojo\/_base\/config":{"id":"dojo\/_base\/config","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/config.js","package":"dojo","amd":true,"content":"define([\"..\/has\", \"require\"], function(has, require){\n\t\/\/ module:\n\t\/\/\t\tdojo\/_base\/config\n\t\/\/ summary:\n\t\/\/\t\tThis module defines the user configuration during bootstrap.\n\t\/\/ description:\n\t\/\/\t\tBy defining user configuration as a module value, an entire configuration can be specified in a build,\n    \/\/\t\tthereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.\n    \/\/\t\tAlso, when multiple instances of dojo exist in a single application, each will necessarily be located\n\t\/\/\t\tat an unique absolute module identifier as given by the package configuration. Implementing configuration\n\t\/\/\t\tas a module allows for specifying unique, per-instance configurations.\n\t\/\/ example:\n\t\/\/\t\tCreate a second instance of dojo with a different, instance-uniqe configuration (assume the loader and\n\t\/\/\t\tdojo.js are already loaded).\n\t\/\/\t\t|\t\/\/ specify a configuration that creates a new instance of dojo at the absolute module identifier \"myDojo\"\n\t\/\/\t\t|\trequire({\n\t\/\/\t\t|\t\tpackages:[{\n\t\/\/\t\t|\t\t\tname:\"myDojo\",\n\t\/\/\t\t|\t\t\tlocation:\".\", \/\/assume baseUrl points to dojo.js\n\t\/\/\t\t|\t    }]\n\t\/\/\t\t|\t});\n\t\/\/\t\t|\n\t\/\/\t\t|\t\/\/ specify a configuration for the myDojo instance\n\t\/\/\t\t|\tdefine(\"myDojo\/config\", {\n\t\/\/\t\t|\t\t\/\/ normal configuration variables go here, e.g.,\n\t\/\/\t\t|\t\tlocale:\"fr-ca\"\n\t\/\/\t\t|\t});\n\t\/\/\t\t|\n\t\/\/\t\t|\t\/\/ load and use the new instance of dojo\n\t\/\/\t\t|\trequire([\"myDojo\"], function(dojo) {\n\t\/\/\t\t|\t\t\/\/ dojo is the new instance of dojo\n\t\/\/\t\t|\t\t\/\/ use as required\n\t\/\/\t\t|\t});\n\n\tvar result = {};\n\tif(has(\"dojo-config-api\")){\n\t\t\/\/ must be the dojo loader; take a shallow copy of require.rawConfig\n\t\tvar src = require.rawConfig, p;\n\t\tfor(p in src){\n\t\t\tresult[p] = src[p];\n\t\t}\n\t}else{\n\t\tvar adviseHas = function(featureSet, prefix, booting){\n\t\t\tfor(p in featureSet){\n\t\t\t\tp!=\"has\" && has.add(prefix + p, featureSet[p], 0, booting);\n\t\t\t}\n\t\t};\n\t\tresult = has(\"dojo-loader\") ?\n\t\t\t\/\/ must be a built version of the dojo loader; all config stuffed in require.rawConfig\n\t\t\trequire.rawConfig :\n\t\t\t\/\/ a foreign loader\n\t\t\tthis.dojoConfig || this.djConfig || {};\n\t\tadviseHas(result, \"config\", 1);\n\t\tadviseHas(result.has, \"\", 1);\n\t}\n\treturn result;\n\n\/*=====\n\/\/ note:\n\/\/\t\t'dojoConfig' does not exist under 'dojo.*' so that it can be set before the\n\/\/\t\t'dojo' variable exists.\n\/\/ note:\n\/\/\t\tSetting any of these variables *after* the library has loaded does\n\/\/\t\tnothing at all.\n\n\/\/ FIXME: can we document these on dojo.config object and explain they must be set via djConfig\/dojoConfig global prior to loading dojo.js\n\ndojoConfig = {\n\t\/\/ summary:\n\t\/\/\t\tApplication code can set the global 'dojoConfig' prior to loading\n\t\/\/\t\tthe library to control certain global settings for how dojo works.\n\t\/\/\n\t\/\/ isDebug: Boolean\n\t\/\/\t\tDefaults to `false`. If set to `true`, ensures that Dojo provides\n\t\/\/\t\textended debugging feedback via Firebug. If Firebug is not available\n\t\/\/\t\ton your platform, setting `isDebug` to `true` will force Dojo to\n\t\/\/\t\tpull in (and display) the version of Firebug Lite which is\n\t\/\/\t\tintegrated into the Dojo distribution, thereby always providing a\n\t\/\/\t\tdebugging\/logging console when `isDebug` is enabled. Note that\n\t\/\/\t\tFirebug's `console.*` methods are ALWAYS defined by Dojo. If\n\t\/\/\t\t`isDebug` is false and you are on a platform without Firebug, these\n\t\/\/\t\tmethods will be defined as no-ops.\n\tisDebug: false,\n\t\/\/ locale: String\n\t\/\/\t\tThe locale to assume for loading localized resources in this page,\n\t\/\/\t\tspecified according to [RFC 3066](http:\/\/www.ietf.org\/rfc\/rfc3066.txt).\n\t\/\/\t\tMust be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.\n\t\/\/\t\tSee the documentation for `dojo.i18n` and `dojo.requireLocalization`\n\t\/\/\t\tfor details on loading localized resources. If no locale is specified,\n\t\/\/\t\tDojo assumes the locale of the user agent, according to `navigator.userLanguage`\n\t\/\/\t\tor `navigator.language` properties.\n\tlocale: undefined,\n\t\/\/ extraLocale: Array\n\t\/\/\t\tNo default value. Specifies additional locales whose\n\t\/\/\t\tresources should also be loaded alongside the default locale when\n\t\/\/\t\tcalls to `dojo.requireLocalization()` are processed.\n\textraLocale: undefined,\n\t\/\/ baseUrl: String\n\t\/\/\t\tThe directory in which `dojo.js` is located. Under normal\n\t\/\/\t\tconditions, Dojo auto-detects the correct location from which it\n\t\/\/\t\twas loaded. You may need to manually configure `baseUrl` in cases\n\t\/\/\t\twhere you have renamed `dojo.js` or in which `<base>` tags confuse\n\t\/\/\t\tsome browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned\n\t\/\/\t\teither the value of `djConfig.baseUrl` if one is provided or the\n\t\/\/\t\tauto-detected root if not. Other modules are located relative to\n\t\/\/\t\tthis path. The path should end in a slash.\n\tbaseUrl: undefined,\n\t\/\/ modulePaths: Object\n\t\/\/\t\tA map of module names to paths relative to `dojo.baseUrl`. The\n\t\/\/\t\tkey\/value pairs correspond directly to the arguments which\n\t\/\/\t\t`dojo.registerModulePath` accepts. Specifiying\n\t\/\/\t\t`djConfig.modulePaths = { \"foo\": \"..\/..\/bar\" }` is the equivalent\n\t\/\/\t\tof calling `dojo.registerModulePath(\"foo\", \"..\/..\/bar\");`. Multiple\n\t\/\/\t\tmodules may be configured via `djConfig.modulePaths`.\n\tmodulePaths: {},\n\t\/\/ afterOnLoad: Boolean\n\t\/\/\t\tIndicates Dojo was added to the page after the page load. In this case\n\t\/\/\t\tDojo will not wait for the page DOMContentLoad\/load events and fire\n\t\/\/\t\tits dojo.addOnLoad callbacks after making sure all outstanding\n\t\/\/\t\tdojo.required modules have loaded. Only works with a built dojo.js,\n\t\/\/\t\tit does not work the dojo.js directly from source control.\n\tafterOnLoad: false,\n\t\/\/ addOnLoad: Function or Array\n\t\/\/\t\tAdds a callback via dojo.addOnLoad. Useful when Dojo is added after\n\t\/\/\t\tthe page loads and djConfig.afterOnLoad is true. Supports the same\n\t\/\/\t\targuments as dojo.addOnLoad. When using a function reference, use\n\t\/\/\t\t`djConfig.addOnLoad = function(){};`. For object with function name use\n\t\/\/\t\t`djConfig.addOnLoad = [myObject, \"functionName\"];` and for object with\n\t\/\/\t\tfunction reference use\n\t\/\/\t\t`djConfig.addOnLoad = [myObject, function(){}];`\n\taddOnLoad: null,\n\t\/\/ require: Array\n\t\/\/\t\tAn array of module names to be loaded immediately after dojo.js has been included\n\t\/\/\t\tin a page.\n\trequire: [],\n\t\/\/ defaultDuration: Array\n\t\/\/\t\tDefault duration, in milliseconds, for wipe and fade animations within dijits.\n\t\/\/\t\tAssigned to dijit.defaultDuration.\n\tdefaultDuration: 200,\n\t\/\/ dojoBlankHtmlUrl: String\n\t\/\/\t\tUsed by some modules to configure an empty iframe. Used by dojo.io.iframe and\n\t\/\/\t\tdojo.back, and dijit popup support in IE where an iframe is needed to make sure native\n\t\/\/\t\tcontrols do not bleed through the popups. Normally this configuration variable\n\t\/\/\t\tdoes not need to be set, except when using cross-domain\/CDN Dojo builds.\n\t\/\/\t\tSave dojo\/resources\/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`\n\t\/\/\t\tto the path on your domain your copy of blank.html.\n\tdojoBlankHtmlUrl: undefined,\n\t\/\/\tioPublish: Boolean?\n\t\/\/\t\tSet this to true to enable publishing of topics for the different phases of\n\t\/\/\t\tIO operations. Publishing is done via dojo.publish. See dojo.__IoPublish for a list\n\t\/\/\t\tof topics that are published.\n\tioPublish: false,\n\t\/\/\tuseCustomLogger: Anything?\n\t\/\/\t\tIf set to a value that evaluates to true such as a string or array and\n\t\/\/\t\tisDebug is true and Firebug is not available or running, then it bypasses\n\t\/\/\t\tthe creation of Firebug Lite allowing you to define your own console object.\n\tuseCustomLogger: undefined,\n\t\/\/ transparentColor: Array\n\t\/\/\t\tArray containing the r, g, b components used as transparent color in dojo.Color;\n\t\/\/\t\tif undefined, [255,255,255] (white) will be used.\n\ttransparentColor: undefined,\n\t\/\/ skipIeDomLoaded: Boolean\n\t\/\/\t\tFor IE only, skip the DOMContentLoaded hack used. Sometimes it can cause an Operation\n\t\/\/\t\tAborted error if the rest of the page triggers script defers before the DOM is ready.\n\t\/\/\t\tIf this is config value is set to true, then dojo.addOnLoad callbacks will not be\n\t\/\/\t\ttriggered until the page load event, which is after images and iframes load. If you\n\t\/\/\t\twant to trigger the callbacks sooner, you can put a script block in the bottom of\n\t\/\/\t\tyour HTML that calls dojo._loadInit();. If you are using multiversion support, change\n\t\/\/\t\t\"dojo.\" to the appropriate scope name for dojo.\n\tskipIeDomLoaded: false\n}\n=====*\/\n});\n\n","dependencies":["dojo\/has","require"]},"dojo\/fx\/Toggler":{"id":"dojo\/fx\/Toggler","url":"\/home\/arian\/www\/MooTools\/dojo\/fx\/Toggler.js","package":"dojo","amd":true,"content":"define([\"..\/main\"], function(dojo) {\n\t\/\/ module:\n\t\/\/\t\tdojo\/fx\/Toggler\n\t\/\/ summary:\n\t\/\/\t\tTODOC\n\n\ndojo.declare(\"dojo.fx.Toggler\", null, {\n\t\/\/ summary:\n\t\/\/\t\tA simple `dojo.Animation` toggler API.\n\t\/\/\n\t\/\/ description:\n\t\/\/\t\tclass constructor for an animation toggler. It accepts a packed\n\t\/\/\t\tset of arguments about what type of animation to use in each\n\t\/\/\t\tdirection, duration, etc. All available members are mixed into\n\t\/\/\t\tthese animations from the constructor (for example, `node`,\n\t\/\/\t\t`showDuration`, `hideDuration`).\n\t\/\/\n\t\/\/ example:\n\t\/\/\t|\tvar t = new dojo.fx.Toggler({\n\t\/\/\t|\t\tnode: \"nodeId\",\n\t\/\/\t|\t\tshowDuration: 500,\n\t\/\/\t|\t\t\/\/ hideDuration will default to \"200\"\n\t\/\/\t|\t\tshowFunc: dojo.fx.wipeIn,\n\t\/\/\t|\t\t\/\/ hideFunc will default to \"fadeOut\"\n\t\/\/\t|\t});\n\t\/\/\t|\tt.show(100); \/\/ delay showing for 100ms\n\t\/\/\t|\t\/\/ ...time passes...\n\t\/\/\t|\tt.hide();\n\n\t\/\/ node: DomNode\n\t\/\/\t\tthe node to target for the showing and hiding animations\n\tnode: null,\n\n\t\/\/ showFunc: Function\n\t\/\/\t\tThe function that returns the `dojo.Animation` to show the node\n\tshowFunc: dojo.fadeIn,\n\n\t\/\/ hideFunc: Function\n\t\/\/\t\tThe function that returns the `dojo.Animation` to hide the node\n\thideFunc: dojo.fadeOut,\n\n\t\/\/ showDuration:\n\t\/\/\t\tTime in milliseconds to run the show Animation\n\tshowDuration: 200,\n\n\t\/\/ hideDuration:\n\t\/\/\t\tTime in milliseconds to run the hide Animation\n\thideDuration: 200,\n\n\t\/\/ FIXME: need a policy for where the toggler should \"be\" the next\n\t\/\/ time show\/hide are called if we're stopped somewhere in the\n\t\/\/ middle.\n\t\/\/ FIXME: also would be nice to specify individual showArgs\/hideArgs mixed into\n\t\/\/ each animation individually.\n\t\/\/ FIXME: also would be nice to have events from the animations exposed\/bridged\n\n\t\/*=====\n\t_showArgs: null,\n\t_showAnim: null,\n\n\t_hideArgs: null,\n\t_hideAnim: null,\n\n\t_isShowing: false,\n\t_isHiding: false,\n\t=====*\/\n\n\tconstructor: function(args){\n\t\tvar _t = this;\n\n\t\tdojo.mixin(_t, args);\n\t\t_t.node = args.node;\n\t\t_t._showArgs = dojo.mixin({}, args);\n\t\t_t._showArgs.node = _t.node;\n\t\t_t._showArgs.duration = _t.showDuration;\n\t\t_t.showAnim = _t.showFunc(_t._showArgs);\n\n\t\t_t._hideArgs = dojo.mixin({}, args);\n\t\t_t._hideArgs.node = _t.node;\n\t\t_t._hideArgs.duration = _t.hideDuration;\n\t\t_t.hideAnim = _t.hideFunc(_t._hideArgs);\n\n\t\tdojo.connect(_t.showAnim, \"beforeBegin\", dojo.hitch(_t.hideAnim, \"stop\", true));\n\t\tdojo.connect(_t.hideAnim, \"beforeBegin\", dojo.hitch(_t.showAnim, \"stop\", true));\n\t},\n\n\tshow: function(delay){\n\t\t\/\/ summary: Toggle the node to showing\n\t\t\/\/ delay: Integer?\n\t\t\/\/\t\tAmmount of time to stall playing the show animation\n\t\treturn this.showAnim.play(delay || 0);\n\t},\n\n\thide: function(delay){\n\t\t\/\/ summary: Toggle the node to hidden\n\t\t\/\/ delay: Integer?\n\t\t\/\/\t\tAmmount of time to stall playing the hide animation\n\t\treturn this.hideAnim.play(delay || 0);\n\t}\n});\n\nreturn dojo.fx.Toggler;\n});\n","dependencies":["dojo\/main"]},"dojo\/main":{"id":"dojo\/main","url":"\/home\/arian\/www\/MooTools\/dojo\/main.js","package":"dojo","amd":true,"content":"define([\n\t\".\/_base\/kernel\",\n\t\".\/has\",\n\t\"require\",\n\t\".\/_base\/sniff\",\n\t\".\/_base\/lang\",\n\t\".\/_base\/array\",\n\t\".\/_base\/declare\",\n\t\/\/\".\/_base\/connect\", \/\/ until we decide if connect is going back into non-browser environments\n\t\".\/_base\/Deferred\",\n\t\".\/_base\/json\",\n\t\".\/_base\/Color\",\n\t\".\/has!dojo-firebug?.\/_firebug\/firebug\",\n\t\".\/has!host-browser?.\/_base\/browser\",\n\t\".\/has!dojo-sync-loader?.\/_base\/loader\"], function(dojo, has, require){\n\t\/\/ module:\n\t\/\/\t\tdojo\/main\n\t\/\/ summary:\n\t\/\/\t\tThis is the package main module for the dojo package; it loads dojo base appropriate for the execution environment.\n\n\t\/\/ the preferred way to load the dojo firebug console is by setting has(\"dojo-firebug\") true in dojoConfig\n\t\/\/ the isDebug config switch is for backcompat and will work fine in sync loading mode; it works in\n\t\/\/ async mode too, but there's no guarantee when the module is loaded; therefore, if you need a firebug\n\t\/\/ console guarnanteed at a particular spot in an app, either set config.has[\"dojo-firebug\"] true before\n\t\/\/ loading dojo.js or explicitly include dojo\/_firebug\/firebug in a dependency list.\n\tif(dojo.config.isDebug){\n\t\trequire([\".\/_firebug\/firebug\"]);\n\t}\n\n\t\/\/ dojoConfig.require is deprecated; use the loader configuration property deps\n\thas.add(\"dojo-config-require\", 1);\n\tif(has(\"dojo-config-require\")){\n\t\tvar deps= dojo.config.require;\n\t\tif(deps){\n\t\t\t\/\/ dojo.config.require may be dot notation\n\t\t\tdeps= dojo.map(dojo.isArray(deps) ? deps : [deps], function(item){ return item.replace(\/\\.\/g, \"\/\"); });\n\t\t\tif(dojo.isAsync){\n\t\t\t\trequire(deps);\n\t\t\t}else{\n\t\t\t\t\/\/ this is a bit janky; in 1.6- dojo is defined before these requires are applied; but in 1.7+\n\t\t\t\t\/\/ dojo isn't defined until returning from this module; this is only a problem in sync mode\n\t\t\t\t\/\/ since we're in sync mode, we know we've got our loader with its priority ready queue\n\t\t\t\tdojo.ready(1, function(){require(deps);});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dojo;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/has","require","dojo\/_base\/sniff","dojo\/_base\/lang","dojo\/_base\/array","dojo\/_base\/declare","dojo\/_base\/Deferred","dojo\/_base\/json","dojo\/_base\/Color","dojo\/has!dojo-firebug?.\/_firebug\/firebug","dojo\/has!host-browser?.\/_base\/browser","dojo\/has!dojo-sync-loader?.\/_base\/loader","dojo\/_firebug\/firebug"]},"dojo\/_base\/sniff":{"id":"dojo\/_base\/sniff","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/sniff.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \"..\/has\"], function(dojo, has){\n\t\/\/ module:\n\t\/\/\t\tdojo\/sniff\n\t\/\/ summary:\n\t\/\/\t\tThis module populates the dojo browser version sniffing properties.\n\n\tif(!has(\"host-browser\")){\n\t\treturn has;\n\t}\n\n\tdojo.isBrowser = true,\n\tdojo._name = \"browser\";\n\n\tvar hasAdd = has.add,\n\t\tn = navigator,\n\t\tdua = n.userAgent,\n\t\tdav = n.appVersion,\n\t\ttv = parseFloat(dav),\n\t\tisOpera,\n\t\tisAIR,\n\t\tisKhtml,\n\t\tisWebKit,\n\t\tisChrome,\n\t\tisMac,\n\t\tisSafari,\n\t\tisMozilla ,\n\t\tisMoz,\n\t\tisIE,\n\t\tisFF,\n\t\tisQuirks,\n\t\tisIos,\n\t\tisAndroid,\n\t\tisWii;\n\n\t\/*=====\n\tdojo.isBrowser = {\n\t\t\/\/\texample:\n\t\t\/\/\t| if(dojo.isBrowser){ ... }\n\t};\n\n\tdojo.isFF = {\n\t\t\/\/\texample:\n\t\t\/\/\t| if(dojo.isFF > 1){ ... }\n\t};\n\n\tdojo.isIE = {\n\t\t\/\/ example:\n\t\t\/\/\t| if(dojo.isIE > 6){\n\t\t\/\/\t|\t\t\/\/ we are IE7\n\t\t\/\/\t| }\n\t};\n\n\tdojo.isSafari = {\n\t\t\/\/\texample:\n\t\t\/\/\t| if(dojo.isSafari){ ... }\n\t\t\/\/\texample:\n\t\t\/\/\t\tDetect iPhone:\n\t\t\/\/\t| if(dojo.isSafari && navigator.userAgent.indexOf(\"iPhone\") != -1){\n\t\t\/\/\t|\t\t\/\/ we are iPhone. Note, iPod touch reports \"iPod\" above and fails this test.\n\t\t\/\/\t| }\n\t};\n\n\tdojo.mixin(dojo, {\n\t\t\/\/ isBrowser: Boolean\n\t\t\/\/\t\tTrue if the client is a web-browser\n\t\tisBrowser: true,\n\t\t\/\/\tisFF: Number | undefined\n\t\t\/\/\t\tVersion as a Number if client is FireFox. undefined otherwise. Corresponds to\n\t\t\/\/\t\tmajor detected FireFox version (1.5, 2, 3, etc.)\n\t\tisFF: 2,\n\t\t\/\/\tisIE: Number | undefined\n\t\t\/\/\t\tVersion as a Number if client is MSIE(PC). undefined otherwise. Corresponds to\n\t\t\/\/\t\tmajor detected IE version (6, 7, 8, etc.)\n\t\tisIE: 6,\n\t\t\/\/\tisKhtml: Number | undefined\n\t\t\/\/\t\tVersion as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major\n\t\t\/\/\t\tdetected version.\n\t\tisKhtml: 0,\n\t\t\/\/\tisWebKit: Number | undefined\n\t\t\/\/\t\tVersion as a Number if client is a WebKit-derived browser (Konqueror,\n\t\t\/\/\t\tSafari, Chrome, etc.). undefined otherwise.\n\t\tisWebKit: 0,\n\t\t\/\/\tisMozilla: Number | undefined\n\t\t\/\/\t\tVersion as a Number if client is a Mozilla-based browser (Firefox,\n\t\t\/\/\t\tSeaMonkey). undefined otherwise. Corresponds to major detected version.\n\t\tisMozilla: 0,\n\t\t\/\/\tisOpera: Number | undefined\n\t\t\/\/\t\tVersion as a Number if client is Opera. undefined otherwise. Corresponds to\n\t\t\/\/\t\tmajor detected version.\n\t\tisOpera: 0,\n\t\t\/\/\tisSafari: Number | undefined\n\t\t\/\/\t\tVersion as a Number if client is Safari or iPhone. undefined otherwise.\n\t\tisSafari: 0,\n\t\t\/\/\tisChrome: Number | undefined\n\t\t\/\/\t\tVersion as a Number if client is Chrome browser. undefined otherwise.\n\t\tisChrome: 0,\n\t\t\/\/\tisMac: Boolean\n\t\t\/\/\t\tTrue if the client runs on Mac\n\t\tisMac: 0,\n\t\t\/\/ isIos: Boolean\n\t\t\/\/\t\tTrue if client is iPhone, iPod, or iPad\n\t\tisIos: 0,\n\t\t\/\/ isWii: Boolean\n\t\t\/\/\t\tTrue if client is Wii\n\t\tisWii: 0\n\t});\n\t=====*\/\n\n\t\/\/ fill in the rendering support information in dojo.render.*\n\tif(dua.indexOf(\"AdobeAIR\") >= 0){ isAIR = 1; }\n\tisKhtml = (dav.indexOf(\"Konqueror\") >= 0) ? tv : 0;\n\tisWebKit = parseFloat(dua.split(\"WebKit\/\")[1]) || undefined;\n\tisChrome = parseFloat(dua.split(\"Chrome\/\")[1]) || undefined;\n\tisMac = dav.indexOf(\"Macintosh\") >= 0;\n\tisIos = \/iPhone|iPod|iPad\/.test(dua);\n\tisAndroid = \/Android\/.test(dua);\n\tisWii = typeof opera != \"undefined\" && opera.wiiremote;\n\n\t\/\/ safari detection derived from:\n\t\/\/\t\thttp:\/\/developer.apple.com\/internet\/safari\/faq.html#anchor2\n\t\/\/\t\thttp:\/\/developer.apple.com\/internet\/safari\/uamatrix.html\n\tvar index = Math.max(dav.indexOf(\"WebKit\"), dav.indexOf(\"Safari\"), 0);\n\tif(index && !isChrome){\n\t\t\/\/ try to grab the explicit Safari version first. If we don't get\n\t\t\/\/ one, look for less than 419.3 as the indication that we're on something\n\t\t\/\/ \"Safari 2-ish\".\n\t\tisSafari = parseFloat(dav.split(\"Version\/\")[1]);\n\t\tif(!isSafari || parseFloat(dav.substr(index + 7)) <= 419.3){\n\t\t\tisSafari = 2;\n\t\t}\n\t}\n\n\tif (!has(\"dojo-webkit\")) {\n\t\tif(dua.indexOf(\"Opera\") >= 0){\n\t\t\tisOpera = tv;\n\t\t\t\/\/ see http:\/\/dev.opera.com\/articles\/view\/opera-ua-string-changes and http:\/\/www.useragentstring.com\/pages\/Opera\/\n\t\t\t\/\/ 9.8 has both styles; <9.8, 9.9 only old style\n\t\t\tif(isOpera >= 9.8){\n\t\t\t\tisOpera = parseFloat(dua.split(\"Version\/\")[1]) || tv;\n\t\t\t}\n\t\t}\n\n\t\tif(dua.indexOf(\"Gecko\") >= 0 && !isKhtml && !isWebKit){\n\t\t\tisMozilla = isMoz = tv;\n\t\t}\n\t\tif(isMoz){\n\t\t\t\/\/We really need to get away from this. Consider a sane isGecko approach for the future.\n\t\t\tisFF = parseFloat(dua.split(\"Firefox\/\")[1] || dua.split(\"Minefield\/\")[1]) || undefined;\n\t\t}\n\t\tif(document.all && !isOpera){\n\t\t\tisIE = parseFloat(dav.split(\"MSIE \")[1]) || undefined;\n\t\t\t\/\/In cases where the page has an HTTP header or META tag with\n\t\t\t\/\/X-UA-Compatible, then it is in emulation mode.\n\t\t\t\/\/Make sure isIE reflects the desired version.\n\t\t\t\/\/document.documentMode of 5 means quirks mode.\n\t\t\t\/\/Only switch the value if documentMode's major version\n\t\t\t\/\/is different from isIE's major version.\n\t\t\tvar mode = document.documentMode;\n\t\t\tif(mode && mode != 5 && Math.floor(isIE) != mode){\n\t\t\t\tisIE = mode;\n\t\t\t}\n\t\t}\n\t}\n\n\tisQuirks = document.compatMode == \"BackCompat\";\n\n\thasAdd(\"opera\", dojo.isOpera = isOpera);\n\thasAdd(\"air\", dojo.isAIR = isAIR);\n\thasAdd(\"khtml\", dojo.isKhtml = isKhtml);\n\thasAdd(\"webkit\", dojo.isWebKit = isWebKit);\n\thasAdd(\"chrome\", dojo.isChrome = isChrome);\n\thasAdd(\"mac\", dojo.isMac = isMac );\n\thasAdd(\"safari\", dojo.isSafari = isSafari);\n\thasAdd(\"mozilla\", dojo.isMozilla = dojo.isMoz = isMozilla );\n\thasAdd(\"ie\", dojo.isIE = isIE );\n\thasAdd(\"ff\", dojo.isFF = isFF);\n\thasAdd(\"quirks\", dojo.isQuirks = isQuirks);\n\thasAdd(\"ios\", dojo.isIos = isIos);\n\thasAdd(\"android\", dojo.isAndroid = isAndroid);\n\n\tdojo.locale = dojo.locale || (isIE ? n.userLanguage : n.language).toLowerCase();\n\n\treturn has;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/has"]},"dojo\/_base\/lang":{"id":"dojo\/_base\/lang","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/lang.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \"..\/has\", \".\/sniff\"], function(dojo, has, sniff){\n\t\/\/\tmodule:\n\t\/\/\t\tdojo\/_base\/lang\n\t\/\/\tsummary:\n\t\/\/\t\tThis module defines Javascript language extensions.\n\n\thas.add(\"bug-for-in-skips-shadowed\", function(){\n\t\t\/\/ if true, the for-in interator skips object properties that exist in Object's prototype (IE 6 - ?)\n\t\tfor(var i in {toString: 1}){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t});\n\n\tvar _extraNames =\n\t\t\thas(\"bug-for-in-skips-shadowed\") ?\n\t\t\t\t\"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor\".split(\".\") : [],\n\n\t\t_extraLen = _extraNames.length,\n\n\t\t_mixin = function(dest, source, copyFunc){\n\t\t\tvar name, s, i, empty = {};\n\t\t\tfor(name in source){\n\t\t\t\t\/\/ the (!(name in empty) || empty[name] !== s) condition avoids copying properties in \"source\"\n\t\t\t\t\/\/ inherited from Object.prototype.\t For example, if dest has a custom toString() method,\n\t\t\t\t\/\/ don't overwrite it with the toString() method that source inherited from Object.prototype\n\t\t\t\ts = source[name];\n\t\t\t\tif(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n\t\t\t\t\tdest[name] = copyFunc ? copyFunc(s) : s;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(has(\"bug-for-in-skips-shadowed\")){\n\t\t\t\tif(source){\n\t\t\t\t\tfor(i = 0; i < _extraLen; ++i){\n\t\t\t\t\t\tname = _extraNames[i];\n\t\t\t\t\t\ts = source[name];\n\t\t\t\t\t\tif(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n\t\t\t\t\t\t\tdest[name] = copyFunc ? copyFunc(s) : s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dest; \/\/ Object\n\t\t},\n\n\t\tmixin = function(dest, sources){\n\t\t\tif(!dest){ dest = {}; }\n\t\t\tfor(var i = 1, l = arguments.length; i < l; i++){\n\t\t\t\tlang._mixin(dest, arguments[i]);\n\t\t\t}\n\t\t\treturn dest; \/\/ Object\n\t\t},\n\n\t\tgetProp = function(\/*Array*\/parts, \/*Boolean*\/create, \/*Object*\/context){\n\t\t\tvar p, i = 0, dojoGlobal = dojo.global;\n\t\t\tif(!context){\n\t\t\t\tif(!parts.length){\n\t\t\t\t\treturn dojoGlobal;\n\t\t\t\t}else{\n\t\t\t\t\tp = parts[i++];\n\t\t\t\t\ttry{\n\t\t\t\t\t\tcontext = dojo.scopeMap[p] && dojo.scopeMap[p][1];\n\t\t\t\t\t}catch(e){}\n\t\t\t\t\tcontext = context || (p in dojoGlobal ? dojoGlobal[p] : (create ? dojoGlobal[p] = {} : undefined));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(context && (p = parts[i++])){\n\t\t\t\tcontext = (p in context ? context[p] : (create ? context[p] = {} : undefined));\n\t\t\t}\n\t\t\treturn context; \/\/ mixed\n\t\t},\n\n\t\tsetObject = function(name, value, context){\n\t\t\tvar parts = name.split(\".\"), p = parts.pop(), obj = getProp(parts, true, context);\n\t\t\treturn obj && p ? (obj[p] = value) : undefined; \/\/ Object\n\t\t},\n\n\t\tgetObject = function(name, create, context){\n\t\t\treturn getProp(name.split(\".\"), create, context); \/\/ Object\n\t\t},\n\n\t\texists = function(name, obj){\n\t\t\treturn lang.getObject(name, false, obj) !== undefined; \/\/ Boolean\n\t\t},\n\n\t\topts = Object.prototype.toString,\n\n\t\t\/\/ Crockford (ish) functions\n\n\t\tisString = function(it){\n\t\t\treturn (typeof it == \"string\" || it instanceof String); \/\/ Boolean\n\t\t},\n\n\t\tisArray = function(it){\n\t\t\treturn it && (it instanceof Array || typeof it == \"array\"); \/\/ Boolean\n\t\t},\n\n\t\tisFunction = function(it){\n\t\t\treturn opts.call(it) === \"[object Function]\";\n\t\t},\n\n\t\tisObject = function(it){\n\t\t\treturn it !== undefined &&\n\t\t\t\t(it === null || typeof it == \"object\" || lang.isArray(it) || lang.isFunction(it)); \/\/ Boolean\n\t\t},\n\n\t\tisArrayLike = function(it){\n\t\t\treturn it && it !== undefined && \/\/ Boolean\n\t\t\t\t\/\/ keep out built-in constructors (Number, String, ...) which have length\n\t\t\t\t\/\/ properties\n\t\t\t\t!lang.isString(it) && !lang.isFunction(it) &&\n\t\t\t\t!(it.tagName && it.tagName.toLowerCase() == 'form') &&\n\t\t\t\t(lang.isArray(it) || isFinite(it.length));\n\t\t},\n\n\t\tisAlien = function(it){\n\t\t\treturn it && !lang.isFunction(it) && \/\\{\\s*\\[native code\\]\\s*\\}\/.test(String(it)); \/\/ Boolean\n\t\t},\n\n\t\textend = function(constructor, props){\n\t\t\tfor(var i=1, l=arguments.length; i<l; i++){\n\t\t\t\tlang._mixin(constructor.prototype, arguments[i]);\n\t\t\t}\n\t\t\treturn constructor; \/\/ Object\n\t\t},\n\n\t\t_hitchArgs = function(scope, method){\n\t\t\tvar pre = _toArray(arguments, 2);\n\t\t\tvar named = lang.isString(method);\n\t\t\treturn function(){\n\t\t\t\t\/\/ arrayify arguments\n\t\t\t\tvar args = _toArray(arguments);\n\t\t\t\t\/\/ locate our method\n\t\t\t\tvar f = named ? (scope||dojo.global)[method] : method;\n\t\t\t\t\/\/ invoke with collected args\n\t\t\t\treturn f && f.apply(scope || this, pre.concat(args)); \/\/ mixed\n\t\t\t}; \/\/ Function\n\t\t},\n\n\t\thitch = function(scope, method){\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn lang._hitchArgs.apply(dojo, arguments); \/\/ Function\n\t\t\t}\n\t\t\tif(!method){\n\t\t\t\tmethod = scope;\n\t\t\t\tscope = null;\n\t\t\t}\n\t\t\tif(lang.isString(method)){\n\t\t\t\tscope = scope || dojo.global;\n\t\t\t\tif(!scope[method]){ throw(['dojo.hitch: scope[\"', method, '\"] is null (scope=\"', scope, '\")'].join('')); }\n\t\t\t\treturn function(){ return scope[method].apply(scope, arguments || []); }; \/\/ Function\n\t\t\t}\n\t\t\treturn !scope ? method : function(){ return method.apply(scope, arguments || []); }; \/\/ Function\n\t\t},\n\n\t\tdelegate = (function(){\n\t\t\t\/\/ boodman\/crockford delegation w\/ cornford optimization\n\t\t\tfunction TMP(){}\n\t\t\treturn function(obj, props){\n\t\t\t\tTMP.prototype = obj;\n\t\t\t\tvar tmp = new TMP();\n\t\t\t\tTMP.prototype = null;\n\t\t\t\tif(props){\n\t\t\t\t\tlang._mixin(tmp, props);\n\t\t\t\t}\n\t\t\t\treturn tmp; \/\/ Object\n\t\t\t};\n\t\t})(),\n\n\t\tefficient = function(obj, offset, startWith){\n\t\t\treturn (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));\n\t\t},\n\n\t\t_toArray =\n\t\t\thas(\"ie\") ?\n\t\t\t\t(function(){\n\t\t\t\t\tfunction slow(obj, offset, startWith){\n\t\t\t\t\t\tvar arr = startWith||[];\n\t\t\t\t\t\tfor(var x = offset || 0; x < obj.length; x++){\n\t\t\t\t\t\t\tarr.push(obj[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn arr;\n\t\t\t\t\t}\n\t\t\t\t\treturn function(obj){\n\t\t\t\t\t\treturn ((obj.item) ? slow : efficient).apply(this, arguments);\n\t\t\t\t\t};\n\t\t\t\t})() : efficient,\n\n\t\tpartial = function(\/*Function|String*\/method \/*, ...*\/){\n\t\t\tvar arr = [ null ];\n\t\t\treturn lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); \/\/ Function\n\t\t},\n\n\t\tclone = function(\/*anything*\/ src){\n\t\t\tif(!src || typeof src != \"object\" || lang.isFunction(src)){\n\t\t\t\t\/\/ null, undefined, any non-object, or function\n\t\t\t\treturn src;\t\/\/ anything\n\t\t\t}\n\t\t\tif(src.nodeType && \"cloneNode\" in src){\n\t\t\t\t\/\/ DOM Node\n\t\t\t\treturn src.cloneNode(true); \/\/ Node\n\t\t\t}\n\t\t\tif(src instanceof Date){\n\t\t\t\t\/\/ Date\n\t\t\t\treturn new Date(src.getTime());\t\/\/ Date\n\t\t\t}\n\t\t\tif(src instanceof RegExp){\n\t\t\t\t\/\/ RegExp\n\t\t\t\treturn new RegExp(src);   \/\/ RegExp\n\t\t\t}\n\t\t\tvar r, i, l, s, name;\n\t\t\tif(lang.isArray(src)){\n\t\t\t\t\/\/ array\n\t\t\t\tr = [];\n\t\t\t\tfor(i = 0, l = src.length; i < l; ++i){\n\t\t\t\t\tif(i in src){\n\t\t\t\t\t\tr.push(clone(src[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\/\/ we don't clone functions for performance reasons\n\t\/\/\t\t}else if(d.isFunction(src)){\n\t\/\/\t\t\t\/\/ function\n\t\/\/\t\t\tr = function(){ return src.apply(this, arguments); };\n\t\t\t}else{\n\t\t\t\t\/\/ generic objects\n\t\t\t\tr = src.constructor ? new src.constructor() : {};\n\t\t\t}\n\t\t\treturn lang._mixin(r, src, clone);\n\t\t},\n\n\n\t\ttrim = String.prototype.trim ?\n\t\t\tfunction(str){ return str.trim(); } :\n\t\t\tfunction(str){ return str.replace(\/^\\s\\s*\/, '').replace(\/\\s\\s*$\/, ''); },\n\n\n\t\t_pattern = \/\\{([^\\}]+)\\}\/g,\n\n\t\treplace = function(tmpl, map, pattern){\n\t\t\treturn tmpl.replace(pattern || _pattern, lang.isFunction(map) ?\n\t\t\t\tmap : function(_, k){ return getObject(k, false, map); });\n\t\t},\n\n\t\tlang = {\n\t\t\t_extraNames:_extraNames,\n\t\t\t_mixin:_mixin,\n\t\t\tmixin:mixin,\n\t\t\tsetObject:setObject,\n\t\t\tgetObject:getObject,\n\t\t\texists:exists,\n\t\t\tisString:isString,\n\t\t\tisArray:isArray,\n\t\t\tisFunction:isFunction,\n\t\t\tisObject:isObject,\n\t\t\tisArrayLike:isArrayLike,\n\t\t\tisAlien:isAlien,\n\t\t\textend:extend,\n\t\t\t_hitchArgs:_hitchArgs,\n\t\t\thitch:hitch,\n\t\t\tdelegate:delegate,\n\t\t\t_toArray:_toArray,\n\t\t\tpartial:partial,\n\t\t\tclone:clone,\n\t\t\ttrim:trim,\n\t\t\treplace:replace\n\t\t};\n\n\thas(\"dojo-1x-base\") && mixin(dojo, lang);\n\treturn lang;\n\n\t\/*=====\n\tdojo._extraNames\n\t\/\/ summary:\n\t\/\/\t\tArray of strings. Lists property names that must be explicitly processed during for-in interation\n\t\/\/\t\tin environments that have has(\"bug-for-in-skips-shadowed\") true.\n\t=====*\/\n\n\t\/*=====\n\tdojo._mixin = function(dest, source, copyFunc){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tCopies\/adds all properties of source to dest; returns dest.\n\t\t\/\/\tdest: Object:\n\t\t\/\/\t\tThe object to which to copy\/add all properties contained in source.\n\t\t\/\/\tsource: Object:\n\t\t\/\/\t\tThe object from which to draw all properties to copy into dest.\n\t\t\/\/\tcopyFunc: Function?:\n\t\t\/\/\t\tThe process used to copy\/add a property in source; defaults to the Javascript assignment operator.\n\t\t\/\/\treturns:\n\t\t\/\/\t\tdest, as modified\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tAll properties, including functions (sometimes termed \"methods\"), excluding any non-standard extensions\n\t\t\/\/\t\tfound in Object.prototype, are copied\/added to dest. Copying\/adding each particular property is\n\t\t\/\/\t\tdelegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.\n\t\t\/\/\t\tNotice that by default, _mixin executes a so-called \"shallow copy\" and aggregate types are copied\/added by reference.\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.mixin = function(dest, sources){\n\t\/\/\tsummary:\n\t\/\/\t\tCopies\/adds all properties of one or more sources to dest; returns dest.\n\t\/\/\tdest: Object\n\t\/\/\t\tThe object to which to copy\/add all properties contained in source. If dest is falsy, then\n\t\/\/\t\ta new object is manufactured before copying\/adding properties begins.\n\t\/\/\tsources: Object...\n\t\/\/\t\tOne of more objects from which to draw all properties to copy into dest. sources are processed\n\t\/\/\t\tleft-to-right and if more than one of these objects contain the same property name, the right-most\n\t\/\/\t\tvalue \"wins\".\n\t\/\/\treturns: Object\n\t\/\/\t\tdest, as modified\n\t\/\/\tdescription:\n\t\/\/\t\tAll properties, including functions (sometimes termed \"methods\"), excluding any non-standard extensions\n\t\/\/\t\tfound in Object.prototype, are copied\/added from sources to dest. sources are processed left to right.\n\t\/\/\t\tThe Javascript assignment operator is used to copy\/add each property; therefore, by default, mixin\n\t\/\/\t\texecutes a so-called \"shallow copy\" and aggregate types are copied\/added by reference.\n\t\/\/\texample:\n\t\/\/\t\tmake a shallow copy of an object\n\t\/\/\t| var copy = lang.mixin({}, source);\n\t\/\/\texample:\n\t\/\/\t\tmany class constructors often take an object which specifies\n\t\/\/\t\tvalues to be configured on the object. In this case, it is\n\t\/\/\t\toften simplest to call `lang.mixin` on the `this` object:\n\t\/\/\t| dojo.declare(\"acme.Base\", null, {\n\t\/\/\t|\t\tconstructor: function(properties){\n\t\/\/\t|\t\t\t\/\/ property configuration:\n\t\/\/\t|\t\t\tlang.mixin(this, properties);\n\t\/\/\t|\n\t\/\/\t|\t\t\tconsole.log(this.quip);\n\t\/\/\t|\t\t\t\/\/\t...\n\t\/\/\t|\t\t},\n\t\/\/\t|\t\tquip: \"I wasn't born yesterday, you know - I've seen movies.\",\n\t\/\/\t|\t\t\/\/ ...\n\t\/\/\t| });\n\t\/\/\t|\n\t\/\/\t| \/\/ create an instance of the class and configure it\n\t\/\/\t| var b = new acme.Base({quip: \"That's what it does!\" });\n\t\/\/\texample:\n\t\/\/\t\tcopy in properties from multiple objects\n\t\/\/\t| var flattened = lang.mixin(\n\t\/\/\t|\t\t{\n\t\/\/\t|\t\t\tname: \"Frylock\",\n\t\/\/\t|\t\t\tbraces: true\n\t\/\/\t|\t\t},\n\t\/\/\t|\t\t{\n\t\/\/\t|\t\t\tname: \"Carl Brutanananadilewski\"\n\t\/\/\t|\t\t}\n\t\/\/\t| );\n\t\/\/\t|\n\t\/\/\t| \/\/ will print \"Carl Brutanananadilewski\"\n\t\/\/\t| console.log(flattened.name);\n\t\/\/\t| \/\/ will print \"true\"\n\t\/\/\t| console.log(flattened.braces);\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.setObject = function(name, value, context){\n\t\/\/ summary:\n\t\/\/\t\tSet a property from a dot-separated string, such as \"A.B.C\"\n\t\/\/\tdescription:\n\t\/\/\t\tUseful for longer api chains where you have to test each object in\n\t\/\/\t\tthe chain, or when you have an object reference in string format.\n\t\/\/\t\tObjects are created as needed along `path`. Returns the passed\n\t\/\/\t\tvalue if setting is successful or `undefined` if not.\n\t\/\/\tname: String\n\t\/\/\t\tPath to a property, in the form \"A.B.C\".\n\t\/\/\tvalue: anything\n\t\/\/\t\tvalue or object to place at location given by name\n\t\/\/\tcontext: Object?\n\t\/\/\t\tOptional. Object to use as root of path. Defaults to\n\t\/\/\t\t`dojo.global`.\n\t\/\/\texample:\n\t\/\/\t\tset the value of `foo.bar.baz`, regardless of whether\n\t\/\/\t\tintermediate objects already exist:\n\t\/\/\t| lang.setObject(\"foo.bar.baz\", value);\n\t\/\/\texample:\n\t\/\/\t\twithout `lang.setObject`, we often see code like this:\n\t\/\/\t| \/\/ ensure that intermediate objects are available\n\t\/\/\t| if(!obj[\"parent\"]){ obj.parent = {}; }\n\t\/\/\t| if(!obj.parent[\"child\"]){ obj.parent.child = {}; }\n\t\/\/\t| \/\/ now we can safely set the property\n\t\/\/\t| obj.parent.child.prop = \"some value\";\n\t\/\/\t\twhereas with `lang.setObject`, we can shorten that to:\n\t\/\/\t| lang.setObject(\"parent.child.prop\", \"some value\", obj);\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.getObject = function(name, create, context){\n\t\/\/ summary:\n\t\/\/\t\tGet a property from a dot-separated string, such as \"A.B.C\"\n\t\/\/\tdescription:\n\t\/\/\t\tUseful for longer api chains where you have to test each object in\n\t\/\/\t\tthe chain, or when you have an object reference in string format.\n\t\/\/\tname: String\n\t\/\/\t\tPath to an property, in the form \"A.B.C\".\n\t\/\/\tcreate: Boolean?\n\t\/\/\t\tOptional. Defaults to `false`. If `true`, Objects will be\n\t\/\/\t\tcreated at any point along the 'path' that is undefined.\n\t\/\/\tcontext: Object?\n\t\/\/\t\tOptional. Object to use as root of path. Defaults to\n\t\/\/\t\t'dojo.global'. Null may be passed.\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.exists = function(name, obj){\n\t\/\/\tsummary:\n\t\/\/\t\tdetermine if an object supports a given method\n\t\/\/\tdescription:\n\t\/\/\t\tuseful for longer api chains where you have to test each object in\n\t\/\/\t\tthe chain. Useful for object and method detection.\n\t\/\/\tname: String\n\t\/\/\t\tPath to an object, in the form \"A.B.C\".\n\t\/\/\tobj: Object?\n\t\/\/\t\tObject to use as root of path. Defaults to\n\t\/\/\t\t'dojo.global'. Null may be passed.\n\t\/\/\texample:\n\t\/\/\t| \/\/ define an object\n\t\/\/\t| var foo = {\n\t\/\/\t|\t\tbar: { }\n\t\/\/\t| };\n\t\/\/\t|\n\t\/\/\t| \/\/ search the global scope\n\t\/\/\t| lang.exists(\"foo.bar\"); \/\/ true\n\t\/\/\t| lang.exists(\"foo.bar.baz\"); \/\/ false\n\t\/\/\t|\n\t\/\/\t| \/\/ search from a particular scope\n\t\/\/\t| lang.exists(\"bar\", foo); \/\/ true\n\t\/\/\t| lang.exists(\"bar.baz\", foo); \/\/ false\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.isString = function(it){\n\t\/\/\tsummary:\n\t\/\/\t\tReturn true if it is a String\n\t\/\/\tit: anything\n\t\/\/\t\tItem to test.\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.isArray = function(it){\n\t\/\/\tsummary:\n\t\/\/\t\tReturn true if it is an Array.\n\t\/\/\t\tDoes not work on Arrays created in other windows.\n\t\/\/\tit: anything\n\t\/\/\t\tItem to test.\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.isFunction = function(it){\n\t\/\/ summary:\n\t\/\/\t\tReturn true if it is a Function\n\t\/\/\tit: anything\n\t\/\/\t\tItem to test.\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.isStringisObject = function(it){\n\t\/\/ summary:\n\t\/\/\t\tReturns true if it is a JavaScript object (or an Array, a Function\n\t\/\/\t\tor null)\n\t\/\/\tit: anything\n\t\/\/\t\tItem to test.\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.isArrayLike = function(it){\n\t\/\/\tsummary:\n\t\/\/\t\tsimilar to dojo.isArray() but more permissive\n\t\/\/\tit: anything\n\t\/\/\t\tItem to test.\n\t\/\/\treturns:\n\t\/\/\t\tIf it walks like a duck and quacks like a duck, return `true`\n\t\/\/\tdescription:\n\t\/\/\t\tDoesn't strongly test for \"arrayness\".  Instead, settles for \"isn't\n\t\/\/\t\ta string or number and has a length property\". Arguments objects\n\t\/\/\t\tand DOM collections will return true when passed to\n\t\/\/\t\tdojo.isArrayLike(), but will return false when passed to\n\t\/\/\t\tdojo.isArray().\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.isAlien = function(it){\n\t\/\/ summary:\n\t\/\/\t\tReturns true if it is a built-in function or some other kind of\n\t\/\/\t\toddball that *should* report as a function but doesn't\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.extend = function(constructor, props){\n\t\/\/ summary:\n\t\/\/\t\tAdds all properties and methods of props to constructor's\n\t\/\/\t\tprototype, making them available to all instances created with\n\t\/\/\t\tconstructor.\n\t\/\/\tconstructor: Object\n\t\/\/\t\tTarget constructor to extend.\n\t\/\/\tprops: Object...\n\t\/\/\t\tOne or more objects to mix into constructor.prototype\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.hitch = function(scope, method){\n\t\/\/\tsummary:\n\t\/\/\t\tReturns a function that will only ever execute in the a given scope.\n\t\/\/\t\tThis allows for easy use of object member functions\n\t\/\/\t\tin callbacks and other places in which the \"this\" keyword may\n\t\/\/\t\totherwise not reference the expected scope.\n\t\/\/\t\tAny number of default positional arguments may be passed as parameters\n\t\/\/\t\tbeyond \"method\".\n\t\/\/\t\tEach of these values will be used to \"placehold\" (similar to curry)\n\t\/\/\t\tfor the hitched function.\n\t\/\/\tscope: Object\n\t\/\/\t\tThe scope to use when method executes. If method is a string,\n\t\/\/\t\tscope is also the object containing method.\n\t\/\/\tmethod: Function|String...\n\t\/\/\t\tA function to be hitched to scope, or the name of the method in\n\t\/\/\t\tscope to be hitched.\n\t\/\/\texample:\n\t\/\/\t|\tdojo.hitch(foo, \"bar\")();\n\t\/\/\t\truns foo.bar() in the scope of foo\n\t\/\/\texample:\n\t\/\/\t|\tdojo.hitch(foo, myFunction);\n\t\/\/\t\treturns a function that runs myFunction in the scope of foo\n\t\/\/\texample:\n\t\/\/\t\tExpansion on the default positional arguments passed along from\n\t\/\/\t\thitch. Passed args are mixed first, additional args after.\n\t\/\/\t|\tvar foo = { bar: function(a, b, c){ console.log(a, b, c); } };\n\t\/\/\t|\tvar fn = dojo.hitch(foo, \"bar\", 1, 2);\n\t\/\/\t|\tfn(3); \/\/ logs \"1, 2, 3\"\n\t\/\/\texample:\n\t\/\/\t|\tvar foo = { bar: 2 };\n\t\/\/\t|\tdojo.hitch(foo, function(){ this.bar = 10; })();\n\t\/\/\t\texecute an anonymous function in scope of foo\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.delegate = function(obj, props){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tReturns a new object which \"looks\" to obj for properties which it\n\t\t\/\/\t\tdoes not have a value for. Optionally takes a bag of properties to\n\t\t\/\/\t\tseed the returned object with initially.\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tThis is a small implementaton of the Boodman\/Crockford delegation\n\t\t\/\/\t\tpattern in JavaScript. An intermediate object constructor mediates\n\t\t\/\/\t\tthe prototype chain for the returned object, using it to delegate\n\t\t\/\/\t\tdown to obj for property lookup when object-local lookup fails.\n\t\t\/\/\t\tThis can be thought of similarly to ES4's \"wrap\", save that it does\n\t\t\/\/\t\tnot act on types but rather on pure objects.\n\t\t\/\/\tobj: Object\n\t\t\/\/\t\tThe object to delegate to for properties not found directly on the\n\t\t\/\/\t\treturn object or in props.\n\t\t\/\/\tprops: Object...\n\t\t\/\/\t\tan object containing properties to assign to the returned object\n\t\t\/\/\treturns:\n\t\t\/\/\t\tan Object of anonymous type\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar foo = { bar: \"baz\" };\n\t\t\/\/\t|\tvar thinger = dojo.delegate(foo, { thud: \"xyzzy\"});\n\t\t\/\/\t|\tthinger.bar == \"baz\"; \/\/ delegated to foo\n\t\t\/\/\t|\tfoo.thud == undefined; \/\/ by definition\n\t\t\/\/\t|\tthinger.thud == \"xyzzy\"; \/\/ mixed in from props\n\t\t\/\/\t|\tfoo.bar = \"thonk\";\n\t\t\/\/\t|\tthinger.bar == \"thonk\"; \/\/ still delegated to foo's bar\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.partial = function(method){\n\t\/\/\tsummary:\n\t\/\/\t\tsimilar to hitch() except that the scope object is left to be\n\t\/\/\t\twhatever the execution context eventually becomes.\n\t\/\/\tmethod: Function|String\n\t\/\/\tdescription:\n\t\/\/\t\tCalling dojo.partial is the functional equivalent of calling:\n\t\/\/\t\t|\tdojo.hitch(null, funcName, ...);\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.trim = function(str){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tTrims whitespace from both sides of the string\n\t\t\/\/\tstr: String\n\t\t\/\/\t\tString to be trimmed\n\t\t\/\/\treturns: String\n\t\t\/\/\t\tReturns the trimmed string\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tThis version of trim() was selected for inclusion into the base due\n\t\t\/\/\t\tto its compact size and relatively good performance\n\t\t\/\/\t\t(see [Steven Levithan's blog](http:\/\/blog.stevenlevithan.com\/archives\/faster-trim-javascript)\n\t\t\/\/\t\tUses String.prototype.trim instead, if available.\n\t\t\/\/\t\tThe fastest but longest version of this function is located at\n\t\t\/\/\t\tdojo.string.trim()\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.clone = function(src){\n\t\/\/ summary:\n\t\/\/\t\tClones objects (including DOM nodes) and all children.\n\t\/\/\t\tWarning: do not clone cyclic structures.\n\t\/\/\tsrc:\n\t\/\/\t\tThe object to clone\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo._toArray = function(obj, offset, startWith){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tConverts an array-like object (i.e. arguments, DOMCollection) to an\n\t\t\/\/\t\tarray. Returns a new Array with the elements of obj.\n\t\t\/\/\tobj: Object\n\t\t\/\/\t\tthe object to \"arrayify\". We expect the object to have, at a\n\t\t\/\/\t\tminimum, a length property which corresponds to integer-indexed\n\t\t\/\/\t\tproperties.\n\t\t\/\/\toffset: Number?\n\t\t\/\/\t\tthe location in obj to start iterating from. Defaults to 0.\n\t\t\/\/\t\tOptional.\n\t\t\/\/\tstartWith: Array?\n\t\t\/\/\t\tAn array to pack with the properties of obj. If provided,\n\t\t\/\/\t\tproperties in obj are appended at the end of startWith and\n\t\t\/\/\t\tstartWith is the returned array.\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.replace = function(tmpl, map, pattern){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tPerforms parameterized substitutions on a string. Throws an\n\t\t\/\/\t\texception if any parameter is unmatched.\n\t\t\/\/\ttmpl: String\n\t\t\/\/\t\tString to be used as a template.\n\t\t\/\/\tmap: Object|Function\n\t\t\/\/\t\tIf an object, it is used as a dictionary to look up substitutions.\n\t\t\/\/\t\tIf a function, it is called for every substitution with following\n\t\t\/\/\t\tparameters: a whole match, a name, an offset, and the whole template\n\t\t\/\/\t\tstring (see https:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Global_Objects\/String\/replace\n\t\t\/\/\t\tfor more details).\n\t\t\/\/\tpattern: RegEx?\n\t\t\/\/\t\tOptional regular expression objects that overrides the default pattern.\n\t\t\/\/\t\tMust be global and match one item. The default is: \/\\{([^\\}]+)\\}\/g,\n\t\t\/\/\t\twhich matches patterns like that: \"{xxx}\", where \"xxx\" is any sequence\n\t\t\/\/\t\tof characters, which doesn't include \"}\".\n\t\t\/\/\treturns: String\n\t\t\/\/\t\tReturns the substituted string.\n\t\t\/\/\texample:\n\t\t\/\/\t|\t\/\/ uses a dictionary for substitutions:\n\t\t\/\/\t|\tdojo.replace(\"Hello, {name.first} {name.last} AKA {nick}!\",\n\t\t\/\/\t|\t\t{\n\t\t\/\/\t|\t\t\tnick: \"Bob\",\n\t\t\/\/\t|\t\t\tname: {\n\t\t\/\/\t|\t\t\t\tfirst:\t\"Robert\",\n\t\t\/\/\t|\t\t\t\tmiddle: \"X\",\n\t\t\/\/\t|\t\t\t\tlast:\t\t\"Cringely\"\n\t\t\/\/\t|\t\t\t}\n\t\t\/\/\t|\t\t});\n\t\t\/\/\t|\t\/\/ returns: Hello, Robert Cringely AKA Bob!\n\t\t\/\/\texample:\n\t\t\/\/\t|\t\/\/ uses an array for substitutions:\n\t\t\/\/\t|\tdojo.replace(\"Hello, {0} {2}!\",\n\t\t\/\/\t|\t\t[\"Robert\", \"X\", \"Cringely\"]);\n\t\t\/\/\t|\t\/\/ returns: Hello, Robert Cringely!\n\t\t\/\/\texample:\n\t\t\/\/\t|\t\/\/ uses a function for substitutions:\n\t\t\/\/\t|\tfunction sum(a){\n\t\t\/\/\t|\t\tvar t = 0;\n\t\t\/\/\t|\t\tdojo.forEach(a, function(x){ t += x; });\n\t\t\/\/\t|\t\treturn t;\n\t\t\/\/\t|\t}\n\t\t\/\/\t|\tdojo.replace(\n\t\t\/\/\t|\t\t\"{count} payments averaging {avg} USD per payment.\",\n\t\t\/\/\t|\t\tdojo.hitch(\n\t\t\/\/\t|\t\t\t{ payments: [11, 16, 12] },\n\t\t\/\/\t|\t\t\tfunction(_, key){\n\t\t\/\/\t|\t\t\t\tswitch(key){\n\t\t\/\/\t|\t\t\t\t\tcase \"count\": return this.payments.length;\n\t\t\/\/\t|\t\t\t\t\tcase \"min\":\t\treturn Math.min.apply(Math, this.payments);\n\t\t\/\/\t|\t\t\t\t\tcase \"max\":\t\treturn Math.max.apply(Math, this.payments);\n\t\t\/\/\t|\t\t\t\t\tcase \"sum\":\t\treturn sum(this.payments);\n\t\t\/\/\t|\t\t\t\t\tcase \"avg\":\t\treturn sum(this.payments) \/ this.payments.length;\n\t\t\/\/\t|\t\t\t\t}\n\t\t\/\/\t|\t\t\t}\n\t\t\/\/\t|\t\t)\n\t\t\/\/\t|\t);\n\t\t\/\/\t|\t\/\/ prints: 3 payments averaging 13 USD per payment.\n\t\t\/\/\texample:\n\t\t\/\/\t|\t\/\/ uses an alternative PHP-like pattern for substitutions:\n\t\t\/\/\t|\tdojo.replace(\"Hello, ${0} ${2}!\",\n\t\t\/\/\t|\t\t[\"Robert\", \"X\", \"Cringely\"], \/\\$\\{([^\\}]+)\\}\/g);\n\t\t\/\/\t|\t\/\/ returns: Hello, Robert Cringely!\n\t\treturn \"\";\t\/\/ String\n\t}\n\t=====*\/\n});\n\n","dependencies":["dojo\/_base\/kernel","dojo\/has","dojo\/_base\/sniff"]},"dojo\/_base\/array":{"id":"dojo\/_base\/array","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/array.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \".\/lang\", \"..\/array\"], function(dojo, lang, array){\n\t\/\/ module:\n\t\/\/\t\tdojo\/_base\/array\n\t\/\/ summary:\n\t\/\/\t\tThis module defines the Javascript v1.6 array extensions.\n\n\t\/*=====\n\tdojo.indexOf = function(arr, value, fromIndex, findLast){\n\t\t\/\/ summary:\n\t\t\/\/\t\tlocates the first index of the provided value in the\n\t\t\/\/\t\tpassed array. If the value is not found, -1 is returned.\n\t\t\/\/ description:\n\t\t\/\/\t\tThis method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript\n\t\t\/\/\t\t1.6's indexOf skips the holes in the sparse array.\n\t\t\/\/\t\tFor details on this method, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/indexOf\n\t\t\/\/ arr: Array\n\t\t\/\/ value: Object\n\t\t\/\/ fromIndex: Integer?\n\t\t\/\/ findLast: Boolean?\n\t\t\/\/ returns: Number\n\t};\n\tdojo.lastIndexOf = function(arr, value, fromIndex){\n\t\t\/\/ summary:\n\t\t\/\/\t\tlocates the last index of the provided value in the passed\n\t\t\/\/\t\tarray. If the value is not found, -1 is returned.\n\t\t\/\/ description:\n\t\t\/\/\t\tThis method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript\n\t\t\/\/\t\t1.6's lastIndexOf skips the holes in the sparse array.\n\t\t\/\/\t\tFor details on this method, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/lastIndexOf\n\t\t\/\/\tarr: Array,\n\t\t\/\/\tvalue: Object,\n\t\t\/\/\tfromIndex: Integer?\n\t\t\/\/\treturns: Number\n\t};\n\tdojo.forEach = function(arr, callback, thisObject){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tfor every item in arr, callback is invoked. Return values are ignored.\n\t\t\/\/\t\tIf you want to break out of the loop, consider using dojo.every() or dojo.some().\n\t\t\/\/\t\tforEach does not allow breaking out of the loop over the items in arr.\n\t\t\/\/\tarr:\n\t\t\/\/\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t\/\/\tcallback:\n\t\t\/\/\t\ta function is invoked with three arguments: item, index, and array\n\t\t\/\/\tthisObject:\n\t\t\/\/\t\tmay be used to scope the call to callback\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tThis function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, this implemenation passes the \"holes\" in the sparse array to\n\t\t\/\/\t\tthe callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.\n\t\t\/\/\t\tFor more details, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/forEach\n\t\t\/\/\texample:\n\t\t\/\/\t| \/\/ log out all members of the array:\n\t\t\/\/\t| dojo.forEach(\n\t\t\/\/\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\/\/\t|\t\tfunction(item){\n\t\t\/\/\t|\t\t\tconsole.log(item);\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t| );\n\t\t\/\/\texample:\n\t\t\/\/\t| \/\/ log out the members and their indexes\n\t\t\/\/\t| dojo.forEach(\n\t\t\/\/\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\/\/\t|\t\tfunction(item, idx, arr){\n\t\t\/\/\t|\t\t\tconsole.log(item, \"at index:\", idx);\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t| );\n\t\t\/\/\texample:\n\t\t\/\/\t| \/\/ use a scoped object member as the callback\n\t\t\/\/\t|\n\t\t\/\/\t| var obj = {\n\t\t\/\/\t|\t\tprefix: \"logged via obj.callback:\",\n\t\t\/\/\t|\t\tcallback: function(item){\n\t\t\/\/\t|\t\t\tconsole.log(this.prefix, item);\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t| };\n\t\t\/\/\t|\n\t\t\/\/\t| \/\/ specifying the scope function executes the callback in that scope\n\t\t\/\/\t| dojo.forEach(\n\t\t\/\/\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\/\/\t|\t\tobj.callback,\n\t\t\/\/\t|\t\tobj\n\t\t\/\/\t| );\n\t\t\/\/\t|\n\t\t\/\/\t| \/\/ alternately, we can accomplish the same thing with dojo.hitch()\n\t\t\/\/\t| dojo.forEach(\n\t\t\/\/\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\/\/\t|\t\tdojo.hitch(obj, \"callback\")\n\t\t\/\/\t| );\n\t\t\/\/\tarr: Array|String\n\t\t\/\/\tcallback: Function|String\n\t\t\/\/\tthisObject: Object?\n\t};\n\tdojo.every = function(arr, callback, thisObject){\n\t\t\/\/ summary:\n\t\t\/\/\t\tDetermines whether or not every item in arr satisfies the\n\t\t\/\/\t\tcondition implemented by callback.\n\t\t\/\/ arr: Array|String\n\t\t\/\/\t\tthe array to iterate on. If a string, operates on individual characters.\n\t\t\/\/ callback: Function|String\n\t\t\/\/\t\ta function is invoked with three arguments: item, index,\n\t\t\/\/\t\tand array and returns true if the condition is met.\n\t\t\/\/ thisObject: Object?\n\t\t\/\/\t\tmay be used to scope the call to callback\n\t\t\/\/ returns: Boolean\n\t\t\/\/ description:\n\t\t\/\/\t\tThis function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, this implemenation passes the \"holes\" in the sparse array to\n\t\t\/\/\t\tthe callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.\n\t\t\/\/\t\tFor more details, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/every\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ returns false\n\t\t\/\/\t| dojo.every([1, 2, 3, 4], function(item){ return item>1; });\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ returns true\n\t\t\/\/\t| dojo.every([1, 2, 3, 4], function(item){ return item>0; });\n\t};\n\tdojo.some = function(arr, callback, thisObject){\n\t\t\/\/ summary:\n\t\t\/\/\t\tDetermines whether or not any item in arr satisfies the\n\t\t\/\/\t\tcondition implemented by callback.\n\t\t\/\/ arr: Array|String\n\t\t\/\/\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t\/\/ callback: Function|String\n\t\t\/\/\t\ta function is invoked with three arguments: item, index,\n\t\t\/\/\t\tand array and returns true if the condition is met.\n\t\t\/\/ thisObject: Object?\n\t\t\/\/\t\tmay be used to scope the call to callback\n\t\t\/\/ returns: Boolean\n\t\t\/\/ description:\n\t\t\/\/\t\tThis function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, this implemenation passes the \"holes\" in the sparse array to\n\t\t\/\/\t\tthe callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.\n\t\t\/\/\t\tFor more details, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/some\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ is true\n\t\t\/\/\t| dojo.some([1, 2, 3, 4], function(item){ return item>1; });\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ is false\n\t\t\/\/\t| dojo.some([1, 2, 3, 4], function(item){ return item<1; });\n\t};\n\tdojo.map = function(arr, callback, thisObject){\n\t\t\/\/ summary:\n\t\t\/\/\t\tapplies callback to each element of arr and returns\n\t\t\/\/\t\tan Array with the results\n\t\t\/\/ arr: Array|String\n\t\t\/\/\t\tthe array to iterate on. If a string, operates on\n\t\t\/\/\t\tindividual characters.\n\t\t\/\/ callback: Function|String\n\t\t\/\/\t\ta function is invoked with three arguments, (item, index,\n\t\t\/\/\t\tarray),\t and returns a value\n\t\t\/\/ thisObject: Object?\n\t\t\/\/\t\tmay be used to scope the call to callback\n\t\t\/\/ returns: Array\n\t\t\/\/ description:\n\t\t\/\/\t\tThis function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, this implemenation passes the \"holes\" in the sparse array to\n\t\t\/\/\t\tthe callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.\n\t\t\/\/\t\tFor more details, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/map\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ returns [2, 3, 4, 5]\n\t\t\/\/\t| dojo.map([1, 2, 3, 4], function(item){ return item+1 });\n\t};\n\tdojo.filter = function(arr, callback, thisObject){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns a new Array with those items from arr that match the\n\t\t\/\/\t\tcondition implemented by callback.\n\t\t\/\/ arr: Array\n\t\t\/\/\t\tthe array to iterate over.\n\t\t\/\/ callback: Function|String\n\t\t\/\/\t\ta function that is invoked with three arguments (item,\n\t\t\/\/\t\tindex, array). The return of this function is expected to\n\t\t\/\/\t\tbe a boolean which determines whether the passed-in item\n\t\t\/\/\t\twill be included in the returned array.\n\t\t\/\/ thisObject: Object?\n\t\t\/\/\t\tmay be used to scope the call to callback\n\t\t\/\/ returns: Array\n\t\t\/\/ description:\n\t\t\/\/\t\tThis function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\n\t\t\/\/\t\trun over sparse arrays, this implemenation passes the \"holes\" in the sparse array to\n\t\t\/\/\t\tthe callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\n\t\t\/\/\t\tFor more details, see:\n\t\t\/\/\t\t\thttps:\/\/developer.mozilla.org\/en\/Core_JavaScript_1.5_Reference\/Objects\/Array\/filter\n\t\t\/\/ example:\n\t\t\/\/\t| \/\/ returns [2, 3, 4]\n\t\t\/\/\t| dojo.filter([1, 2, 3, 4], function(item){ return item>1; });\n\t};\n\t=====*\/\n\tlang.mixin(dojo, array);\n\n\treturn array;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/_base\/lang","dojo\/array"]},"dojo\/_base\/declare":{"id":"dojo\/_base\/declare","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/declare.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \"..\/has\", \".\/lang\", \".\/array\"], function(dojo, has, lang){\n\t\/\/ module:\n\t\/\/\t\tdojo\/_base\/declare\n\t\/\/ summary:\n\t\/\/\t\tThis module defines dojo.declare.\n\n\tvar mix = lang.mixin, op = Object.prototype, opts = op.toString,\n\t\txtor = new Function, counter = 0, cname = \"constructor\";\n\n\tfunction err(msg, cls){ throw new Error(\"declare\" + (cls ? \" \" + cls : \"\") + \": \" + msg); }\n\n\t\/\/ C3 Method Resolution Order (see http:\/\/www.python.org\/download\/releases\/2.3\/mro\/)\n\tfunction c3mro(bases, className){\n\t\tvar result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,\n\t\t\tl = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;\n\n\t\t\/\/ build a list of bases naming them if needed\n\t\tfor(; i < l; ++i){\n\t\t\tbase = bases[i];\n\t\t\tif(!base){\n\t\t\t\terr(\"mixin #\" + i + \" is unknown. Did you use dojo.require to pull it in?\", className);\n\t\t\t}else if(opts.call(base) != \"[object Function]\"){\n\t\t\t\terr(\"mixin #\" + i + \" is not a callable constructor.\", className);\n\t\t\t}\n\t\t\tlin = base._meta ? base._meta.bases : [base];\n\t\t\ttop = 0;\n\t\t\t\/\/ add bases to the name map\n\t\t\tfor(j = lin.length - 1; j >= 0; --j){\n\t\t\t\tproto = lin[j].prototype;\n\t\t\t\tif(!proto.hasOwnProperty(\"declaredClass\")){\n\t\t\t\t\tproto.declaredClass = \"uniqName_\" + (counter++);\n\t\t\t\t}\n\t\t\t\tname = proto.declaredClass;\n\t\t\t\tif(!nameMap.hasOwnProperty(name)){\n\t\t\t\t\tnameMap[name] = {count: 0, refs: [], cls: lin[j]};\n\t\t\t\t\t++clsCount;\n\t\t\t\t}\n\t\t\t\trec = nameMap[name];\n\t\t\t\tif(top && top !== rec){\n\t\t\t\t\trec.refs.push(top);\n\t\t\t\t\t++top.count;\n\t\t\t\t}\n\t\t\t\ttop = rec;\n\t\t\t}\n\t\t\t++top.count;\n\t\t\troots[0].refs.push(top);\n\t\t}\n\n\t\t\/\/ remove classes without external references recursively\n\t\twhile(roots.length){\n\t\t\ttop = roots.pop();\n\t\t\tresult.push(top.cls);\n\t\t\t--clsCount;\n\t\t\t\/\/ optimization: follow a single-linked chain\n\t\t\twhile(refs = top.refs, refs.length == 1){\n\t\t\t\ttop = refs[0];\n\t\t\t\tif(!top || --top.count){\n\t\t\t\t\t\/\/ branch or end of chain => do not end to roots\n\t\t\t\t\ttop = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tresult.push(top.cls);\n\t\t\t\t--clsCount;\n\t\t\t}\n\t\t\tif(top){\n\t\t\t\t\/\/ branch\n\t\t\t\tfor(i = 0, l = refs.length; i < l; ++i){\n\t\t\t\t\ttop = refs[i];\n\t\t\t\t\tif(!--top.count){\n\t\t\t\t\t\troots.push(top);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(clsCount){\n\t\t\terr(\"can't build consistent linearization\", className);\n\t\t}\n\n\t\t\/\/ calculate the superclass offset\n\t\tbase = bases[0];\n\t\tresult[0] = base ?\n\t\t\tbase._meta && base === result[result.length - base._meta.bases.length] ?\n\t\t\t\tbase._meta.bases.length : 1 : 0;\n\n\t\treturn result;\n\t}\n\n\tfunction inherited(args, a, f){\n\t\tvar name, chains, bases, caller, meta, base, proto, opf, pos,\n\t\t\tcache = this._inherited = this._inherited || {};\n\n\t\t\/\/ crack arguments\n\t\tif(typeof args == \"string\"){\n\t\t\tname = args;\n\t\t\targs = a;\n\t\t\ta = f;\n\t\t}\n\t\tf = 0;\n\n\t\tcaller = args.callee;\n\t\tname = name || caller.nom;\n\t\tif(!name){\n\t\t\terr(\"can't deduce a name to call inherited()\", this.declaredClass);\n\t\t}\n\n\t\tmeta = this.constructor._meta;\n\t\tbases = meta.bases;\n\n\t\tpos = cache.p;\n\t\tif(name != cname){\n\t\t\t\/\/ method\n\t\t\tif(cache.c !== caller){\n\t\t\t\t\/\/ cache bust\n\t\t\t\tpos = 0;\n\t\t\t\tbase = bases[0];\n\t\t\t\tmeta = base._meta;\n\t\t\t\tif(meta.hidden[name] !== caller){\n\t\t\t\t\t\/\/ error detection\n\t\t\t\t\tchains = meta.chains;\n\t\t\t\t\tif(chains && typeof chains[name] == \"string\"){\n\t\t\t\t\t\terr(\"calling chained method with inherited: \" + name, this.declaredClass);\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ find caller\n\t\t\t\t\tdo{\n\t\t\t\t\t\tmeta = base._meta;\n\t\t\t\t\t\tproto = base.prototype;\n\t\t\t\t\t\tif(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}while(base = bases[++pos]); \/\/ intentional assignment\n\t\t\t\t\tpos = base ? pos : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ find next\n\t\t\tbase = bases[++pos];\n\t\t\tif(base){\n\t\t\t\tproto = base.prototype;\n\t\t\t\tif(base._meta && proto.hasOwnProperty(name)){\n\t\t\t\t\tf = proto[name];\n\t\t\t\t}else{\n\t\t\t\t\topf = op[name];\n\t\t\t\t\tdo{\n\t\t\t\t\t\tproto = base.prototype;\n\t\t\t\t\t\tf = proto[name];\n\t\t\t\t\t\tif(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}while(base = bases[++pos]); \/\/ intentional assignment\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = base && f || op[name];\n\t\t}else{\n\t\t\t\/\/ constructor\n\t\t\tif(cache.c !== caller){\n\t\t\t\t\/\/ cache bust\n\t\t\t\tpos = 0;\n\t\t\t\tmeta = bases[0]._meta;\n\t\t\t\tif(meta && meta.ctor !== caller){\n\t\t\t\t\t\/\/ error detection\n\t\t\t\t\tchains = meta.chains;\n\t\t\t\t\tif(!chains || chains.constructor !== \"manual\"){\n\t\t\t\t\t\terr(\"calling chained constructor with inherited\", this.declaredClass);\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ find caller\n\t\t\t\t\twhile(base = bases[++pos]){ \/\/ intentional assignment\n\t\t\t\t\t\tmeta = base._meta;\n\t\t\t\t\t\tif(meta && meta.ctor === caller){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos = base ? pos : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ find next\n\t\t\twhile(base = bases[++pos]){\t\/\/ intentional assignment\n\t\t\t\tmeta = base._meta;\n\t\t\t\tf = meta ? meta.ctor : base;\n\t\t\t\tif(f){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = base && f;\n\t\t}\n\n\t\t\/\/ cache the found super method\n\t\tcache.c = f;\n\t\tcache.p = pos;\n\n\t\t\/\/ now we have the result\n\t\tif(f){\n\t\t\treturn a === true ? f : f.apply(this, a || args);\n\t\t}\n\t\t\/\/ intentionally no return if a super method was not found\n\t}\n\n\tfunction getInherited(name, args){\n\t\tif(typeof name == \"string\"){\n\t\t\treturn this.__inherited(name, args, true);\n\t\t}\n\t\treturn this.__inherited(name, true);\n\t}\n\n\tfunction inherited__debug(args, a1, a2){\n\t\tvar f = this.getInherited(args, a1);\n\t\tif(f){ return f.apply(this, a2 || a1 || args); }\n\t\t\/\/ intentionally no return if a super method was not found\n\t}\n\n\tvar inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;\n\n\t\/\/ emulation of \"instanceof\"\n\tfunction isInstanceOf(cls){\n\t\tvar bases = this.constructor._meta.bases;\n\t\tfor(var i = 0, l = bases.length; i < l; ++i){\n\t\t\tif(bases[i] === cls){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn this instanceof cls;\n\t}\n\n\tfunction mixOwn(target, source){\n\t\t\/\/ add props adding metadata for incoming functions skipping a constructor\n\t\tfor(var name in source){\n\t\t\tif(name != cname && source.hasOwnProperty(name)){\n\t\t\t\ttarget[name] = source[name];\n\t\t\t}\n\t\t}\n\t\tif(has(\"bug-for-in-skips-shadowed\")){\n\t\t\tfor(var extraNames= lang._extraNames, i= extraNames.length; i;){\n\t\t\t\tname = extraNames[--i];\n\t\t\t\tif(name != cname && source.hasOwnProperty(name)){\n\t\t\t\t\t  target[name] = source[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\/\/ implementation of safe mixin function\n\tfunction safeMixin(target, source){\n\t\tvar name, t;\n\t\t\/\/ add props adding metadata for incoming functions skipping a constructor\n\t\tfor(name in source){\n\t\t\tt = source[name];\n\t\t\tif((t !== op[name] || !(name in op)) && name != cname){\n\t\t\t\tif(opts.call(t) == \"[object Function]\"){\n\t\t\t\t\t\/\/ non-trivial function method => attach its name\n\t\t\t\t\tt.nom = name;\n\t\t\t\t}\n\t\t\t\ttarget[name] = t;\n\t\t\t}\n\t\t}\n\t\tif(has(\"bug-for-in-skips-shadowed\")){\n\t\t\tfor(var extraNames= lang._extraNames, i= extraNames.length; i;){\n\t\t\t\tname = extraNames[--i];\n\t\t\t\tt = source[name];\n\t\t\t\tif((t !== op[name] || !(name in op)) && name != cname){\n\t\t\t\t\tif(opts.call(t) == \"[object Function]\"){\n\t\t\t\t\t\t\/\/ non-trivial function method => attach its name\n\t\t\t\t\t\t  t.nom = name;\n\t\t\t\t\t}\n\t\t\t\t\ttarget[name] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}\n\n\tfunction extend(source){\n\t\tsafeMixin(this.prototype, source);\n\t\treturn this;\n\t}\n\n\t\/\/ chained constructor compatible with the legacy dojo.declare()\n\tfunction chainedConstructor(bases, ctorSpecial){\n\t\treturn function(){\n\t\t\tvar a = arguments, args = a, a0 = a[0], f, i, m,\n\t\t\t\tl = bases.length, preArgs;\n\n\t\t\tif(!(this instanceof a.callee)){\n\t\t\t\t\/\/ not called via new, so force it\n\t\t\t\treturn applyNew(a);\n\t\t\t}\n\n\t\t\t\/\/this._inherited = {};\n\t\t\t\/\/ perform the shaman's rituals of the original dojo.declare()\n\t\t\t\/\/ 1) call two types of the preamble\n\t\t\tif(ctorSpecial && (a0 && a0.preamble || this.preamble)){\n\t\t\t\t\/\/ full blown ritual\n\t\t\t\tpreArgs = new Array(bases.length);\n\t\t\t\t\/\/ prepare parameters\n\t\t\t\tpreArgs[0] = a;\n\t\t\t\tfor(i = 0;;){\n\t\t\t\t\t\/\/ process the preamble of the 1st argument\n\t\t\t\t\ta0 = a[0];\n\t\t\t\t\tif(a0){\n\t\t\t\t\t\tf = a0.preamble;\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\ta = f.apply(this, a) || a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ process the preamble of this class\n\t\t\t\t\tf = bases[i].prototype;\n\t\t\t\t\tf = f.hasOwnProperty(\"preamble\") && f.preamble;\n\t\t\t\t\tif(f){\n\t\t\t\t\t\ta = f.apply(this, a) || a;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ one peculiarity of the preamble:\n\t\t\t\t\t\/\/ it is called if it is not needed,\n\t\t\t\t\t\/\/ e.g., there is no constructor to call\n\t\t\t\t\t\/\/ let's watch for the last constructor\n\t\t\t\t\t\/\/ (see ticket #9795)\n\t\t\t\t\tif(++i == l){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpreArgs[i] = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ 2) call all non-trivial constructors using prepared arguments\n\t\t\tfor(i = l - 1; i >= 0; --i){\n\t\t\t\tf = bases[i];\n\t\t\t\tm = f._meta;\n\t\t\t\tf = m ? m.ctor : f;\n\t\t\t\tif(f){\n\t\t\t\t\tf.apply(this, preArgs ? preArgs[i] : a);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ 3) continue the original ritual: call the postscript\n\t\t\tf = this.postscript;\n\t\t\tif(f){\n\t\t\t\tf.apply(this, args);\n\t\t\t}\n\t\t};\n\t}\n\n\n\t\/\/ chained constructor compatible with the legacy dojo.declare()\n\tfunction singleConstructor(ctor, ctorSpecial){\n\t\treturn function(){\n\t\t\tvar a = arguments, t = a, a0 = a[0], f;\n\n\t\t\tif(!(this instanceof a.callee)){\n\t\t\t\t\/\/ not called via new, so force it\n\t\t\t\treturn applyNew(a);\n\t\t\t}\n\n\t\t\t\/\/this._inherited = {};\n\t\t\t\/\/ perform the shaman's rituals of the original dojo.declare()\n\t\t\t\/\/ 1) call two types of the preamble\n\t\t\tif(ctorSpecial){\n\t\t\t\t\/\/ full blown ritual\n\t\t\t\tif(a0){\n\t\t\t\t\t\/\/ process the preamble of the 1st argument\n\t\t\t\t\tf = a0.preamble;\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tt = f.apply(this, t) || t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf = this.preamble;\n\t\t\t\tif(f){\n\t\t\t\t\t\/\/ process the preamble of this class\n\t\t\t\t\tf.apply(this, t);\n\t\t\t\t\t\/\/ one peculiarity of the preamble:\n\t\t\t\t\t\/\/ it is called even if it is not needed,\n\t\t\t\t\t\/\/ e.g., there is no constructor to call\n\t\t\t\t\t\/\/ let's watch for the last constructor\n\t\t\t\t\t\/\/ (see ticket #9795)\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ 2) call a constructor\n\t\t\tif(ctor){\n\t\t\t\tctor.apply(this, a);\n\t\t\t}\n\t\t\t\/\/ 3) continue the original ritual: call the postscript\n\t\t\tf = this.postscript;\n\t\t\tif(f){\n\t\t\t\tf.apply(this, a);\n\t\t\t}\n\t\t};\n\t}\n\n\t\/\/ plain vanilla constructor (can use inherited() to call its base constructor)\n\tfunction simpleConstructor(bases){\n\t\treturn function(){\n\t\t\tvar a = arguments, i = 0, f, m;\n\n\t\t\tif(!(this instanceof a.callee)){\n\t\t\t\t\/\/ not called via new, so force it\n\t\t\t\treturn applyNew(a);\n\t\t\t}\n\n\t\t\t\/\/this._inherited = {};\n\t\t\t\/\/ perform the shaman's rituals of the original dojo.declare()\n\t\t\t\/\/ 1) do not call the preamble\n\t\t\t\/\/ 2) call the top constructor (it can use this.inherited())\n\t\t\tfor(; f = bases[i]; ++i){ \/\/ intentional assignment\n\t\t\t\tm = f._meta;\n\t\t\t\tf = m ? m.ctor : f;\n\t\t\t\tif(f){\n\t\t\t\t\tf.apply(this, a);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ 3) call the postscript\n\t\t\tf = this.postscript;\n\t\t\tif(f){\n\t\t\t\tf.apply(this, a);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction chain(name, bases, reversed){\n\t\treturn function(){\n\t\t\tvar b, m, f, i = 0, step = 1;\n\t\t\tif(reversed){\n\t\t\t\ti = bases.length - 1;\n\t\t\t\tstep = -1;\n\t\t\t}\n\t\t\tfor(; b = bases[i]; i += step){ \/\/ intentional assignment\n\t\t\t\tm = b._meta;\n\t\t\t\tf = (m ? m.hidden : b.prototype)[name];\n\t\t\t\tif(f){\n\t\t\t\t\tf.apply(this, arguments);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t\/\/ forceNew(ctor)\n\t\/\/ return a new object that inherits from ctor.prototype but\n\t\/\/ without actually running ctor on the object.\n\tfunction forceNew(ctor){\n\t\t\/\/ create object with correct prototype using a do-nothing\n\t\t\/\/ constructor\n\t\txtor.prototype = ctor.prototype;\n\t\tvar t = new xtor;\n\t\txtor.prototype = null;\t\/\/ clean up\n\t\treturn t;\n\t}\n\n\t\/\/ applyNew(args)\n\t\/\/ just like 'new ctor()' except that the constructor and its arguments come\n\t\/\/ from args, which must be an array or an arguments object\n\tfunction applyNew(args){\n\t\t\/\/ create an object with ctor's prototype but without\n\t\t\/\/ calling ctor on it.\n\t\tvar ctor = args.callee, t = forceNew(ctor);\n\t\t\/\/ execute the real constructor on the new object\n\t\tctor.apply(t, args);\n\t\treturn t;\n\t}\n\n\tdojo.declare = function(className, superclass, props){\n\t\t\/\/ crack parameters\n\t\tif(typeof className != \"string\"){\n\t\t\tprops = superclass;\n\t\t\tsuperclass = className;\n\t\t\tclassName = \"\";\n\t\t}\n\t\tprops = props || {};\n\n\t\tvar proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;\n\n\t\t\/\/ build a prototype\n\t\tif(opts.call(superclass) == \"[object Array]\"){\n\t\t\t\/\/ C3 MRO\n\t\t\tbases = c3mro(superclass, className);\n\t\t\tt = bases[0];\n\t\t\tmixins = bases.length - t;\n\t\t\tsuperclass = bases[mixins];\n\t\t}else{\n\t\t\tbases = [0];\n\t\t\tif(superclass){\n\t\t\t\tif(opts.call(superclass) == \"[object Function]\"){\n\t\t\t\t\tt = superclass._meta;\n\t\t\t\t\tbases = bases.concat(t ? t.bases : superclass);\n\t\t\t\t}else{\n\t\t\t\t\terr(\"base class is not a callable constructor.\", className);\n\t\t\t\t}\n\t\t\t}else if(superclass !== null){\n\t\t\t\terr(\"unknown base class. Did you use dojo.require to pull it in?\", className);\n\t\t\t}\n\t\t}\n\t\tif(superclass){\n\t\t\tfor(i = mixins - 1;; --i){\n\t\t\t\tproto = forceNew(superclass);\n\t\t\t\tif(!i){\n\t\t\t\t\t\/\/ stop if nothing to add (the last base)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\/\/ mix in properties\n\t\t\t\tt = bases[i];\n\t\t\t\t(t._meta ? mixOwn : mix)(proto, t.prototype);\n\t\t\t\t\/\/ chain in new constructor\n\t\t\t\tctor = new Function;\n\t\t\t\tctor.superclass = superclass;\n\t\t\t\tctor.prototype = proto;\n\t\t\t\tsuperclass = proto.constructor = ctor;\n\t\t\t}\n\t\t}else{\n\t\t\tproto = {};\n\t\t}\n\t\t\/\/ add all properties\n\t\tsafeMixin(proto, props);\n\t\t\/\/ add constructor\n\t\tt = props.constructor;\n\t\tif(t !== op.constructor){\n\t\t\tt.nom = cname;\n\t\t\tproto.constructor = t;\n\t\t}\n\n\t\t\/\/ collect chains and flags\n\t\tfor(i = mixins - 1; i; --i){ \/\/ intentional assignment\n\t\t\tt = bases[i]._meta;\n\t\t\tif(t && t.chains){\n\t\t\t\tchains = mix(chains || {}, t.chains);\n\t\t\t}\n\t\t}\n\t\tif(proto[\"-chains-\"]){\n\t\t\tchains = mix(chains || {}, proto[\"-chains-\"]);\n\t\t}\n\n\t\t\/\/ build ctor\n\t\tt = !chains || !chains.hasOwnProperty(cname);\n\t\tbases[0] = ctor = (chains && chains.constructor === \"manual\") ? simpleConstructor(bases) :\n\t\t\t(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));\n\n\t\t\/\/ add meta information to the constructor\n\t\tctor._meta  = {bases: bases, hidden: props, chains: chains,\n\t\t\tparents: parents, ctor: props.constructor};\n\t\tctor.superclass = superclass && superclass.prototype;\n\t\tctor.extend = extend;\n\t\tctor.prototype = proto;\n\t\tproto.constructor = ctor;\n\n\t\t\/\/ add \"standard\" methods to the prototype\n\t\tproto.getInherited = getInherited;\n\t\tproto.isInstanceOf = isInstanceOf;\n\t\tproto.inherited    = inheritedImpl;\n\t\tproto.__inherited  = inherited;\n\n\t\t\/\/ add name if specified\n\t\tif(className){\n\t\t\tproto.declaredClass = className;\n\t\t\tlang.setObject(className, ctor);\n\t\t}\n\n\t\t\/\/ build chains and add them to the prototype\n\t\tif(chains){\n\t\t\tfor(name in chains){\n\t\t\t\tif(proto[name] && typeof chains[name] == \"string\" && name != cname){\n\t\t\t\t\tt = proto[name] = chain(name, bases, chains[name] === \"after\");\n\t\t\t\t\tt.nom = name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ chained methods do not return values\n\t\t\/\/ no need to chain \"invisible\" functions\n\n\t\treturn ctor;\t\/\/ Function\n\t};\n\n\tdojo.safeMixin = safeMixin;\n\n\t\/*=====\n\tdojo.declare = function(className, superclass, props){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tCreate a feature-rich constructor from compact notation.\n\t\t\/\/\tclassName: String?:\n\t\t\/\/\t\tThe optional name of the constructor (loosely, a \"class\")\n\t\t\/\/\t\tstored in the \"declaredClass\" property in the created prototype.\n\t\t\/\/\t\tIt will be used as a global name for a created constructor.\n\t\t\/\/\tsuperclass: Function|Function[]:\n\t\t\/\/\t\tMay be null, a Function, or an Array of Functions. This argument\n\t\t\/\/\t\tspecifies a list of bases (the left-most one is the most deepest\n\t\t\/\/\t\tbase).\n\t\t\/\/\tprops: Object:\n\t\t\/\/\t\tAn object whose properties are copied to the created prototype.\n\t\t\/\/\t\tAdd an instance-initialization function by making it a property\n\t\t\/\/\t\tnamed \"constructor\".\n\t\t\/\/\treturns:\n\t\t\/\/\t\tNew constructor function.\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tCreate a constructor using a compact notation for inheritance and\n\t\t\/\/\t\tprototype extension.\n\t\t\/\/\n\t\t\/\/\t\tMixin ancestors provide a type of multiple inheritance.\n\t\t\/\/\t\tPrototypes of mixin ancestors are copied to the new class:\n\t\t\/\/\t\tchanges to mixin prototypes will not affect classes to which\n\t\t\/\/\t\tthey have been mixed in.\n\t\t\/\/\n\t\t\/\/\t\tAncestors can be compound classes created by this version of\n\t\t\/\/\t\tdojo.declare. In complex cases all base classes are going to be\n\t\t\/\/\t\tlinearized according to C3 MRO algorithm\n\t\t\/\/\t\t(see http:\/\/www.python.org\/download\/releases\/2.3\/mro\/ for more\n\t\t\/\/\t\tdetails).\n\t\t\/\/\n\t\t\/\/\t\t\"className\" is cached in \"declaredClass\" property of the new class,\n\t\t\/\/\t\tif it was supplied. The immediate super class will be cached in\n\t\t\/\/\t\t\"superclass\" property of the new class.\n\t\t\/\/\n\t\t\/\/\t\tMethods in \"props\" will be copied and modified: \"nom\" property\n\t\t\/\/\t\t(the declared name of the method) will be added to all copied\n\t\t\/\/\t\tfunctions to help identify them for the internal machinery. Be\n\t\t\/\/\t\tvery careful, while reusing methods: if you use the same\n\t\t\/\/\t\tfunction under different names, it can produce errors in some\n\t\t\/\/\t\tcases.\n\t\t\/\/\n\t\t\/\/\t\tIt is possible to use constructors created \"manually\" (without\n\t\t\/\/\t\tdojo.declare) as bases. They will be called as usual during the\n\t\t\/\/\t\tcreation of an instance, their methods will be chained, and even\n\t\t\/\/\t\tcalled by \"this.inherited()\".\n\t\t\/\/\n\t\t\/\/\t\tSpecial property \"-chains-\" governs how to chain methods. It is\n\t\t\/\/\t\ta dictionary, which uses method names as keys, and hint strings\n\t\t\/\/\t\tas values. If a hint string is \"after\", this method will be\n\t\t\/\/\t\tcalled after methods of its base classes. If a hint string is\n\t\t\/\/\t\t\"before\", this method will be called before methods of its base\n\t\t\/\/\t\tclasses.\n\t\t\/\/\n\t\t\/\/\t\tIf \"constructor\" is not mentioned in \"-chains-\" property, it will\n\t\t\/\/\t\tbe chained using the legacy mode: using \"after\" chaining,\n\t\t\/\/\t\tcalling preamble() method before each constructor, if available,\n\t\t\/\/\t\tand calling postscript() after all constructors were executed.\n\t\t\/\/\t\tIf the hint is \"after\", it is chained as a regular method, but\n\t\t\/\/\t\tpostscript() will be called after the chain of constructors.\n\t\t\/\/\t\t\"constructor\" cannot be chained \"before\", but it allows\n\t\t\/\/\t\ta special hint string: \"manual\", which means that constructors\n\t\t\/\/\t\tare not going to be chained in any way, and programmer will call\n\t\t\/\/\t\tthem manually using this.inherited(). In the latter case\n\t\t\/\/\t\tpostscript() will be called after the construction.\n\t\t\/\/\n\t\t\/\/\t\tAll chaining hints are \"inherited\" from base classes and\n\t\t\/\/\t\tpotentially can be overridden. Be very careful when overriding\n\t\t\/\/\t\thints! Make sure that all chained methods can work in a proposed\n\t\t\/\/\t\tmanner of chaining.\n\t\t\/\/\n\t\t\/\/\t\tOnce a method was chained, it is impossible to unchain it. The\n\t\t\/\/\t\tonly exception is \"constructor\". You don't need to define a\n\t\t\/\/\t\tmethod in order to supply a chaining hint.\n\t\t\/\/\n\t\t\/\/\t\tIf a method is chained, it cannot use this.inherited() because\n\t\t\/\/\t\tall other methods in the hierarchy will be called automatically.\n\t\t\/\/\n\t\t\/\/\t\tUsually constructors and initializers of any kind are chained\n\t\t\/\/\t\tusing \"after\" and destructors of any kind are chained as\n\t\t\/\/\t\t\"before\". Note that chaining assumes that chained methods do not\n\t\t\/\/\t\treturn any value: any returned value will be discarded.\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tdojo.declare(\"my.classes.bar\", my.classes.foo, {\n\t\t\/\/\t|\t\t\/\/ properties to be added to the class prototype\n\t\t\/\/\t|\t\tsomeValue: 2,\n\t\t\/\/\t|\t\t\/\/ initialization function\n\t\t\/\/\t|\t\tconstructor: function(){\n\t\t\/\/\t|\t\t\tthis.myComplicatedObject = new ReallyComplicatedObject();\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\t\/\/ other functions\n\t\t\/\/\t|\t\tsomeMethod: function(){\n\t\t\/\/\t|\t\t\tdoStuff();\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar MyBase = dojo.declare(null, {\n\t\t\/\/\t|\t\t\/\/ constructor, properties, and methods go here\n\t\t\/\/\t|\t\t\/\/ ...\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar MyClass1 = dojo.declare(MyBase, {\n\t\t\/\/\t|\t\t\/\/ constructor, properties, and methods go here\n\t\t\/\/\t|\t\t\/\/ ...\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar MyClass2 = dojo.declare(MyBase, {\n\t\t\/\/\t|\t\t\/\/ constructor, properties, and methods go here\n\t\t\/\/\t|\t\t\/\/ ...\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar MyDiamond = dojo.declare([MyClass1, MyClass2], {\n\t\t\/\/\t|\t\t\/\/ constructor, properties, and methods go here\n\t\t\/\/\t|\t\t\/\/ ...\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar F = function(){ console.log(\"raw constructor\"); };\n\t\t\/\/\t|\tF.prototype.method = function(){\n\t\t\/\/\t|\t\tconsole.log(\"raw method\");\n\t\t\/\/\t|\t};\n\t\t\/\/\t|\tvar A = dojo.declare(F, {\n\t\t\/\/\t|\t\tconstructor: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"A.constructor\");\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\tmethod: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"before calling F.method...\");\n\t\t\/\/\t|\t\t\tthis.inherited(arguments);\n\t\t\/\/\t|\t\t\tconsole.log(\"...back in A\");\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tnew A().method();\n\t\t\/\/\t|\t\/\/ will print:\n\t\t\/\/\t|\t\/\/ raw constructor\n\t\t\/\/\t|\t\/\/ A.constructor\n\t\t\/\/\t|\t\/\/ before calling F.method...\n\t\t\/\/\t|\t\/\/ raw method\n\t\t\/\/\t|\t\/\/ ...back in A\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar A = dojo.declare(null, {\n\t\t\/\/\t|\t\t\"-chains-\": {\n\t\t\/\/\t|\t\t\tdestroy: \"before\"\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar B = dojo.declare(A, {\n\t\t\/\/\t|\t\tconstructor: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"B.constructor\");\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\tdestroy: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"B.destroy\");\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar C = dojo.declare(B, {\n\t\t\/\/\t|\t\tconstructor: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"C.constructor\");\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\tdestroy: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"C.destroy\");\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tnew C().destroy();\n\t\t\/\/\t|\t\/\/ prints:\n\t\t\/\/\t|\t\/\/ B.constructor\n\t\t\/\/\t|\t\/\/ C.constructor\n\t\t\/\/\t|\t\/\/ C.destroy\n\t\t\/\/\t|\t\/\/ B.destroy\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar A = dojo.declare(null, {\n\t\t\/\/\t|\t\t\"-chains-\": {\n\t\t\/\/\t|\t\t\tconstructor: \"manual\"\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar B = dojo.declare(A, {\n\t\t\/\/\t|\t\tconstructor: function(){\n\t\t\/\/\t|\t\t\t\/\/ ...\n\t\t\/\/\t|\t\t\t\/\/ call the base constructor with new parameters\n\t\t\/\/\t|\t\t\tthis.inherited(arguments, [1, 2, 3]);\n\t\t\/\/\t|\t\t\t\/\/ ...\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar A = dojo.declare(null, {\n\t\t\/\/\t|\t\t\"-chains-\": {\n\t\t\/\/\t|\t\t\tm1: \"before\"\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\tm1: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"A.m1\");\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\tm2: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"A.m2\");\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar B = dojo.declare(A, {\n\t\t\/\/\t|\t\t\"-chains-\": {\n\t\t\/\/\t|\t\t\tm2: \"after\"\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\tm1: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"B.m1\");\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\tm2: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"B.m2\");\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar x = new B();\n\t\t\/\/\t|\tx.m1();\n\t\t\/\/\t|\t\/\/ prints:\n\t\t\/\/\t|\t\/\/ B.m1\n\t\t\/\/\t|\t\/\/ A.m1\n\t\t\/\/\t|\tx.m2();\n\t\t\/\/\t|\t\/\/ prints:\n\t\t\/\/\t|\t\/\/ A.m2\n\t\t\/\/\t|\t\/\/ B.m2\n\t\treturn new Function(); \/\/ Function\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.safeMixin = function(target, source){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tMix in properties skipping a constructor and decorating functions\n\t\t\/\/\t\tlike it is done by dojo.declare.\n\t\t\/\/\ttarget: Object\n\t\t\/\/\t\tTarget object to accept new properties.\n\t\t\/\/\tsource: Object\n\t\t\/\/\t\tSource object for new properties.\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tThis function is used to mix in properties like lang.mixin does,\n\t\t\/\/\t\tbut it skips a constructor property and decorates functions like\n\t\t\/\/\t\tdojo.declare does.\n\t\t\/\/\n\t\t\/\/\t\tIt is meant to be used with classes and objects produced with\n\t\t\/\/\t\tdojo.declare. Functions mixed in with dojo.safeMixin can use\n\t\t\/\/\t\tthis.inherited() like normal methods.\n\t\t\/\/\n\t\t\/\/\t\tThis function is used to implement extend() method of a constructor\n\t\t\/\/\t\tproduced with dojo.declare().\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar A = dojo.declare(null, {\n\t\t\/\/\t|\t\tm1: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"A.m1\");\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\tm2: function(){\n\t\t\/\/\t|\t\t\tconsole.log(\"A.m2\");\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar B = dojo.declare(A, {\n\t\t\/\/\t|\t\tm1: function(){\n\t\t\/\/\t|\t\t\tthis.inherited(arguments);\n\t\t\/\/\t|\t\t\tconsole.log(\"B.m1\");\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tB.extend({\n\t\t\/\/\t|\t\tm2: function(){\n\t\t\/\/\t|\t\t\tthis.inherited(arguments);\n\t\t\/\/\t|\t\t\tconsole.log(\"B.m2\");\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar x = new B();\n\t\t\/\/\t|\tdojo.safeMixin(x, {\n\t\t\/\/\t|\t\tm1: function(){\n\t\t\/\/\t|\t\t\tthis.inherited(arguments);\n\t\t\/\/\t|\t\t\tconsole.log(\"X.m1\");\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\tm2: function(){\n\t\t\/\/\t|\t\t\tthis.inherited(arguments);\n\t\t\/\/\t|\t\t\tconsole.log(\"X.m2\");\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tx.m2();\n\t\t\/\/\t|\t\/\/ prints:\n\t\t\/\/\t|\t\/\/ A.m1\n\t\t\/\/\t|\t\/\/ B.m1\n\t\t\/\/\t|\t\/\/ X.m1\n\t};\n\t=====*\/\n\n\t\/*=====\n\tObject.inherited = function(name, args, newArgs){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tCalls a super method.\n\t\t\/\/\tname: String?\n\t\t\/\/\t\tThe optional method name. Should be the same as the caller's\n\t\t\/\/\t\tname. Usually \"name\" is specified in complex dynamic cases, when\n\t\t\/\/\t\tthe calling method was dynamically added, undecorated by\n\t\t\/\/\t\tdojo.declare, and it cannot be determined.\n\t\t\/\/\targs: Arguments\n\t\t\/\/\t\tThe caller supply this argument, which should be the original\n\t\t\/\/\t\t\"arguments\".\n\t\t\/\/\tnewArgs: Object?\n\t\t\/\/\t\tIf \"true\", the found function will be returned without\n\t\t\/\/\t\texecuting it.\n\t\t\/\/\t\tIf Array, it will be used to call a super method. Otherwise\n\t\t\/\/\t\t\"args\" will be used.\n\t\t\/\/\treturns:\n\t\t\/\/\t\tWhatever is returned by a super method, or a super method itself,\n\t\t\/\/\t\tif \"true\" was specified as newArgs.\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tThis method is used inside method of classes produced with\n\t\t\/\/\t\tdojo.declare to call a super method (next in the chain). It is\n\t\t\/\/\t\tused for manually controlled chaining. Consider using the regular\n\t\t\/\/\t\tchaining, because it is faster. Use \"this.inherited()\" only in\n\t\t\/\/\t\tcomplex cases.\n\t\t\/\/\n\t\t\/\/\t\tThis method cannot me called from automatically chained\n\t\t\/\/\t\tconstructors including the case of a special (legacy)\n\t\t\/\/\t\tconstructor chaining. It cannot be called from chained methods.\n\t\t\/\/\n\t\t\/\/\t\tIf \"this.inherited()\" cannot find the next-in-chain method, it\n\t\t\/\/\t\tdoes nothing and returns \"undefined\". The last method in chain\n\t\t\/\/\t\tcan be a default method implemented in Object, which will be\n\t\t\/\/\t\tcalled last.\n\t\t\/\/\n\t\t\/\/\t\tIf \"name\" is specified, it is assumed that the method that\n\t\t\/\/\t\treceived \"args\" is the parent method for this call. It is looked\n\t\t\/\/\t\tup in the chain list and if it is found the next-in-chain method\n\t\t\/\/\t\tis called. If it is not found, the first-in-chain method is\n\t\t\/\/\t\tcalled.\n\t\t\/\/\n\t\t\/\/\t\tIf \"name\" is not specified, it will be derived from the calling\n\t\t\/\/\t\tmethod (using a methoid property \"nom\").\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar B = dojo.declare(A, {\n\t\t\/\/\t|\t\tmethod1: function(a, b, c){\n\t\t\/\/\t|\t\t\tthis.inherited(arguments);\n\t\t\/\/\t|\t\t},\n\t\t\/\/\t|\t\tmethod2: function(a, b){\n\t\t\/\/\t|\t\t\treturn this.inherited(arguments, [a + b]);\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\t\/\/ next method is not in the chain list because it is added\n\t\t\/\/\t|\t\/\/ manually after the class was created.\n\t\t\/\/\t|\tB.prototype.method3 = function(){\n\t\t\/\/\t|\t\tconsole.log(\"This is a dynamically-added method.\");\n\t\t\/\/\t|\t\tthis.inherited(\"method3\", arguments);\n\t\t\/\/\t|\t};\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar B = dojo.declare(A, {\n\t\t\/\/\t|\t\tmethod: function(a, b){\n\t\t\/\/\t|\t\t\tvar super = this.inherited(arguments, true);\n\t\t\/\/\t|\t\t\t\/\/ ...\n\t\t\/\/\t|\t\t\tif(!super){\n\t\t\/\/\t|\t\t\t\tconsole.log(\"there is no super method\");\n\t\t\/\/\t|\t\t\t\treturn 0;\n\t\t\/\/\t|\t\t\t}\n\t\t\/\/\t|\t\t\treturn super.apply(this, arguments);\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\treturn\t{};\t\/\/ Object\n\t}\n\t=====*\/\n\n\t\/*=====\n\tObject.getInherited = function(name, args){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tReturns a super method.\n\t\t\/\/\tname: String?\n\t\t\/\/\t\tThe optional method name. Should be the same as the caller's\n\t\t\/\/\t\tname. Usually \"name\" is specified in complex dynamic cases, when\n\t\t\/\/\t\tthe calling method was dynamically added, undecorated by\n\t\t\/\/\t\tdojo.declare, and it cannot be determined.\n\t\t\/\/\targs: Arguments\n\t\t\/\/\t\tThe caller supply this argument, which should be the original\n\t\t\/\/\t\t\"arguments\".\n\t\t\/\/\treturns:\n\t\t\/\/\t\tReturns a super method (Function) or \"undefined\".\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tThis method is a convenience method for \"this.inherited()\".\n\t\t\/\/\t\tIt uses the same algorithm but instead of executing a super\n\t\t\/\/\t\tmethod, it returns it, or \"undefined\" if not found.\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar B = dojo.declare(A, {\n\t\t\/\/\t|\t\tmethod: function(a, b){\n\t\t\/\/\t|\t\t\tvar super = this.getInherited(arguments);\n\t\t\/\/\t|\t\t\t\/\/ ...\n\t\t\/\/\t|\t\t\tif(!super){\n\t\t\/\/\t|\t\t\t\tconsole.log(\"there is no super method\");\n\t\t\/\/\t|\t\t\t\treturn 0;\n\t\t\/\/\t|\t\t\t}\n\t\t\/\/\t|\t\t\treturn super.apply(this, arguments);\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\treturn\t{};\t\/\/ Object\n\t}\n\t=====*\/\n\n\t\/*=====\n\tObject.isInstanceOf = function(cls){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tChecks the inheritance chain to see if it is inherited from this\n\t\t\/\/\t\tclass.\n\t\t\/\/\tcls: Function\n\t\t\/\/\t\tClass constructor.\n\t\t\/\/\treturns:\n\t\t\/\/\t\t\"true\", if this object is inherited from this class, \"false\"\n\t\t\/\/\t\totherwise.\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tThis method is used with instances of classes produced with\n\t\t\/\/\t\tdojo.declare to determine of they support a certain interface or\n\t\t\/\/\t\tnot. It models \"instanceof\" operator.\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar A = dojo.declare(null, {\n\t\t\/\/\t|\t\t\/\/ constructor, properties, and methods go here\n\t\t\/\/\t|\t\t\/\/ ...\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar B = dojo.declare(null, {\n\t\t\/\/\t|\t\t\/\/ constructor, properties, and methods go here\n\t\t\/\/\t|\t\t\/\/ ...\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar C = dojo.declare([A, B], {\n\t\t\/\/\t|\t\t\/\/ constructor, properties, and methods go here\n\t\t\/\/\t|\t\t\/\/ ...\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tvar D = dojo.declare(A, {\n\t\t\/\/\t|\t\t\/\/ constructor, properties, and methods go here\n\t\t\/\/\t|\t\t\/\/ ...\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\n\t\t\/\/\t|\tvar a = new A(), b = new B(), c = new C(), d = new D();\n\t\t\/\/\t|\n\t\t\/\/\t|\tconsole.log(a.isInstanceOf(A)); \/\/ true\n\t\t\/\/\t|\tconsole.log(b.isInstanceOf(A)); \/\/ false\n\t\t\/\/\t|\tconsole.log(c.isInstanceOf(A)); \/\/ true\n\t\t\/\/\t|\tconsole.log(d.isInstanceOf(A)); \/\/ true\n\t\t\/\/\t|\n\t\t\/\/\t|\tconsole.log(a.isInstanceOf(B)); \/\/ false\n\t\t\/\/\t|\tconsole.log(b.isInstanceOf(B)); \/\/ true\n\t\t\/\/\t|\tconsole.log(c.isInstanceOf(B)); \/\/ true\n\t\t\/\/\t|\tconsole.log(d.isInstanceOf(B)); \/\/ false\n\t\t\/\/\t|\n\t\t\/\/\t|\tconsole.log(a.isInstanceOf(C)); \/\/ false\n\t\t\/\/\t|\tconsole.log(b.isInstanceOf(C)); \/\/ false\n\t\t\/\/\t|\tconsole.log(c.isInstanceOf(C)); \/\/ true\n\t\t\/\/\t|\tconsole.log(d.isInstanceOf(C)); \/\/ false\n\t\t\/\/\t|\n\t\t\/\/\t|\tconsole.log(a.isInstanceOf(D)); \/\/ false\n\t\t\/\/\t|\tconsole.log(b.isInstanceOf(D)); \/\/ false\n\t\t\/\/\t|\tconsole.log(c.isInstanceOf(D)); \/\/ false\n\t\t\/\/\t|\tconsole.log(d.isInstanceOf(D)); \/\/ true\n\t\treturn\t{};\t\/\/ Object\n\t}\n\t=====*\/\n\n\t\/*=====\n\tObject.extend = function(source){\n\t\t\/\/\tsummary:\n\t\t\/\/\t\tAdds all properties and methods of source to constructor's\n\t\t\/\/\t\tprototype, making them available to all instances created with\n\t\t\/\/\t\tconstructor. This method is specific to constructors created with\n\t\t\/\/\t\tdojo.declare.\n\t\t\/\/\tsource: Object\n\t\t\/\/\t\tSource object which properties are going to be copied to the\n\t\t\/\/\t\tconstructor's prototype.\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tAdds source properties to the constructor's prototype. It can\n\t\t\/\/\t\toverride existing properties.\n\t\t\/\/\n\t\t\/\/\t\tThis method is similar to dojo.extend function, but it is specific\n\t\t\/\/\t\tto constructors produced by dojo.declare. It is implemented\n\t\t\/\/\t\tusing dojo.safeMixin, and it skips a constructor property,\n\t\t\/\/\t\tand properly decorates copied functions.\n\t\t\/\/\n\t\t\/\/\texample:\n\t\t\/\/\t|\tvar A = dojo.declare(null, {\n\t\t\/\/\t|\t\tm1: function(){},\n\t\t\/\/\t|\t\ts1: \"Popokatepetl\"\n\t\t\/\/\t|\t});\n\t\t\/\/\t|\tA.extend({\n\t\t\/\/\t|\t\tm1: function(){},\n\t\t\/\/\t|\t\tm2: function(){},\n\t\t\/\/\t|\t\tf1: true,\n\t\t\/\/\t|\t\td1: 42\n\t\t\/\/\t|\t});\n\t};\n\t=====*\/\n\n\treturn dojo.declare;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/has","dojo\/_base\/lang","dojo\/_base\/array"]},"dojo\/_base\/Deferred":{"id":"dojo\/_base\/Deferred","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/Deferred.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \".\/lang\"], function(dojo, lang){\n\t\/\/ module:\n\t\/\/\t\tdojo\/_base\/Deferred\n\t\/\/ summary:\n\t\/\/\t\tThis module defines dojo.Deferred.\n\n\tvar mutator = function(){};\n\tvar freeze = Object.freeze || function(){};\n\t\/\/ A deferred provides an API for creating and resolving a promise.\n\tdojo.Deferred = function(\/*Function?*\/canceller){\n\t\t\/\/ summary:\n\t\t\/\/\t\tDeferreds provide a generic means for encapsulating an asynchronous\n\t\t\/\/\t\toperation and notifying users of the completion and result of the operation.\n\t\t\/\/ description:\n\t\t\/\/\t\tThe dojo.Deferred API is based on the concept of promises that provide a\n\t\t\/\/\t\tgeneric interface into the eventual completion of an asynchronous action.\n\t\t\/\/\t\tThe motivation for promises fundamentally is about creating a\n\t\t\/\/\t\tseparation of concerns that allows one to achieve the same type of\n\t\t\/\/\t\tcall patterns and logical data flow in asynchronous code as can be\n\t\t\/\/\t\tachieved in synchronous code. Promises allows one\n\t\t\/\/\t\tto be able to call a function purely with arguments needed for\n\t\t\/\/\t\texecution, without conflating the call with concerns of whether it is\n\t\t\/\/\t\tsync or async. One shouldn't need to alter a call's arguments if the\n\t\t\/\/\t\timplementation switches from sync to async (or vice versa). By having\n\t\t\/\/\t\tasync functions return promises, the concerns of making the call are\n\t\t\/\/\t\tseparated from the concerns of asynchronous interaction (which are\n\t\t\/\/\t\thandled by the promise).\n\t\t\/\/\n\t\t\/\/\t\tThe dojo.Deferred is a type of promise that provides methods for fulfilling the\n\t\t\/\/\t\tpromise with a successful result or an error. The most important method for\n\t\t\/\/\t\tworking with Dojo's promises is the then() method, which follows the\n\t\t\/\/\t\tCommonJS proposed promise API. An example of using a Dojo promise:\n\t\t\/\/\n\t\t\/\/\t\t|\tvar resultingPromise = someAsyncOperation.then(function(result){\n\t\t\/\/\t\t|\t\t... handle result ...\n\t\t\/\/\t\t|\t},\n\t\t\/\/\t\t|\tfunction(error){\n\t\t\/\/\t\t|\t\t... handle error ...\n\t\t\/\/\t\t|\t});\n\t\t\/\/\n\t\t\/\/\t\tThe .then() call returns a new promise that represents the result of the\n\t\t\/\/\t\texecution of the callback. The callbacks will never affect the original promises value.\n\t\t\/\/\n\t\t\/\/\t\tThe dojo.Deferred instances also provide the following functions for backwards compatibility:\n\t\t\/\/\n\t\t\/\/\t\t\t* addCallback(handler)\n\t\t\/\/\t\t\t* addErrback(handler)\n\t\t\/\/\t\t\t* callback(result)\n\t\t\/\/\t\t\t* errback(result)\n\t\t\/\/\n\t\t\/\/\t\tCallbacks are allowed to return promises themselves, so\n\t\t\/\/\t\tyou can build complicated sequences of events with ease.\n\t\t\/\/\n\t\t\/\/\t\tThe creator of the Deferred may specify a canceller.  The canceller\n\t\t\/\/\t\tis a function that will be called if Deferred.cancel is called\n\t\t\/\/\t\tbefore the Deferred fires. You can use this to implement clean\n\t\t\/\/\t\taborting of an XMLHttpRequest, etc. Note that cancel will fire the\n\t\t\/\/\t\tdeferred with a CancelledError (unless your canceller returns\n\t\t\/\/\t\tanother kind of error), so the errbacks should be prepared to\n\t\t\/\/\t\thandle that error for cancellable Deferreds.\n\t\t\/\/ example:\n\t\t\/\/\t|\tvar deferred = new dojo.Deferred();\n\t\t\/\/\t|\tsetTimeout(function(){ deferred.callback({success: true}); }, 1000);\n\t\t\/\/\t|\treturn deferred;\n\t\t\/\/ example:\n\t\t\/\/\t\tDeferred objects are often used when making code asynchronous. It\n\t\t\/\/\t\tmay be easiest to write functions in a synchronous manner and then\n\t\t\/\/\t\tsplit code using a deferred to trigger a response to a long-lived\n\t\t\/\/\t\toperation. For example, instead of register a callback function to\n\t\t\/\/\t\tdenote when a rendering operation completes, the function can\n\t\t\/\/\t\tsimply return a deferred:\n\t\t\/\/\n\t\t\/\/\t\t|\t\/\/ callback style:\n\t\t\/\/\t\t|\tfunction renderLotsOfData(data, callback){\n\t\t\/\/\t\t|\t\tvar success = false\n\t\t\/\/\t\t|\t\ttry{\n\t\t\/\/\t\t|\t\t\tfor(var x in data){\n\t\t\/\/\t\t|\t\t\t\trenderDataitem(data[x]);\n\t\t\/\/\t\t|\t\t\t}\n\t\t\/\/\t\t|\t\t\tsuccess = true;\n\t\t\/\/\t\t|\t\t}catch(e){ }\n\t\t\/\/\t\t|\t\tif(callback){\n\t\t\/\/\t\t|\t\t\tcallback(success);\n\t\t\/\/\t\t|\t\t}\n\t\t\/\/\t\t|\t}\n\t\t\/\/\n\t\t\/\/\t\t|\t\/\/ using callback style\n\t\t\/\/\t\t|\trenderLotsOfData(someDataObj, function(success){\n\t\t\/\/\t\t|\t\t\/\/ handles success or failure\n\t\t\/\/\t\t|\t\tif(!success){\n\t\t\/\/\t\t|\t\t\tpromptUserToRecover();\n\t\t\/\/\t\t|\t\t}\n\t\t\/\/\t\t|\t});\n\t\t\/\/\t\t|\t\/\/ NOTE: no way to add another callback here!!\n\t\t\/\/ example:\n\t\t\/\/\t\tUsing a Deferred doesn't simplify the sending code any, but it\n\t\t\/\/\t\tprovides a standard interface for callers and senders alike,\n\t\t\/\/\t\tproviding both with a simple way to service multiple callbacks for\n\t\t\/\/\t\tan operation and freeing both sides from worrying about details\n\t\t\/\/\t\tsuch as \"did this get called already?\". With Deferreds, new\n\t\t\/\/\t\tcallbacks can be added at any time.\n\t\t\/\/\n\t\t\/\/\t\t|\t\/\/ Deferred style:\n\t\t\/\/\t\t|\tfunction renderLotsOfData(data){\n\t\t\/\/\t\t|\t\tvar d = new dojo.Deferred();\n\t\t\/\/\t\t|\t\ttry{\n\t\t\/\/\t\t|\t\t\tfor(var x in data){\n\t\t\/\/\t\t|\t\t\t\trenderDataitem(data[x]);\n\t\t\/\/\t\t|\t\t\t}\n\t\t\/\/\t\t|\t\t\td.callback(true);\n\t\t\/\/\t\t|\t\t}catch(e){\n\t\t\/\/\t\t|\t\t\td.errback(new Error(\"rendering failed\"));\n\t\t\/\/\t\t|\t\t}\n\t\t\/\/\t\t|\t\treturn d;\n\t\t\/\/\t\t|\t}\n\t\t\/\/\n\t\t\/\/\t\t|\t\/\/ using Deferred style\n\t\t\/\/\t\t|\trenderLotsOfData(someDataObj).then(null, function(){\n\t\t\/\/\t\t|\t\tpromptUserToRecover();\n\t\t\/\/\t\t|\t});\n\t\t\/\/\t\t|\t\/\/ NOTE: addErrback and addCallback both return the Deferred\n\t\t\/\/\t\t|\t\/\/ again, so we could chain adding callbacks or save the\n\t\t\/\/\t\t|\t\/\/ deferred for later should we need to be notified again.\n\t\t\/\/ example:\n\t\t\/\/\t\tIn this example, renderLotsOfData is synchronous and so both\n\t\t\/\/\t\tversions are pretty artificial. Putting the data display on a\n\t\t\/\/\t\ttimeout helps show why Deferreds rock:\n\t\t\/\/\n\t\t\/\/\t\t|\t\/\/ Deferred style and async func\n\t\t\/\/\t\t|\tfunction renderLotsOfData(data){\n\t\t\/\/\t\t|\t\tvar d = new dojo.Deferred();\n\t\t\/\/\t\t|\t\tsetTimeout(function(){\n\t\t\/\/\t\t|\t\t\ttry{\n\t\t\/\/\t\t|\t\t\t\tfor(var x in data){\n\t\t\/\/\t\t|\t\t\t\t\trenderDataitem(data[x]);\n\t\t\/\/\t\t|\t\t\t\t}\n\t\t\/\/\t\t|\t\t\t\td.callback(true);\n\t\t\/\/\t\t|\t\t\t}catch(e){\n\t\t\/\/\t\t|\t\t\t\td.errback(new Error(\"rendering failed\"));\n\t\t\/\/\t\t|\t\t\t}\n\t\t\/\/\t\t|\t\t}, 100);\n\t\t\/\/\t\t|\t\treturn d;\n\t\t\/\/\t\t|\t}\n\t\t\/\/\n\t\t\/\/\t\t|\t\/\/ using Deferred style\n\t\t\/\/\t\t|\trenderLotsOfData(someDataObj).then(null, function(){\n\t\t\/\/\t\t|\t\tpromptUserToRecover();\n\t\t\/\/\t\t|\t});\n\t\t\/\/\n\t\t\/\/\t\tNote that the caller doesn't have to change his code at all to\n\t\t\/\/\t\thandle the asynchronous case.\n\n\t\tvar result, finished, isError, head, nextListener;\n\t\tvar promise = (this.promise = {});\n\n\t\tfunction complete(value){\n\t\t\tif(finished){\n\t\t\t\tthrow new Error(\"This deferred has already been resolved\");\n\t\t\t}\n\t\t\tresult = value;\n\t\t\tfinished = true;\n\t\t\tnotify();\n\t\t}\n\t\tfunction notify(){\n\t\t\tvar mutated;\n\t\t\twhile(!mutated && nextListener){\n\t\t\t\tvar listener = nextListener;\n\t\t\t\tnextListener = nextListener.next;\n\t\t\t\tif((mutated = (listener.progress == mutator))){ \/\/ assignment and check\n\t\t\t\t\tfinished = false;\n\t\t\t\t}\n\t\t\t\tvar func = (isError ? listener.error : listener.resolved);\n\t\t\t\tif(func){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tvar newResult = func(result);\n\t\t\t\t\t\tif (newResult && typeof newResult.then === \"function\"){\n\t\t\t\t\t\t\tnewResult.then(dojo.hitch(listener.deferred, \"resolve\"), dojo.hitch(listener.deferred, \"reject\"));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar unchanged = mutated && newResult === undefined;\n\t\t\t\t\t\tif(mutated && !unchanged){\n\t\t\t\t\t\t\tisError = newResult instanceof Error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlistener.deferred[unchanged && isError ? \"reject\" : \"resolve\"](unchanged ? result : newResult);\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tlistener.deferred.reject(e);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(isError){\n\t\t\t\t\t\tlistener.deferred.reject(result);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlistener.deferred.resolve(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ calling resolve will resolve the promise\n\t\tthis.resolve = this.callback = function(value){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tFulfills the Deferred instance successfully with the provide value\n\t\t\tthis.fired = 0;\n\t\t\tthis.results = [value, null];\n\t\t\tcomplete(value);\n\t\t};\n\n\n\t\t\/\/ calling error will indicate that the promise failed\n\t\tthis.reject = this.errback = function(error){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tFulfills the Deferred instance as an error with the provided error\n\t\t\tisError = true;\n\t\t\tthis.fired = 1;\n\t\t\tcomplete(error);\n\t\t\tthis.results = [null, error];\n\t\t\tif(!error || error.log !== false){\n\t\t\t\t(dojo.config.deferredOnError || function(x){ console.error(x); })(error);\n\t\t\t}\n\t\t};\n\t\t\/\/ call progress to provide updates on the progress on the completion of the promise\n\t\tthis.progress = function(update){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tSend progress events to all listeners\n\t\t\tvar listener = nextListener;\n\t\t\twhile(listener){\n\t\t\t\tvar progress = listener.progress;\n\t\t\t\tprogress && progress(update);\n\t\t\t\tlistener = listener.next;\n\t\t\t}\n\t\t};\n\t\tthis.addCallbacks = function(\/*Function?*\/callback, \/*Function?*\/errback){\n\t\t\tthis.then(callback, errback, mutator);\n\t\t\treturn this;\n\t\t};\n\t\t\/\/ provide the implementation of the promise\n\t\tthis.then = promise.then = function(\/*Function?*\/resolvedCallback, \/*Function?*\/errorCallback, \/*Function?*\/progressCallback){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tAdds a fulfilledHandler, errorHandler, and progressHandler to be called for\n\t\t\t\/\/\t\tcompletion of a promise. The fulfilledHandler is called when the promise\n\t\t\t\/\/\t\tis fulfilled. The errorHandler is called when a promise fails. The\n\t\t\t\/\/\t\tprogressHandler is called for progress events. All arguments are optional\n\t\t\t\/\/\t\tand non-function values are ignored. The progressHandler is not only an\n\t\t\t\/\/\t\toptional argument, but progress events are purely optional. Promise\n\t\t\t\/\/\t\tproviders are not required to ever create progress events.\n\t\t\t\/\/\n\t\t\t\/\/\t\tThis function will return a new promise that is fulfilled when the given\n\t\t\t\/\/\t\tfulfilledHandler or errorHandler callback is finished. This allows promise\n\t\t\t\/\/\t\toperations to be chained together. The value returned from the callback\n\t\t\t\/\/\t\thandler is the fulfillment value for the returned promise. If the callback\n\t\t\t\/\/\t\tthrows an error, the returned promise will be moved to failed state.\n\t\t\t\/\/\n\t\t\t\/\/ example:\n\t\t\t\/\/\t\tAn example of using a CommonJS compliant promise:\n\t\t\t\/\/\t\t|\tasyncComputeTheAnswerToEverything().\n\t\t\t\/\/\t\t|\t\tthen(addTwo).\n\t\t\t\/\/\t\t|\t\tthen(printResult, onError);\n\t\t\t\/\/\t\t|\t>44\n\t\t\t\/\/\n\t\t\tvar returnDeferred = progressCallback == mutator ? this : new dojo.Deferred(promise.cancel);\n\t\t\tvar listener = {\n\t\t\t\tresolved: resolvedCallback,\n\t\t\t\terror: errorCallback,\n\t\t\t\tprogress: progressCallback,\n\t\t\t\tdeferred: returnDeferred\n\t\t\t};\n\t\t\tif(nextListener){\n\t\t\t\thead = head.next = listener;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnextListener = head = listener;\n\t\t\t}\n\t\t\tif(finished){\n\t\t\t\tnotify();\n\t\t\t}\n\t\t\treturn returnDeferred.promise;\n\t\t};\n\t\tvar deferred = this;\n\t\tthis.cancel = promise.cancel = function (){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tCancels the asynchronous operation\n\t\t\tif(!finished){\n\t\t\t\tvar error = canceller && canceller(deferred);\n\t\t\t\tif(!finished){\n\t\t\t\t\tif (!(error instanceof Error)){\n\t\t\t\t\t\terror = new Error(error);\n\t\t\t\t\t}\n\t\t\t\t\terror.log = false;\n\t\t\t\t\tdeferred.reject(error);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfreeze(promise);\n\t};\n\tlang.extend(dojo.Deferred, {\n\t\taddCallback: function (\/*Function*\/callback){\n\t\t\treturn this.addCallbacks(dojo.hitch.apply(dojo, arguments));\n\t\t},\n\n\t\taddErrback: function (\/*Function*\/errback){\n\t\t\treturn this.addCallbacks(null, dojo.hitch.apply(dojo, arguments));\n\t\t},\n\n\t\taddBoth: function (\/*Function*\/callback){\n\t\t\tvar enclosed = dojo.hitch.apply(dojo, arguments);\n\t\t\treturn this.addCallbacks(enclosed, enclosed);\n\t\t},\n\t\tfired: -1\n\t});\n\n\tdojo.Deferred.when = dojo.when = function(promiseOrValue, \/*Function?*\/callback, \/*Function?*\/errback, \/*Function?*\/progressHandler){\n\t\t\/\/ summary:\n\t\t\/\/\t\tThis provides normalization between normal synchronous values and\n\t\t\/\/\t\tasynchronous promises, so you can interact with them in a common way\n\t\t\/\/ example:\n\t\t\/\/\t\t|\tfunction printFirstAndList(items){\n\t\t\/\/\t\t|\t\tdojo.when(findFirst(items), console.log);\n\t\t\/\/\t\t|\t\tdojo.when(findLast(items), console.log);\n\t\t\/\/\t\t|\t}\n\t\t\/\/\t\t|\tfunction findFirst(items){\n\t\t\/\/\t\t|\t\treturn dojo.when(items, function(items){\n\t\t\/\/\t\t|\t\t\treturn items[0];\n\t\t\/\/\t\t|\t\t});\n\t\t\/\/\t\t|\t}\n\t\t\/\/\t\t|\tfunction findLast(items){\n\t\t\/\/\t\t|\t\treturn dojo.when(items, function(items){\n\t\t\/\/\t\t|\t\t\treturn items[items.length];\n\t\t\/\/\t\t|\t\t});\n\t\t\/\/\t\t|\t}\n\t\t\/\/\t\tAnd now all three of his functions can be used sync or async.\n\t\t\/\/\t\t|\tprintFirstAndLast([1,2,3,4]) will work just as well as\n\t\t\/\/\t\t|\tprintFirstAndLast(dojo.xhrGet(...));\n\n\t\tif(promiseOrValue && typeof promiseOrValue.then === \"function\"){\n\t\t\treturn promiseOrValue.then(callback, errback, progressHandler);\n\t\t}\n\t\treturn callback(promiseOrValue);\n\t};\n\n\treturn dojo.Deferred;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/_base\/lang"]},"dojo\/_base\/json":{"id":"dojo\/_base\/json","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/json.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \"..\/json\"], function(dojo, json){\n  \/\/ module:\n  \/\/    dojo\/_base\/json\n  \/\/ summary:\n  \/\/    This module defines the dojo JSON API.\n\ndojo.fromJson = function(\/*String*\/ js){\n\t\/\/ summary:\n\t\/\/\t\tParses a JavaScript expression and returns a JavaScript value.\n\t\/\/ description:\n\t\/\/\t\tThrows for invalid JavaScript expressions. It does not use a strict JSON parser. It\n\t\/\/\t\talways delegates to eval(). The content passed to this method must therefore come\n\t\/\/\t\tfrom a trusted source.\n\t\/\/\t\tIt is recommend that you use dojo\/json's parse function for an\n\t\/\/\t\timplementation uses the (faster) native JSON parse when available.\n\t\/\/ js:\n\t\/\/\t\ta string literal of a JavaScript expression, for instance:\n\t\/\/\t\t\t`'{ \"foo\": [ \"bar\", 1, { \"baz\": \"thud\" } ] }'`\n\n\treturn eval(\"(\" + js + \")\"); \/\/ Object\n};\n\n\/*=====\ndojo._escapeString = function(){\n\t\/\/ summary:\n\t\/\/\t\tAdds escape sequences for non-visual characters, double quote and\n\t\/\/\t\tbackslash and surrounds with double quotes to form a valid string\n\t\/\/\t\tliteral.\n};\n=====*\/\ndojo._escapeString = json.stringify; \/\/ just delegate to json.stringify\n\ndojo.toJsonIndentStr = \"\\t\";\ndojo.toJson = function(\/*Object*\/ it, \/*Boolean?*\/ prettyPrint, \/*String?*\/ _indentStr){\n\t\/\/ summary:\n\t\/\/\t\tReturns a [JSON](http:\/\/json.org) serialization of an object.\n\t\/\/ description:\n\t\/\/\t\tReturns a [JSON](http:\/\/json.org) serialization of an object.\n\t\/\/\t\tNote that this doesn't check for infinite recursion, so don't do that!\n\t\/\/\t\tIt is recommend that you use dojo\/json's stringify function for an lighter\n\t\/\/\t\tand faster implementation that matches the native JSON API and uses the\n\t\/\/\t\tnative JSON serializer when available.\n\t\/\/ it:\n\t\/\/\t\tan object to be serialized. Objects may define their own\n\t\/\/\t\tserialization via a special \"__json__\" or \"json\" function\n\t\/\/\t\tproperty. If a specialized serializer has been defined, it will\n\t\/\/\t\tbe used as a fallback.\n\t\/\/\t\tNote that in 1.6, toJson would serialize undefined, but this no longer supported\n\t\/\/\t\tsince it is not supported by native JSON serializer.\n\t\/\/ prettyPrint:\n\t\/\/\t\tif true, we indent objects and arrays to make the output prettier.\n\t\/\/\t\tThe variable `dojo.toJsonIndentStr` is used as the indent string --\n\t\/\/\t\tto use something other than the default (tab), change that variable\n\t\/\/\t\tbefore calling dojo.toJson().\n\t\/\/\t\tNote that if native JSON support is available, it will be used for serialization,\n\t\/\/\t\tand native implementations vary on the exact spacing used in pretty printing.\n\t\/\/\t_indentStr:\n\t\/\/\t\tprivate variable for recursive calls when pretty printing, do not use.\n\t\/\/ returns:\n\t\/\/ \t\tA JSON string serialization of the passed-in object.\n\t\/\/ example:\n\t\/\/\t\tsimple serialization of a trivial object\n\t\/\/\t\t|\tvar jsonStr = dojo.toJson({ howdy: \"stranger!\", isStrange: true });\n\t\/\/\t\t|\tdoh.is('{\"howdy\":\"stranger!\",\"isStrange\":true}', jsonStr);\n\t\/\/ example:\n\t\/\/\t\ta custom serializer for an objects of a particular class:\n\t\/\/\t\t|\tdojo.declare(\"Furby\", null, {\n\t\/\/\t\t|\t\tfurbies: \"are strange\",\n\t\/\/\t\t|\t\tfurbyCount: 10,\n\t\/\/\t\t|\t\t__json__: function(){\n\t\/\/\t\t|\t\t},\n\t\/\/\t\t|\t});\n\n\t\/\/ use dojo\/json\n\treturn json.stringify(it, function(key, value){\n\t\tif(value){\n\t\t\tvar tf = value.__json__||value.json;\n\t\t\tif(typeof tf == \"function\"){\n\t\t\t\treturn tf.call(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}, prettyPrint && dojo.toJsonIndentStr);\t\/\/ String\n};\n\nreturn dojo;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/json"]},"dojo\/json":{"id":"dojo\/json","url":"\/home\/arian\/www\/MooTools\/dojo\/json.js","package":"dojo","amd":true,"content":"define([\".\/has\"], function(has){\r\n\t\"use strict\";\r\n\tvar hasJSON = typeof JSON != \"undefined\";\r\n\thas.add(\"json-parse\", hasJSON); \/\/ all the parsers work fine\r\n\t\t\/\/ Firefox 3.5\/Gecko 1.9 fails to use replacer in stringify properly https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=509184\r\n\thas.add(\"json-stringify\", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{\"a\":1}'); \r\n\tif(has(\"json-stringify\")){\r\n\t\treturn JSON;\r\n\t}\r\n\telse{\r\n\t\tvar escapeString = function(\/*String*\/str){\r\n\t\t\t\/\/summary:\r\n\t\t\t\/\/\t\tAdds escape sequences for non-visual characters, double quote and\r\n\t\t\t\/\/\t\tbackslash and surrounds with double quotes to form a valid string\r\n\t\t\t\/\/\t\tliteral.\r\n\t\t\treturn ('\"' + str.replace(\/([\"\\\\])\/g, '\\\\$1') + '\"').\r\n\t\t\t\treplace(\/[\\f]\/g, \"\\\\f\").replace(\/[\\b]\/g, \"\\\\b\").replace(\/[\\n]\/g, \"\\\\n\").\r\n\t\t\t\treplace(\/[\\t]\/g, \"\\\\t\").replace(\/[\\r]\/g, \"\\\\r\"); \/\/ string\r\n\t\t};\r\n\t\treturn {\r\n\t\t\tparse: has(\"json-parse\") ? JSON.parse : function(str, strict){\r\n\t\t\t\t\/\/ summary:\r\n\t\t\t\t\/\/ \t\tParses a [JSON](http:\/\/json.org) string to return a JavaScript object.\r\n\t\t\t\t\/\/ description:\r\n\t\t\t\t\/\/\t\tThis function follows [native JSON API](https:\/\/developer.mozilla.org\/en\/JSON)\r\n\t\t\t\t\/\/ \t\tThrows for invalid JSON strings. This delegates to eval() if native JSON\r\n\t\t\t\t\/\/ \t\tsupport is not available. By default this will evaluate any valid JS expression.\r\n\t\t\t\t\/\/\t\tWith the strict parameter set to true, the parser will ensure that only\r\n\t\t\t\t\/\/\t\tvalid JSON strings are parsed (otherwise throwing an error). Without the strict\r\n\t\t\t\t\/\/ \t\tparameter, the content passed to this method must come\r\n\t\t\t\t\/\/\t\tfrom a trusted source.\r\n\t\t\t\t\/\/ str:\r\n\t\t\t\t\/\/\t\ta string literal of a JSON item, for instance:\r\n\t\t\t\t\/\/\t\t\t`'{ \"foo\": [ \"bar\", 1, { \"baz\": \"thud\" } ] }'`\r\n\t\t\t\t\/\/\tstrict: \r\n\t\t\t\t\/\/\t\tWhen set to true, this will ensure that only valid, secure JSON is ever parsed.\r\n\t\t\t\t\/\/ \t\tMake sure this is set to true for untrusted content. Note that on browsers\/engines\r\n\t\t\t\t\/\/\t\twithout native JSON support, setting this to true will run slower.\r\n\t\t\t\tif(strict && !\/^([\\s\\[\\{]*(?:\"(?:\\\\.|[^\"])+\"|-?\\d[\\d\\.]*(?:[Ee][+-]?\\d+)?|null|true|false|)[\\s\\]\\}]*(?:,|:|$))+$\/.test(str)){\r\n\t\t\t\t\tthrow new SyntaxError(\"Invalid characters in JSON\");\r\n\t\t\t\t}\r\n\t\t\t\treturn eval('(' + str + ')');\r\n\t\t\t},\r\n\t\t\tstringify: function(value, replacer, spacer){\r\n\t\t\t\t\/\/\tsummary:\r\n\t\t\t\t\/\/\t\tReturns a [JSON](http:\/\/json.org) serialization of an object.\r\n\t\t\t\t\/\/\tdescription:\r\n\t\t\t\t\/\/\t\tReturns a [JSON](http:\/\/json.org) serialization of an object.\r\n\t\t\t\t\/\/\t\tThis function follows [native JSON API](https:\/\/developer.mozilla.org\/en\/JSON)\r\n\t\t\t\t\/\/\t\tNote that this doesn't check for infinite recursion, so don't do that!\r\n\t\t\t\t\/\/\tvalue:\r\n\t\t\t\t\/\/\t\tA value to be serialized. \r\n\t\t\t\t\/\/\treplacer:\r\n\t\t\t\t\/\/\t\tA replacer function that is called for each value and can return a replacement\r\n\t\t\t\t\/\/\tspacer:\r\n\t\t\t\t\/\/\t\tA spacer string to be used for pretty printing of JSON\r\n\t\t\t\t\/\/\t\t\r\n\t\t\t\t\/\/\texample:\r\n\t\t\t\t\/\/\t\tsimple serialization of a trivial object\r\n\t\t\t\t\/\/\t\t|\tdefine([\"dojo\/json\"], function(JSON){\r\n\t\t\t\t\/\/ \t\t|\t\tvar jsonStr = JSON.stringify({ howdy: \"stranger!\", isStrange: true });\r\n\t\t\t\t\/\/\t\t|\t\tdoh.is('{\"howdy\":\"stranger!\",\"isStrange\":true}', jsonStr);\r\n\t\t\t\tvar undef;\r\n\t\t\t\tif(typeof replacer == \"string\"){\r\n\t\t\t\t\tspacer = replacer;\r\n\t\t\t\t\treplacer = null;\r\n\t\t\t\t}\r\n\t\t\t\tfunction stringify(it, indent, key){\r\n\t\t\t\t\tif(replacer){\r\n\t\t\t\t\t\tit = replacer(key, it);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar val, objtype = typeof it;\r\n\t\t\t\t\tif(objtype == \"number\"){\r\n\t\t\t\t\t\treturn isFinite(it) ? it + \"\" : \"null\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(objtype == \"boolean\"){\r\n\t\t\t\t\t\treturn it + \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(it === null){\r\n\t\t\t\t\t\treturn \"null\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(typeof it == \"string\"){\r\n\t\t\t\t\t\treturn escapeString(it);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(objtype == \"function\" || objtype == \"undefined\"){\r\n\t\t\t\t\t\treturn undef; \/\/ undefined\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\/\/ short-circuit for objects that support \"json\" serialization\r\n\t\t\t\t\t\/\/ if they return \"self\" then just pass-through...\r\n\t\t\t\t\tif(typeof it.toJSON == \"function\"){\r\n\t\t\t\t\t\treturn stringify(it.toJSON(key), indent, key);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(it instanceof Date){\r\n\t\t\t\t\t\treturn '\"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z\"'.replace(\/\\{(\\w+)(\\+)?\\}\/g, function(t, prop, plus){\r\n\t\t\t\t\t\t\tvar num = it[\"getUTC\" + prop]() + (plus ? 1 : 0);\r\n\t\t\t\t\t\t\treturn num < 10 ? \"0\" + num : num;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(it.valueOf() !== it){\r\n\t\t\t\t\t\t\/\/ primitive wrapper, try again unwrapped:\r\n\t\t\t\t\t\treturn stringify(it.valueOf(), indent, key);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar nextIndent= spacer ? (indent + spacer) : \"\";\r\n\t\t\t\t\t\/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable *\/ \r\n\t\t\t\t\r\n\t\t\t\t\tvar sep = spacer ? \" \" : \"\";\r\n\t\t\t\t\tvar newLine = spacer ? \"\\n\" : \"\";\r\n\t\t\t\t\r\n\t\t\t\t\t\/\/ array\r\n\t\t\t\t\tif(it instanceof Array){\r\n\t\t\t\t\t\tvar itl = it.length, res = [];\r\n\t\t\t\t\t\tfor(key = 0; key < itl; key++){\r\n\t\t\t\t\t\t\tvar obj = it[key];\r\n\t\t\t\t\t\t\tval = stringify(obj, nextIndent, key);\r\n\t\t\t\t\t\t\tif(typeof val != \"string\"){\r\n\t\t\t\t\t\t\t\tval = \"null\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tres.push(newLine + nextIndent + val);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn \"[\" + res.join(\",\") + newLine + indent + \"]\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\/\/ generic object code path\r\n\t\t\t\t\tvar output = [];\r\n\t\t\t\t\tfor(key in it){\r\n\t\t\t\t\t\tvar keyStr;\r\n\t\t\t\t\t\tif(typeof key == \"number\"){\r\n\t\t\t\t\t\t\tkeyStr = '\"' + key + '\"';\r\n\t\t\t\t\t\t}else if(typeof key == \"string\"){\r\n\t\t\t\t\t\t\tkeyStr = escapeString(key);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\/\/ skip non-string or number keys\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tval = stringify(it[key], nextIndent, key);\r\n\t\t\t\t\t\tif(typeof val != \"string\"){\r\n\t\t\t\t\t\t\t\/\/ skip non-serializable values\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\/\/ At this point, the most non-IE browsers don't get in this branch \r\n\t\t\t\t\t\t\/\/ (they have native JSON), so push is definitely the way to\r\n\t\t\t\t\t\toutput.push(newLine + nextIndent + keyStr + \":\" + sep + val);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn \"{\" + output.join(\",\") + newLine + indent + \"}\"; \/\/ String\r\n\t\t\t\t}\r\n\t\t\t\treturn stringify(value, \"\", \"\");\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n});\r\n","dependencies":["dojo\/has"]},"dojo\/_base\/Color":{"id":"dojo\/_base\/Color","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/Color.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \".\/lang\", \".\/array\", \".\/config\"], function(dojo, lang, ArrayUtil, config){\n\n\tvar Color = dojo.Color = function(\/*Array|String|Object*\/ color){\n\t\t\/\/ summary:\n\t\t\/\/\t\tTakes a named string, hex string, array of rgb or rgba values,\n\t\t\/\/\t\tan object with r, g, b, and a properties, or another `dojo.Color` object\n\t\t\/\/\t\tand creates a new Color instance to work from.\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tWork with a Color instance:\n\t\t\/\/\t | var c = new dojo.Color();\n\t\t\/\/\t | c.setColor([0,0,0]); \/\/ black\n\t\t\/\/\t | var hex = c.toHex(); \/\/ #000000\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tWork with a node's color:\n\t\t\/\/\t | var color = dojo.style(\"someNode\", \"backgroundColor\");\n\t\t\/\/\t | var n = new dojo.Color(color);\n\t\t\/\/\t | \/\/ adjust the color some\n\t\t\/\/\t | n.r *= .5;\n\t\t\/\/\t | console.log(n.toString()); \/\/ rgb(128, 255, 255);\n\t\tif(color){ this.setColor(color); }\n\t};\n\n\t\/*=====\n\tlang.mixin(dojo.Color,{\n\t\tnamed:{\n\t\t\t\/\/ summary: Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.\n\t\t}\n\t});\n\t=====*\/\n\n\t\/\/ FIXME:\n\t\/\/ there's got to be a more space-efficient way to encode or discover\n\t\/\/ these!! Use hex?\n\tColor.named = {\n\t\t\"black\":  [0,0,0],\n\t\t\"silver\": [192,192,192],\n\t\t\"gray\":\t  [128,128,128],\n\t\t\"white\":  [255,255,255],\n\t\t\"maroon\": [128,0,0],\n\t\t\"red\":\t  [255,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"fuchsia\":[255,0,255],\n\t\t\"green\":  [0,128,0],\n\t\t\"lime\":\t  [0,255,0],\n\t\t\"olive\":  [128,128,0],\n\t\t\"yellow\": [255,255,0],\n\t\t\"navy\":\t  [0,0,128],\n\t\t\"blue\":\t  [0,0,255],\n\t\t\"teal\":\t  [0,128,128],\n\t\t\"aqua\":\t  [0,255,255],\n\t\t\"transparent\": config.transparentColor || [0,0,0,0]\n\t};\n\n\tlang.extend(Color, {\n\t\tr: 255, g: 255, b: 255, a: 1,\n\t\t_set: function(r, g, b, a){\n\t\t\tvar t = this; t.r = r; t.g = g; t.b = b; t.a = a;\n\t\t},\n\t\tsetColor: function(\/*Array|String|Object*\/ color){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tTakes a named string, hex string, array of rgb or rgba values,\n\t\t\t\/\/\t\tan object with r, g, b, and a properties, or another `dojo.Color` object\n\t\t\t\/\/\t\tand sets this color instance to that value.\n\t\t\t\/\/\n\t\t\t\/\/ example:\n\t\t\t\/\/\t|\tvar c = new dojo.Color(); \/\/ no color\n\t\t\t\/\/\t|\tc.setColor(\"#ededed\"); \/\/ greyish\n\t\t\tif(lang.isString(color)){\n\t\t\t\tColor.fromString(color, this);\n\t\t\t}else if(lang.isArray(color)){\n\t\t\t\tColor.fromArray(color, this);\n\t\t\t}else{\n\t\t\t\tthis._set(color.r, color.g, color.b, color.a);\n\t\t\t\tif(!(color instanceof Color)){ this.sanitize(); }\n\t\t\t}\n\t\t\treturn this;\t\/\/ dojo.Color\n\t\t},\n\t\tsanitize: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tEnsures the object has correct attributes\n\t\t\t\/\/ description:\n\t\t\t\/\/\t\tthe default implementation does nothing, include dojo.colors to\n\t\t\t\/\/\t\taugment it with real checks\n\t\t\treturn this;\t\/\/ dojo.Color\n\t\t},\n\t\ttoRgb: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tReturns 3 component array of rgb values\n\t\t\t\/\/ example:\n\t\t\t\/\/\t|\tvar c = new dojo.Color(\"#000000\");\n\t\t\t\/\/\t|\tconsole.log(c.toRgb()); \/\/ [0,0,0]\n\t\t\tvar t = this;\n\t\t\treturn [t.r, t.g, t.b]; \/\/ Array\n\t\t},\n\t\ttoRgba: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tReturns a 4 component array of rgba values from the color\n\t\t\t\/\/\t\trepresented by this object.\n\t\t\tvar t = this;\n\t\t\treturn [t.r, t.g, t.b, t.a];\t\/\/ Array\n\t\t},\n\t\ttoHex: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tReturns a CSS color string in hexadecimal representation\n\t\t\t\/\/ example:\n\t\t\t\/\/\t|\tconsole.log(new dojo.Color([0,0,0]).toHex()); \/\/ #000000\n\t\t\tvar arr = ArrayUtil.map([\"r\", \"g\", \"b\"], function(x){\n\t\t\t\tvar s = this[x].toString(16);\n\t\t\t\treturn s.length < 2 ? \"0\" + s : s;\n\t\t\t}, this);\n\t\t\treturn \"#\" + arr.join(\"\");\t\/\/ String\n\t\t},\n\t\ttoCss: function(\/*Boolean?*\/ includeAlpha){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tReturns a css color string in rgb(a) representation\n\t\t\t\/\/ example:\n\t\t\t\/\/\t|\tvar c = new dojo.Color(\"#FFF\").toCss();\n\t\t\t\/\/\t|\tconsole.log(c); \/\/ rgb('255','255','255')\n\t\t\tvar t = this, rgb = t.r + \", \" + t.g + \", \" + t.b;\n\t\t\treturn (includeAlpha ? \"rgba(\" + rgb + \", \" + t.a : \"rgb(\" + rgb) + \")\";\t\/\/ String\n\t\t},\n\t\ttoString: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tReturns a visual representation of the color\n\t\t\treturn this.toCss(true); \/\/ String\n\t\t}\n\t});\n\n\tColor.blendColors = dojo.blendColors = function(\n\t\t\/*dojo.Color*\/ start,\n\t\t\/*dojo.Color*\/ end,\n\t\t\/*Number*\/ weight,\n\t\t\/*dojo.Color?*\/ obj\n\t){\n\t\t\/\/ summary:\n\t\t\/\/\t\tBlend colors end and start with weight from 0 to 1, 0.5 being a 50\/50 blend,\n\t\t\/\/\t\tcan reuse a previously allocated dojo.Color object for the result\n\t\tvar t = obj || new Color();\n\t\tArrayUtil.forEach([\"r\", \"g\", \"b\", \"a\"], function(x){\n\t\t\tt[x] = start[x] + (end[x] - start[x]) * weight;\n\t\t\tif(x != \"a\"){ t[x] = Math.round(t[x]); }\n\t\t});\n\t\treturn t.sanitize();\t\/\/ dojo.Color\n\t};\n\n\tColor.fromRgb = dojo.colorFromRgb = function(\/*String*\/ color, \/*dojo.Color?*\/ obj){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns a `dojo.Color` instance from a string of the form\n\t\t\/\/\t\t\"rgb(...)\" or \"rgba(...)\". Optionally accepts a `dojo.Color`\n\t\t\/\/\t\tobject to update with the parsed value and return instead of\n\t\t\/\/\t\tcreating a new object.\n\t\t\/\/ returns:\n\t\t\/\/\t\tA dojo.Color object. If obj is passed, it will be the return value.\n\t\tvar m = color.toLowerCase().match(\/^rgba?\\(([\\s\\.,0-9]+)\\)\/);\n\t\treturn m && Color.fromArray(m[1].split(\/\\s*,\\s*\/), obj);\t\/\/ dojo.Color\n\t};\n\n\tColor.fromHex = dojo.colorFromHex = function(\/*String*\/ color, \/*dojo.Color?*\/ obj){\n\t\t\/\/ summary:\n\t\t\/\/\t\tConverts a hex string with a '#' prefix to a color object.\n\t\t\/\/\t\tSupports 12-bit #rgb shorthand. Optionally accepts a\n\t\t\/\/\t\t`dojo.Color` object to update with the parsed value.\n\t\t\/\/\n\t\t\/\/ returns:\n\t\t\/\/\t\tA dojo.Color object. If obj is passed, it will be the return value.\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t | var thing = dojo.colorFromHex(\"#ededed\"); \/\/ grey, longhand\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t| var thing = dojo.colorFromHex(\"#000\"); \/\/ black, shorthand\n\t\tvar t = obj || new Color(),\n\t\t\tbits = (color.length == 4) ? 4 : 8,\n\t\t\tmask = (1 << bits) - 1;\n\t\tcolor = Number(\"0x\" + color.substr(1));\n\t\tif(isNaN(color)){\n\t\t\treturn null; \/\/ dojo.Color\n\t\t}\n\t\tArrayUtil.forEach([\"b\", \"g\", \"r\"], function(x){\n\t\t\tvar c = color & mask;\n\t\t\tcolor >>= bits;\n\t\t\tt[x] = bits == 4 ? 17 * c : c;\n\t\t});\n\t\tt.a = 1;\n\t\treturn t;\t\/\/ dojo.Color\n\t};\n\n\tColor.fromArray = dojo.colorFromArray = function(\/*Array*\/ a, \/*dojo.Color?*\/ obj){\n\t\t\/\/ summary:\n\t\t\/\/\t\tBuilds a `dojo.Color` from a 3 or 4 element array, mapping each\n\t\t\/\/\t\telement in sequence to the rgb(a) values of the color.\n\t\t\/\/ example:\n\t\t\/\/\t\t| var myColor = dojo.colorFromArray([237,237,237,0.5]); \/\/ grey, 50% alpha\n\t\t\/\/ returns:\n\t\t\/\/\t\tA dojo.Color object. If obj is passed, it will be the return value.\n\t\tvar t = obj || new Color();\n\t\tt._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));\n\t\tif(isNaN(t.a)){ t.a = 1; }\n\t\treturn t.sanitize();\t\/\/ dojo.Color\n\t};\n\n\tColor.fromString = dojo.colorFromString = function(\/*String*\/ str, \/*dojo.Color?*\/ obj){\n\t\t\/\/ summary:\n\t\t\/\/\t\tParses `str` for a color value. Accepts hex, rgb, and rgba\n\t\t\/\/\t\tstyle color values.\n\t\t\/\/ description:\n\t\t\/\/\t\tAcceptable input values for str may include arrays of any form\n\t\t\/\/\t\taccepted by dojo.colorFromArray, hex strings such as \"#aaaaaa\", or\n\t\t\/\/\t\trgb or rgba strings such as \"rgb(133, 200, 16)\" or \"rgba(10, 10,\n\t\t\/\/\t\t10, 50)\"\n\t\t\/\/ returns:\n\t\t\/\/\t\tA dojo.Color object. If obj is passed, it will be the return value.\n\t\tvar a = Color.named[str];\n\t\treturn a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);\t\/\/ dojo.Color\n\t};\n\n\treturn Color;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/_base\/lang","dojo\/_base\/array","dojo\/_base\/config"]},"dojo\/_firebug\/firebug":{"id":"dojo\/_firebug\/firebug","url":"\/home\/arian\/www\/MooTools\/dojo\/_firebug\/firebug.js","package":"dojo","amd":true,"content":"define([\"..\/_base\/kernel\", \"require\", \"..\/_base\/html\", \"..\/_base\/sniff\", \"..\/_base\/array\", \"..\/_base\/lang\", \"..\/_base\/event\", \"..\/_base\/unload\"], function(dojo, require) {\n\t\/\/ module:\n\t\/\/\t\tdojo\/_firebug\/firebug\n\t\/\/ summary:\n\n\/\/ FIREBUG LITE\n\t\/\/ summary: Firebug Lite, the baby brother to Joe Hewitt's Firebug for Mozilla Firefox\n\t\/\/ description:\n\t\/\/\t\tOpens a console for logging, debugging, and error messages.\n\t\/\/\t\tContains partial functionality to Firebug. See function list below.\n\t\/\/\tNOTE:\n\t\/\/\t\t\tFirebug is a Firefox extension created by Joe Hewitt (see license). You do not need Dojo to run Firebug.\n\t\/\/\t\t\tFirebug Lite is included in Dojo by permission from Joe Hewitt\n\t\/\/\t\t\tIf you are new to Firebug, or used to the Dojo 0.4 dojo.debug, you can learn Firebug\n\t\/\/\t\t\t\tfunctionality by reading the function comments below or visiting http:\/\/www.getfirebug.com\/docs.html\n\t\/\/\tNOTE:\n\t\/\/\t\tTo test Firebug Lite in Firefox:\n\t\/\/\t\t\tFF2: set \"console = null\" before loading dojo and set djConfig.isDebug=true\n\t\/\/\t\t\tFF3: disable Firebug and set djConfig.isDebug=true\n\t\/\/\n\t\/\/ example:\n\t\/\/\t\tSupports inline objects in object inspector window (only simple trace of dom nodes, however)\n\t\/\/\t\t|\tconsole.log(\"my object\", {foo:\"bar\"})\n\t\/\/ example:\n\t\/\/\t\tOption for console to open in popup window\n\t\/\/\t\t|\tvar djConfig = {isDebug: true, popup:true };\n\t\/\/ example:\n\t\/\/\t\tOption for console height (ignored for popup)\n\t\/\/\t\t|\tvar djConfig = {isDebug: true, debugHeight:100 }\n\n\n\tvar isNewIE = (\/Trident\/.test(window.navigator.userAgent));\n\tif(isNewIE){\n\t\t\/\/ Fixing IE's console\n\t\t\/\/ IE doesn't insert space between arguments. How annoying.\n\t\tvar calls = [\"log\", \"info\", \"debug\", \"warn\", \"error\"];\n\t\tfor(var i=0;i<calls.length;i++){\n\t\t\tvar m = calls[i];\n\t\t\tif(!console[m] ||console[m]._fake){\n\t\t\t\t\/\/ IE9 doesn't have console.debug method, a fake one is added later\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar n = \"_\"+calls[i];\n\t\t\tconsole[n] = console[m];\n\t\t\tconsole[m] = (function(){\n\t\t\t\tvar type = n;\n\t\t\t\treturn function(){\n\t\t\t\t\tconsole[type](Array.prototype.join.call(arguments, \" \"));\n\t\t\t\t};\n\t\t\t})();\n\t\t}\n\t\t\/\/ clear the console on load. This is more than a convenience - too many logs crashes it.\n\t\t\/\/ If closed it throws an error\n\t\ttry{ console.clear(); }catch(e){}\n\t}\n\n\tif(\n\t\tdojo.isFF ||\t\t\t\t\t\t\t\t\/\/ Firefox has Firebug\n\t\tdojo.isChrome ||\t\t\t\t\t\t\t\/\/ Chrome 3+ has a console\n\t\tdojo.isSafari ||\t\t\t\t\t\t\t\/\/ Safari 4 has a console\n\t\tisNewIE ||\t\t\t\t\t\t\t\t\t\/\/ Has the new IE console\n\t\twindow.firebug ||\t\t\t\t\t\t\t\/\/ Testing for mozilla firebug lite\n\t\t(typeof console != \"undefined\" && console.firebug) || \/\/The firebug console\n\t\tdojo.config.useCustomLogger ||\t\t\t\t\/\/ Allow custom loggers\n\t\tdojo.isAIR\t\t\t\t\t\t\t\t\t\/\/ isDebug triggers AIRInsector, not Firebug\n\t){\n\t\treturn;\n\t}\n\n\t\/\/ don't build firebug in iframes\n\ttry{\n\t\tif(window != window.parent){\n\t\t\t\/\/ but if we've got a parent logger, connect to it\n\t\t\tif(window.parent[\"console\"]){\n\t\t\t\twindow.console = window.parent.console;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}catch(e){\/*squelch*\/}\n\n\t\/\/ ***************************************************************************\n\t\/\/ Placing these variables before the functions that use them to avoid a\n\t\/\/ shrinksafe bug where variable renaming does not happen correctly otherwise.\n\n\t\/\/ most of the objects in this script are run anonomously\n\tvar _firebugDoc = document;\n\tvar _firebugWin = window;\n\tvar __consoleAnchorId__ = 0;\n\n\tvar consoleFrame = null;\n\tvar consoleBody = null;\n\tvar consoleObjectInspector = null;\n\tvar fireBugTabs = null;\n\tvar commandLine = null;\n\tvar consoleToolbar = null;\n\n\tvar frameVisible = false;\n\tvar messageQueue = [];\n\tvar groupStack = [];\n\tvar timeMap = {};\n\tvar countMap = {};\n\n\tvar consoleDomInspector = null;\n\tvar _inspectionMoveConnection;\n\tvar _inspectionClickConnection;\n\tvar _inspectionEnabled = false;\n\tvar _inspectionTimer = null;\n\tvar _inspectTempNode = document.createElement(\"div\");\n\n\n\tvar _inspectCurrentNode;\n\tvar _restoreBorderStyle;\n\n\t\/\/ ***************************************************************************\n\n\twindow.console = {\n\t\t_connects: [],\n\t\tlog: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tSends arguments to console.\n\t\t\tlogFormatted(arguments, \"\");\n\t\t},\n\n\t\tdebug: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tSends arguments to console. Missing finctionality to show script line of trace.\n\t\t\tlogFormatted(arguments, \"debug\");\n\t\t},\n\n\t\tinfo: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tSends arguments to console, highlighted with (I) icon.\n\t\t\tlogFormatted(arguments, \"info\");\n\t\t},\n\n\t\twarn: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tSends warning arguments to console, highlighted with (!) icon and blue style.\n\t\t\tlogFormatted(arguments, \"warning\");\n\t\t},\n\n\t\terror: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tSends error arguments (object) to console, highlighted with (X) icon and yellow style\n\t\t\t\/\/\t\t\tNEW: error object now displays in object inspector\n\t\t\tlogFormatted(arguments, \"error\");\n\t\t},\n\n\t\tassert: function(truth, message){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tTests for true. Throws exception if false.\n\t\t\tif(!truth){\n\t\t\t\tvar args = [];\n\t\t\t\tfor(var i = 1; i < arguments.length; ++i){\n\t\t\t\t\targs.push(arguments[i]);\n\t\t\t\t}\n\n\t\t\t\tlogFormatted(args.length ? args : [\"Assertion Failure\"], \"error\");\n\t\t\t\tthrow message ? message : \"Assertion Failure\";\n\t\t\t}\n\t\t},\n\n\t\tdir: function(obj){\n\t\t\tvar str = printObject( obj );\n\t\t\tstr = str.replace(\/\\n\/g, \"<br \/>\");\n\t\t\tstr = str.replace(\/\\t\/g, \"&nbsp;&nbsp;&nbsp;&nbsp;\");\n\t\t\tlogRow([str], \"dir\");\n\t\t},\n\n\t\tdirxml: function(node){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\n\t\t\tvar html = [];\n\t\t\tappendNode(node, html);\n\t\t\tlogRow(html, \"dirxml\");\n\t\t},\n\n\t\tgroup: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tcollects log messages into a group, starting with this call and ending with\n\t\t\t\/\/\t\t\tgroupEnd(). Missing collapse functionality\n\t\t\tlogRow(arguments, \"group\", pushGroup);\n\t\t},\n\n\t\tgroupEnd: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tCloses group. See above\n\t\t\tlogRow(arguments, \"\", popGroup);\n\t\t},\n\n\t\ttime: function(name){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tStarts timers assigned to name given in argument. Timer stops and displays on timeEnd(title);\n\t\t\t\/\/\texample:\n\t\t\t\/\/\t|\tconsole.time(\"load\");\n\t\t\t\/\/\t|\tconsole.time(\"myFunction\");\n\t\t\t\/\/\t|\tconsole.timeEnd(\"load\");\n\t\t\t\/\/\t|\tconsole.timeEnd(\"myFunction\");\n\t\t\ttimeMap[name] = new Date().getTime();\n\t\t},\n\n\t\ttimeEnd: function(name){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tSee above.\n\t\t\tif(name in timeMap){\n\t\t\t\tvar delta = (new Date()).getTime() - timeMap[name];\n\t\t\t\tlogFormatted([name+ \":\", delta+\"ms\"]);\n\t\t\t\tdelete timeMap[name];\n\t\t\t}\n\t\t},\n\n\t\tcount: function(name){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tNot supported\n\t\t\tif(!countMap[name]) countMap[name] = 0;\n\t\t\tcountMap[name]++;\n\t\t\tlogFormatted([name+\": \"+countMap[name]]);\n\t\t},\n\n\t\ttrace: function(_value){\n\t\t\tvar stackAmt = _value || 3;\n\t\t\tvar f = console.trace.caller; \/\/function that called trace\n\t\t\tconsole.log(\">>> console.trace(stack)\");\n\t\t\tfor(var i=0;i<stackAmt;i++){\n\t\t\t\tvar func = f.toString();\n\t\t\t\tvar args=[];\n\t\t\t\tfor (var a = 0; a < f.arguments.length; a++) {\n\t\t\t\t\targs.push(f.arguments[a]);\n\t\t\t\t}\n\t\t\t\tif(f.arguments.length){\n\t\t\t\t\tconsole.dir({\"function\":func, \"arguments\":args});\n\t\t\t\t}else{\n\t\t\t\t\tconsole.dir({\"function\":func});\n\t\t\t\t}\n\n\t\t\t\tf = f.caller;\n\t\t\t}\n\t\t},\n\n\t\tprofile: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tNot supported\n\t\t\tthis.warn([\"profile() not supported.\"]);\n\t\t},\n\n\t\tprofileEnd: function(){ },\n\n\t\tclear: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tClears message console. Do not call this directly\n\t\t\tif(consoleBody){\n\t\t\t\twhile(consoleBody.childNodes.length){\n\t\t\t\t\tdojo.destroy(consoleBody.firstChild);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdojo.forEach(this._connects,dojo.disconnect);\n\t\t},\n\n\t\topen: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tOpens message console. Do not call this directly\n\t\t\ttoggleConsole(true);\n\t\t},\n\n\t\tclose: function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tCloses message console. Do not call this directly\n\t\t\tif(frameVisible){\n\t\t\t\ttoggleConsole();\n\t\t\t}\n\t\t},\n\t\t_restoreBorder: function(){\n\t\t\tif(_inspectCurrentNode){\n\t\t\t\t_inspectCurrentNode.style.border = _restoreBorderStyle;\n\t\t\t}\n\t\t},\n\t\topenDomInspector: function(){\n\t\t\t_inspectionEnabled = true;\n\t\t\tconsoleBody.style.display = \"none\";\n\t\t\tconsoleDomInspector.style.display = \"block\";\n\t\t\tconsoleObjectInspector.style.display = \"none\";\n\t\t\tdocument.body.style.cursor = \"pointer\";\n\t\t\t_inspectionMoveConnection = dojo.connect(document, \"mousemove\", function(evt){\n\t\t\t\tif(!_inspectionEnabled){ return; }\n\t\t\t\tif(!_inspectionTimer){\n\t\t\t\t\t_inspectionTimer = setTimeout(function(){ _inspectionTimer = null; }, 50);\n\t\t\t\t}else{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar node = evt.target;\n\t\t\t\tif(node && (_inspectCurrentNode !== node)){\n\t\t\t\t\tvar parent = true;\n\n\t\t\t\t\tconsole._restoreBorder();\n\t\t\t\t\tvar html = [];\n\t\t\t\t\tappendNode(node, html);\n\t\t\t\t\tconsoleDomInspector.innerHTML = html.join(\"\");\n\n\t\t\t\t\t_inspectCurrentNode = node;\n\t\t\t\t\t_restoreBorderStyle = _inspectCurrentNode.style.border;\n\t\t\t\t\t_inspectCurrentNode.style.border = \"#0000FF 1px solid\";\n\t\t\t\t}\n\t\t\t});\n\t\t\tsetTimeout(function(){\n\t\t\t\t_inspectionClickConnection = dojo.connect(document, \"click\", function(evt){\n\t\t\t\t\tdocument.body.style.cursor = \"\";\n\t\t\t\t\t_inspectionEnabled = !_inspectionEnabled;\n\t\t\t\t\tdojo.disconnect(_inspectionClickConnection);\n\t\t\t\t\t\/\/ console._restoreBorder();\n\t\t\t\t});\n\t\t\t}, 30);\n\t\t},\n\t\t_closeDomInspector: function(){\n\t\t\tdocument.body.style.cursor = \"\";\n\t\t\tdojo.disconnect(_inspectionMoveConnection);\n\t\t\tdojo.disconnect(_inspectionClickConnection);\n\t\t\t_inspectionEnabled = false;\n\t\t\tconsole._restoreBorder();\n\t\t},\n\t\topenConsole:function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tCloses object inspector and opens message console. Do not call this directly\n\t\t\tconsoleBody.style.display = \"block\";\n\t\t\tconsoleDomInspector.style.display = \"none\";\n\t\t\tconsoleObjectInspector.style.display = \"none\";\n\t\t\tconsole._closeDomInspector();\n\t\t},\n\t\topenObjectInspector:function(){\n\t\t\tconsoleBody.style.display = \"none\";\n\t\t\tconsoleDomInspector.style.display = \"none\";\n\t\t\tconsoleObjectInspector.style.display = \"block\";\n\t\t\tconsole._closeDomInspector();\n\t\t},\n\t\trecss: function(){\n\t\t\t\/\/ http:\/\/turtle.dojotoolkit.org\/~david\/recss.html\n\t\t\t\/\/ this is placed in dojo since the console is most likely\n\t\t\t\/\/ in another window and dojo is easilly accessible\n\t\t\tvar i,a,s;a=document.getElementsByTagName('link');\n\t\t\tfor(i=0;i<a.length;i++){\n\t\t\t\ts=a[i];\n\t\t\t\tif(s.rel.toLowerCase().indexOf('stylesheet')>=0&&s.href) {\n\t\t\t\t\tvar h=s.href.replace(\/(&|%5C?)forceReload=\\d+\/,'');\n\t\t\t\t\ts.href=h+(h.indexOf('?')>=0?'&':'?')+'forceReload='+new Date().valueOf();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t\/\/ ***************************************************************************\n\n\tfunction toggleConsole(forceOpen){\n\t\tframeVisible = forceOpen || !frameVisible;\n\t\tif(consoleFrame){\n\t\t\tconsoleFrame.style.display = frameVisible ? \"block\" : \"none\";\n\t\t}\n\t}\n\n\tfunction focusCommandLine(){\n\t\ttoggleConsole(true);\n\t\tif(commandLine){\n\t\t\tcommandLine.focus();\n\t\t}\n\t}\n\n\tfunction openWin(x,y,w,h){\n\t\tvar win = window.open(\"\",\"_firebug\",\"status=0,menubar=0,resizable=1,top=\"+y+\",left=\"+x+\",width=\"+w+\",height=\"+h+\",scrollbars=1,addressbar=0\");\n\t\tif(!win){\n\t\t\tvar msg = \"Firebug Lite could not open a pop-up window, most likely because of a blocker.\\n\" +\n\t\t\t\t\"Either enable pop-ups for this domain, or change the djConfig to popup=false.\";\n\t\t\talert(msg);\n\t\t}\n\t\tcreateResizeHandler(win);\n\t\tvar newDoc=win.document;\n\t\t\/\/Safari needs an HTML height\n\t\tvar HTMLstring=\t'<html style=\"height:100%;\"><head><title>Firebug Lite<\/title><\/head>\\n' +\n\t\t\t\t\t'<body bgColor=\"#ccc\" style=\"height:97%;\" onresize=\"opener.onFirebugResize()\">\\n' +\n\t\t\t\t\t'<div id=\"fb\"><\/div>' +\n\t\t\t\t\t'<\/body><\/html>';\n\n\t\tnewDoc.write(HTMLstring);\n\t\tnewDoc.close();\n\t\treturn win;\n\t}\n\n\tfunction createResizeHandler(wn){\n\t\t\/\/ summary:\n\t\t\/\/\t\tCreates handle for onresize window. Called from script in popup's body tag (so that it will work with IE).\n\t\t\/\/\n\n\t\tvar d = new Date();\n\t\t\td.setTime(d.getTime()+(60*24*60*60*1000)); \/\/ 60 days\n\t\t\td = d.toUTCString();\n\n\t\t\tvar dc = wn.document,\n\t\t\t\tgetViewport;\n\n\t\t\tif (wn.innerWidth){\n\t\t\t\tgetViewport = function(){\n\t\t\t\t\treturn{w:wn.innerWidth, h:wn.innerHeight};\n\t\t\t\t};\n\t\t\t}else if (dc.documentElement && dc.documentElement.clientWidth){\n\t\t\t\tgetViewport = function(){\n\t\t\t\t\treturn{w:dc.documentElement.clientWidth, h:dc.documentElement.clientHeight};\n\t\t\t\t};\n\t\t\t}else if (dc.body){\n\t\t\t\tgetViewport = function(){\n\t\t\t\t\treturn{w:dc.body.clientWidth, h:dc.body.clientHeight};\n\t\t\t\t};\n\t\t\t}\n\n\n\t\twindow.onFirebugResize = function(){\n\n\t\t\t\/\/resize the height of the console log body\n\t\t\tlayout(getViewport().h);\n\n\t\t\tclearInterval(wn._firebugWin_resize);\n\t\t\twn._firebugWin_resize = setTimeout(function(){\n\t\t\t\tvar x = wn.screenLeft,\n\t\t\t\t\ty = wn.screenTop,\n\t\t\t\t\tw = wn.outerWidth  || wn.document.body.offsetWidth,\n\t\t\t\t\th = wn.outerHeight || wn.document.body.offsetHeight;\n\n\t\t\t\tdocument.cookie = \"_firebugPosition=\" + [x,y,w,h].join(\",\") + \"; expires=\"+d+\"; path=\/\";\n\n\t\t\t }, 5000); \/\/can't capture window.onMove - long timeout gives better chance of capturing a resize, then the move\n\n\t\t};\n\t}\n\n\n\t\/*****************************************************************************\/\n\n\n\tfunction createFrame(){\n\t\tif(consoleFrame){\n\t\t\treturn;\n\t\t}\n\t\ttoggleConsole(true);\n\t\tif(dojo.config.popup){\n\t\t\tvar containerHeight = \"100%\";\n\t\t\tvar cookieMatch = document.cookie.match(\/(?:^|; )_firebugPosition=([^;]*)\/);\n\t\t\tvar p = cookieMatch ? cookieMatch[1].split(\",\") : [2,2,320,480];\n\n\t\t\t_firebugWin = openWin(p[0],p[1],p[2],p[3]);\t\/\/ global\n\t\t\t_firebugDoc = _firebugWin.document;\t\t\t\/\/ global\n\n\t\t\tdojo.config.debugContainerId = 'fb';\n\n\t\t\t\/\/ connecting popup\n\t\t\t_firebugWin.console = window.console;\n\t\t\t_firebugWin.dojo = window.dojo;\n\t\t}else{\n\t\t\t_firebugDoc = document;\n\t\t\tcontainerHeight = (dojo.config.debugHeight || 300) + \"px\";\n\t\t}\n\n\t\tvar styleElement = _firebugDoc.createElement(\"link\");\n\t\tstyleElement.href = require.toUrl(\".\/firebug.css\");\n\t\tstyleElement.rel = \"stylesheet\";\n\t\tstyleElement.type = \"text\/css\";\n\t\tvar styleParent = _firebugDoc.getElementsByTagName(\"head\");\n\t\tif(styleParent){\n\t\t\tstyleParent = styleParent[0];\n\t\t}\n\t\tif(!styleParent){\n\t\t\tstyleParent = _firebugDoc.getElementsByTagName(\"html\")[0];\n\t\t}\n\t\tif(dojo.isIE){\n\t\t\twindow.setTimeout(function(){ styleParent.appendChild(styleElement); }, 0);\n\t\t}else{\n\t\t\tstyleParent.appendChild(styleElement);\n\t\t}\n\n\t\tif(dojo.config.debugContainerId){\n\t\t\tconsoleFrame = _firebugDoc.getElementById(dojo.config.debugContainerId);\n\t\t}\n\t\tif(!consoleFrame){\n\t\t\tconsoleFrame = _firebugDoc.createElement(\"div\");\n\t\t\t_firebugDoc.body.appendChild(consoleFrame);\n\t\t}\n\t\tconsoleFrame.className += \" firebug\";\n\t\tconsoleFrame.style.height = containerHeight;\n\t\tconsoleFrame.style.display = (frameVisible ? \"block\" : \"none\");\n\n\t\tvar buildLink = function(label, title, method, _class){\n\t\t\treturn '<li class=\"'+_class+'\"><a href=\"javascript:void(0);\" onclick=\"console.'+ method +'(); return false;\" title=\"'+title+'\">'+label+'<\/a><\/li>';\n\t\t};\n\t\tconsoleFrame.innerHTML =\n\t\t\t  '<div id=\"firebugToolbar\">'\n\t\t\t+ '  <ul id=\"fireBugTabs\" class=\"tabs\">'\n\n\t\t\t+ buildLink(\"Clear\", \"Remove All Console Logs\", \"clear\", \"\")\n\t\t\t+ buildLink(\"ReCSS\", \"Refresh CSS without reloading page\", \"recss\", \"\")\n\n\t\t\t+ buildLink(\"Console\", \"Show Console Logs\", \"openConsole\", \"gap\")\n\t\t\t+ buildLink(\"DOM\", \"Show DOM Inspector\", \"openDomInspector\", \"\")\n\t\t\t+ buildLink(\"Object\", \"Show Object Inspector\", \"openObjectInspector\", \"\")\n\t\t\t+ ((dojo.config.popup) ? \"\" : buildLink(\"Close\", \"Close the console\", \"close\", \"gap\"))\n\n\t\t\t+ '\t<\/ul>'\n\t\t\t+ '<\/div>'\n\t\t\t+ '<input type=\"text\" id=\"firebugCommandLine\" \/>'\n\t\t\t+ '<div id=\"firebugLog\"><\/div>'\n\t\t\t+ '<div id=\"objectLog\" style=\"display:none;\">Click on an object in the Log display<\/div>'\n\t\t\t+ '<div id=\"domInspect\" style=\"display:none;\">Hover over HTML elements in the main page. Click to hold selection.<\/div>';\n\n\n\t\tconsoleToolbar = _firebugDoc.getElementById(\"firebugToolbar\");\n\n\t\tcommandLine = _firebugDoc.getElementById(\"firebugCommandLine\");\n\t\taddEvent(commandLine, \"keydown\", onCommandLineKeyDown);\n\n\t\taddEvent(_firebugDoc, dojo.isIE || dojo.isSafari ? \"keydown\" : \"keypress\", onKeyDown);\n\n\t\tconsoleBody = _firebugDoc.getElementById(\"firebugLog\");\n\t\tconsoleObjectInspector = _firebugDoc.getElementById(\"objectLog\");\n\t\tconsoleDomInspector = _firebugDoc.getElementById(\"domInspect\");\n\t\tfireBugTabs = _firebugDoc.getElementById(\"fireBugTabs\");\n\t\tlayout();\n\t\tflush();\n\t}\n\n\tdojo.addOnLoad(createFrame);\n\n\tfunction clearFrame(){\n\t\t_firebugDoc = null;\n\n\t\tif(_firebugWin.console){\n\t\t\t_firebugWin.console.clear();\n\t\t}\n\t\t_firebugWin = null;\n\t\tconsoleFrame = null;\n\t\tconsoleBody = null;\n\t\tconsoleObjectInspector = null;\n\t\tconsoleDomInspector = null;\n\t\tcommandLine = null;\n\t\tmessageQueue = [];\n\t\tgroupStack = [];\n\t\ttimeMap = {};\n\t}\n\n\n\tfunction evalCommandLine(){\n\t\tvar text = commandLine.value;\n\t\tcommandLine.value = \"\";\n\n\t\tlogRow([\">  \", text], \"command\");\n\n\t\tvar value;\n\t\ttry{\n\t\t\tvalue = eval(text);\n\t\t}catch(e){\n\t\t\tconsole.debug(e); \/\/ put exception on the console\n\t\t}\n\n\t\tconsole.log(value);\n\t}\n\n\tfunction layout(h){\n\t\tvar tHeight = 25; \/\/consoleToolbar.offsetHeight; \/\/ tab style not ready on load - throws off layout\n\t\tvar height = h ?\n\t\t\th  - (tHeight + commandLine.offsetHeight +25 + (h*.01)) + \"px\" :\n\t\t\t(consoleFrame.offsetHeight - tHeight - commandLine.offsetHeight) + \"px\";\n\n\t\tconsoleBody.style.top = tHeight + \"px\";\n\t\tconsoleBody.style.height = height;\n\t\tconsoleObjectInspector.style.height = height;\n\t\tconsoleObjectInspector.style.top = tHeight + \"px\";\n\t\tconsoleDomInspector.style.height = height;\n\t\tconsoleDomInspector.style.top = tHeight + \"px\";\n\t\tcommandLine.style.bottom = 0;\n\n\t\tdojo.addOnWindowUnload(clearFrame);\n\t}\n\n\tfunction logRow(message, className, handler){\n\t\tif(consoleBody){\n\t\t\twriteMessage(message, className, handler);\n\t\t}else{\n\t\t\tmessageQueue.push([message, className, handler]);\n\t\t}\n\t}\n\n\tfunction flush(){\n\t\tvar queue = messageQueue;\n\t\tmessageQueue = [];\n\n\t\tfor(var i = 0; i < queue.length; ++i){\n\t\t\twriteMessage(queue[i][0], queue[i][1], queue[i][2]);\n\t\t}\n\t}\n\n\tfunction writeMessage(message, className, handler){\n\t\tvar isScrolledToBottom =\n\t\t\tconsoleBody.scrollTop + consoleBody.offsetHeight >= consoleBody.scrollHeight;\n\n\t\thandler = handler||writeRow;\n\n\t\thandler(message, className);\n\n\t\tif(isScrolledToBottom){\n\t\t\tconsoleBody.scrollTop = consoleBody.scrollHeight - consoleBody.offsetHeight;\n\t\t}\n\t}\n\n\tfunction appendRow(row){\n\t\tvar container = groupStack.length ? groupStack[groupStack.length-1] : consoleBody;\n\t\tcontainer.appendChild(row);\n\t}\n\n\tfunction writeRow(message, className){\n\t\tvar row = consoleBody.ownerDocument.createElement(\"div\");\n\t\trow.className = \"logRow\" + (className ? \" logRow-\"+className : \"\");\n\t\trow.innerHTML = message.join(\"\");\n\t\tappendRow(row);\n\t}\n\n\tfunction pushGroup(message, className){\n\t\tlogFormatted(message, className);\n\n\t\t\/\/var groupRow = consoleBody.ownerDocument.createElement(\"div\");\n\t\t\/\/groupRow.className = \"logGroup\";\n\t\tvar groupRowBox = consoleBody.ownerDocument.createElement(\"div\");\n\t\tgroupRowBox.className = \"logGroupBox\";\n\t\t\/\/groupRow.appendChild(groupRowBox);\n\t\tappendRow(groupRowBox);\n\t\tgroupStack.push(groupRowBox);\n\t}\n\n\tfunction popGroup(){\n\t\tgroupStack.pop();\n\t}\n\n\t\/\/ ***************************************************************************\n\n\tfunction logFormatted(objects, className){\n\t\tvar html = [];\n\n\t\tvar format = objects[0];\n\t\tvar objIndex = 0;\n\n\t\tif(typeof(format) != \"string\"){\n\t\t\tformat = \"\";\n\t\t\tobjIndex = -1;\n\t\t}\n\n\t\tvar parts = parseFormat(format);\n\n\t\tfor(var i = 0; i < parts.length; ++i){\n\t\t\tvar part = parts[i];\n\t\t\tif(part && typeof part == \"object\"){\n\t\t\t\tpart.appender(objects[++objIndex], html);\n\t\t\t}else{\n\t\t\t\tappendText(part, html);\n\t\t\t}\n\t\t}\n\n\n\t\tvar ids = [];\n\t\tvar obs = [];\n\t\tfor(i = objIndex+1; i < objects.length; ++i){\n\t\t\tappendText(\" \", html);\n\n\t\t\tvar object = objects[i];\n\t\t\tif(object === undefined || object === null ){\n\t\t\t\tappendNull(object, html);\n\n\t\t\t}else if(typeof(object) == \"string\"){\n\t\t\t\tappendText(object, html);\n\n\t\t\t}else if(object instanceof Date){\n\t\t\t\tappendText(object.toString(), html);\n\n\t\t\t}else if(object.nodeType == 9){\n\t\t\t\tappendText(\"[ XmlDoc ]\", html);\n\n\t\t\t}else{\n\t\t\t\t\/\/ Create link for object inspector\n\t\t\t\t\/\/ need to create an ID for this link, since it is currently text\n\t\t\t\tvar id = \"_a\" + __consoleAnchorId__++;\n\t\t\t\tids.push(id);\n\t\t\t\t\/\/ need to save the object, so the arrays line up\n\t\t\t\tobs.push(object);\n\t\t\t\tvar str = '<a id=\"'+id+'\" href=\"javascript:void(0);\">'+getObjectAbbr(object)+'<\/a>';\n\n\t\t\t\tappendLink( str , html);\n\t\t\t}\n\t\t}\n\n\t\tlogRow(html, className);\n\n\t\t\/\/ Now that the row is inserted in the DOM, loop through all of the links that were just created\n\t\tfor(i=0; i<ids.length; i++){\n\t\t\tvar btn = _firebugDoc.getElementById(ids[i]);\n\t\t\tif(!btn){ continue; }\n\n\t\t\t\/\/ store the object in the dom btn for reference later\n\t\t\t\/\/ avoid parsing these objects unless necessary\n\t\t\tbtn.obj = obs[i];\n\n\t\t\t_firebugWin.console._connects.push(dojo.connect(btn, \"onclick\", function(){\n\n\t\t\t\tconsole.openObjectInspector();\n\n\t\t\t\ttry{\n\t\t\t\t\tprintObject(this.obj);\n\t\t\t\t}catch(e){\n\t\t\t\t\tthis.obj = e;\n\t\t\t\t}\n\t\t\t\tconsoleObjectInspector.innerHTML = \"<pre>\" + printObject( this.obj ) + \"<\/pre>\";\n\t\t\t}));\n\t\t}\n\t}\n\n\tfunction parseFormat(format){\n\t\tvar parts = [];\n\n\t\tvar reg = \/((^%|[^\\\\]%)(\\d+)?(\\.)([a-zA-Z]))|((^%|[^\\\\]%)([a-zA-Z]))\/;\n\t\tvar appenderMap = {s: appendText, d: appendInteger, i: appendInteger, f: appendFloat};\n\n\t\tfor(var m = reg.exec(format); m; m = reg.exec(format)){\n\t\t\tvar type = m[8] ? m[8] : m[5];\n\t\t\tvar appender = type in appenderMap ? appenderMap[type] : appendObject;\n\t\t\tvar precision = m[3] ? parseInt(m[3]) : (m[4] == \".\" ? -1 : 0);\n\n\t\t\tparts.push(format.substr(0, m[0][0] == \"%\" ? m.index : m.index+1));\n\t\t\tparts.push({appender: appender, precision: precision});\n\n\t\t\tformat = format.substr(m.index+m[0].length);\n\t\t}\n\n\t\tparts.push(format);\n\n\t\treturn parts;\n\t}\n\n\tfunction escapeHTML(value){\n\t\tfunction replaceChars(ch){\n\t\t\tswitch(ch){\n\t\t\t\tcase \"<\":\n\t\t\t\t\treturn \"&lt;\";\n\t\t\t\tcase \">\":\n\t\t\t\t\treturn \"&gt;\";\n\t\t\t\tcase \"&\":\n\t\t\t\t\treturn \"&amp;\";\n\t\t\t\tcase \"'\":\n\t\t\t\t\treturn \"&#39;\";\n\t\t\t\tcase '\"':\n\t\t\t\t\treturn \"&quot;\";\n\t\t\t}\n\t\t\treturn \"?\";\n\t\t}\n\t\treturn String(value).replace(\/[<>&\"']\/g, replaceChars);\n\t}\n\n\tfunction objectToString(object){\n\t\ttry{\n\t\t\treturn object+\"\";\n\t\t}catch(e){\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t\/\/ ***************************************************************************\n\tfunction appendLink(object, html){\n\t\t\/\/ needed for object links - no HTML escaping\n\t\thtml.push( objectToString(object) );\n\t}\n\n\tfunction appendText(object, html){\n\t\thtml.push(escapeHTML(objectToString(object)));\n\t}\n\n\tfunction appendNull(object, html){\n\t\thtml.push('<span class=\"objectBox-null\">', escapeHTML(objectToString(object)), '<\/span>');\n\t}\n\n\tfunction appendString(object, html){\n\t\thtml.push('<span class=\"objectBox-string\">&quot;', escapeHTML(objectToString(object)),\n\t\t\t'&quot;<\/span>');\n\t}\n\n\tfunction appendInteger(object, html){\n\t\thtml.push('<span class=\"objectBox-number\">', escapeHTML(objectToString(object)), '<\/span>');\n\t}\n\n\tfunction appendFloat(object, html){\n\t\thtml.push('<span class=\"objectBox-number\">', escapeHTML(objectToString(object)), '<\/span>');\n\t}\n\n\tfunction appendFunction(object, html){\n\t\thtml.push('<span class=\"objectBox-function\">', getObjectAbbr(object), '<\/span>');\n\t}\n\n\tfunction appendObject(object, html){\n\t\ttry{\n\t\t\tif(object === undefined){\n\t\t\t\tappendNull(\"undefined\", html);\n\t\t\t}else if(object === null){\n\t\t\t\tappendNull(\"null\", html);\n\t\t\t}else if(typeof object == \"string\"){\n\t\t\t\tappendString(object, html);\n\t\t\t}else if(typeof object == \"number\"){\n\t\t\t\tappendInteger(object, html);\n\t\t\t}else if(typeof object == \"function\"){\n\t\t\t\tappendFunction(object, html);\n\t\t\t}else if(object.nodeType == 1){\n\t\t\t\tappendSelector(object, html);\n\t\t\t}else if(typeof object == \"object\"){\n\t\t\t\tappendObjectFormatted(object, html);\n\t\t\t}else{\n\t\t\t\tappendText(object, html);\n\t\t\t}\n\t\t}catch(e){\n\t\t\t\/* squelch *\/\n\t\t}\n\t}\n\n\tfunction appendObjectFormatted(object, html){\n\t\tvar text = objectToString(object);\n\t\tvar reObject = \/\\[object (.*?)\\]\/;\n\n\t\tvar m = reObject.exec(text);\n\t\thtml.push('<span class=\"objectBox-object\">', m ? m[1] : text, '<\/span>');\n\t}\n\n\tfunction appendSelector(object, html){\n\t\thtml.push('<span class=\"objectBox-selector\">');\n\n\t\thtml.push('<span class=\"selectorTag\">', escapeHTML(object.nodeName.toLowerCase()), '<\/span>');\n\t\tif(object.id){\n\t\t\thtml.push('<span class=\"selectorId\">#', escapeHTML(object.id), '<\/span>');\n\t\t}\n\t\tif(object.className){\n\t\t\thtml.push('<span class=\"selectorClass\">.', escapeHTML(object.className), '<\/span>');\n\t\t}\n\n\t\thtml.push('<\/span>');\n\t}\n\n\tfunction appendNode(node, html){\n\t\tif(node.nodeType == 1){\n\t\t\thtml.push(\n\t\t\t\t'<div class=\"objectBox-element\">',\n\t\t\t\t\t'&lt;<span class=\"nodeTag\">', node.nodeName.toLowerCase(), '<\/span>');\n\n\t\t\tfor(var i = 0; i < node.attributes.length; ++i){\n\t\t\t\tvar attr = node.attributes[i];\n\t\t\t\tif(!attr.specified){ continue; }\n\n\t\t\t\thtml.push('&nbsp;<span class=\"nodeName\">', attr.nodeName.toLowerCase(),\n\t\t\t\t\t'<\/span>=&quot;<span class=\"nodeValue\">', escapeHTML(attr.nodeValue),\n\t\t\t\t\t'<\/span>&quot;');\n\t\t\t}\n\n\t\t\tif(node.firstChild){\n\t\t\t\thtml.push('&gt;<\/div><div class=\"nodeChildren\">');\n\n\t\t\t\tfor(var child = node.firstChild; child; child = child.nextSibling){\n\t\t\t\t\tappendNode(child, html);\n\t\t\t\t}\n\n\t\t\t\thtml.push('<\/div><div class=\"objectBox-element\">&lt;\/<span class=\"nodeTag\">',\n\t\t\t\t\tnode.nodeName.toLowerCase(), '&gt;<\/span><\/div>');\n\t\t\t}else{\n\t\t\t\thtml.push('\/&gt;<\/div>');\n\t\t\t}\n\t\t}else if (node.nodeType == 3){\n\t\t\thtml.push('<div class=\"nodeText\">', escapeHTML(node.nodeValue),\n\t\t\t\t'<\/div>');\n\t\t}\n\t}\n\n\t\/\/ ***************************************************************************\n\n\tfunction addEvent(object, name, handler){\n\t\tif(document.all){\n\t\t\tobject.attachEvent(\"on\"+name, handler);\n\t\t}else{\n\t\t\tobject.addEventListener(name, handler, false);\n\t\t}\n\t}\n\n\tfunction removeEvent(object, name, handler){\n\t\tif(document.all){\n\t\t\tobject.detachEvent(\"on\"+name, handler);\n\t\t}else{\n\t\t\tobject.removeEventListener(name, handler, false);\n\t\t}\n\t}\n\n\tfunction cancelEvent(event){\n\t\tif(document.all){\n\t\t\tevent.cancelBubble = true;\n\t\t}else{\n\t\t\tevent.stopPropagation();\n\t\t}\n\t}\n\n\tfunction onError(msg, href, lineNo){\n\t\tvar lastSlash = href.lastIndexOf(\"\/\");\n\t\tvar fileName = lastSlash == -1 ? href : href.substr(lastSlash+1);\n\n\t\tvar html = [\n\t\t\t'<span class=\"errorMessage\">', msg, '<\/span>',\n\t\t\t'<div class=\"objectBox-sourceLink\">', fileName, ' (line ', lineNo, ')<\/div>'\n\t\t];\n\n\t\tlogRow(html, \"error\");\n\t}\n\n\n\t\/\/After converting to div instead of iframe, now getting two keydowns right away in IE 6.\n\t\/\/Make sure there is a little bit of delay.\n\tvar onKeyDownTime = new Date().getTime();\n\n\tfunction onKeyDown(event){\n\t\tvar timestamp = (new Date()).getTime();\n\t\tif(timestamp > onKeyDownTime + 200){\n\t\t\tevent = dojo.fixEvent(event);\n\t\t\tvar keys = dojo.keys;\n\t\t\tvar ekc = event.keyCode;\n\t\t\tonKeyDownTime = timestamp;\n\t\t\tif(ekc == keys.F12){\n\t\t\t\ttoggleConsole();\n\t\t\t}else if(\n\t\t\t\t(ekc == keys.NUMPAD_ENTER || ekc == 76) &&\n\t\t\t\tevent.shiftKey &&\n\t\t\t\t(event.metaKey || event.ctrlKey)\n\t\t\t){\n\t\t\t\tfocusCommandLine();\n\t\t\t}else{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcancelEvent(event);\n\t\t}\n\t}\n\n\tfunction onCommandLineKeyDown(e){\n\t\tvar dk = dojo.keys;\n\t\tif(e.keyCode == 13 && commandLine.value){\n\t\t\taddToHistory(commandLine.value);\n\t\t\tevalCommandLine();\n\t\t}else if(e.keyCode == 27){\n\t\t\tcommandLine.value = \"\";\n\t\t}else if(e.keyCode == dk.UP_ARROW || e.charCode == dk.UP_ARROW){\n\t\t\tnavigateHistory(\"older\");\n\t\t}else if(e.keyCode == dk.DOWN_ARROW || e.charCode == dk.DOWN_ARROW){\n\t\t\tnavigateHistory(\"newer\");\n\t\t}else if(e.keyCode == dk.HOME || e.charCode == dk.HOME){\n\t\t\thistoryPosition = 1;\n\t\t\tnavigateHistory(\"older\");\n\t\t}else if(e.keyCode == dk.END || e.charCode == dk.END){\n\t\t\thistoryPosition = 999999;\n\t\t\tnavigateHistory(\"newer\");\n\t\t}\n\t}\n\n\tvar historyPosition = -1;\n\tvar historyCommandLine = null;\n\n\tfunction addToHistory(value){\n\t\tvar history = cookie(\"firebug_history\");\n\t\thistory = (history) ? dojo.fromJson(history) : [];\n\t\tvar pos = dojo.indexOf(history, value);\n\t\tif (pos != -1){\n\t\t\thistory.splice(pos, 1);\n\t\t}\n\t\thistory.push(value);\n\t\tcookie(\"firebug_history\", dojo.toJson(history), 30);\n\t\twhile(history.length && !cookie(\"firebug_history\")){\n\t\t\thistory.shift();\n\t\t\tcookie(\"firebug_history\", dojo.toJson(history), 30);\n\t\t}\n\t\thistoryCommandLine = null;\n\t\thistoryPosition = -1;\n\t}\n\n\tfunction navigateHistory(direction){\n\t\tvar history = cookie(\"firebug_history\");\n\t\thistory = (history) ? dojo.fromJson(history) : [];\n\t\tif(!history.length){\n\t\t\treturn;\n\t\t}\n\n\t\tif(historyCommandLine === null){\n\t\t\thistoryCommandLine = commandLine.value;\n\t\t}\n\n\t\tif(historyPosition == -1){\n\t\t\thistoryPosition = history.length;\n\t\t}\n\n\t\tif(direction == \"older\"){\n\t\t\t--historyPosition;\n\t\t\tif(historyPosition < 0){\n\t\t\t\thistoryPosition = 0;\n\t\t\t}\n\t\t}else if(direction == \"newer\"){\n\t\t\t++historyPosition;\n\t\t\tif(historyPosition > history.length){\n\t\t\t\thistoryPosition = history.length;\n\t\t\t}\n\t\t}\n\n\t\tif(historyPosition == history.length){\n\t\t\tcommandLine.value = historyCommandLine;\n\t\t\thistoryCommandLine = null;\n\t\t}else{\n\t\t\tcommandLine.value = history[historyPosition];\n\t\t}\n\t}\n\n\tfunction cookie(name, value){\n\t\tvar c = document.cookie;\n\t\tif(arguments.length == 1){\n\t\t\tvar matches = c.match(new RegExp(\"(?:^|; )\" + name + \"=([^;]*)\"));\n\t\t\treturn matches ? decodeURIComponent(matches[1]) : undefined; \/\/ String or undefined\n\t\t}else{\n\t\t\tvar d = new Date();\n\t\t\td.setMonth(d.getMonth()+1);\n\t\t\tdocument.cookie = name + \"=\" + encodeURIComponent(value) + ((d.toUtcString) ? \"; expires=\" + d.toUTCString() : \"\");\n\t\t}\n\t}\n\n\tfunction isArray(it){\n\t\treturn it && it instanceof Array || typeof it == \"array\";\n\t}\n\n\t\/\/***************************************************************************************************\n\t\/\/ Print Object Helpers\n\tfunction objectLength(o){\n\t\tvar cnt = 0;\n\t\tfor(var nm in o){\n\t\t\tcnt++;\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tfunction printObject(o, i, txt, used){\n\t\t\/\/ Recursively trace object, indenting to represent depth for display in object inspector\n\t\tvar ind = \" \\t\";\n\t\ttxt = txt || \"\";\n\t\ti = i || ind;\n\t\tused = used || [];\n\t\tvar opnCls;\n\n\t\tif(o && o.nodeType == 1){\n\t\t\tvar html = [];\n\t\t\tappendNode(o, html);\n\t\t\treturn html.join(\"\");\n\t\t}\n\n\t\tvar br=\",\\n\", cnt = 0, length = objectLength(o);\n\n\t\tif(o instanceof Date){\n\t\t\treturn i + o.toString() + br;\n\t\t}\n\t\tlooking:\n\t\tfor(var nm in o){\n\t\t\tcnt++;\n\t\t\tif(cnt==length){br = \"\\n\";}\n\t\t\tif(o[nm] === window || o[nm] === document){\n\t\t\t\t\/\/ do nothing\n\t\t\t}else if(o[nm] === null){\n\t\t\t\ttxt += i+nm + \" : NULL\" + br;\n\t\t\t}else if(o[nm] && o[nm].nodeType){\n\t\t\t\tif(o[nm].nodeType == 1){\n\t\t\t\t\t\/\/txt += i+nm + \" : < \"+o[nm].tagName+\" id=\\\"\"+ o[nm].id+\"\\\" \/>\" + br;\n\t\t\t\t}else if(o[nm].nodeType == 3){\n\t\t\t\t\ttxt += i+nm + \" : [ TextNode \"+o[nm].data + \" ]\" + br;\n\t\t\t\t}\n\n\t\t\t}else if(typeof o[nm] == \"object\" && (o[nm] instanceof String || o[nm] instanceof Number || o[nm] instanceof Boolean)){\n\t\t\t\ttxt += i+nm + \" : \" + o[nm] + \",\" + br;\n\n\t\t\t}else if(o[nm] instanceof Date){\n\t\t\t\ttxt += i+nm + \" : \" + o[nm].toString() + br;\n\n\t\t\t}else if(typeof(o[nm]) == \"object\" && o[nm]){\n\t\t\t\tfor(var j = 0, seen; seen = used[j]; j++){\n\t\t\t\t\tif(o[nm] === seen){\n\t\t\t\t\t\ttxt += i+nm + \" : RECURSION\" + br;\n\t\t\t\t\t\tcontinue looking;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused.push(o[nm]);\n\n\t\t\t\topnCls = (isArray(o[nm]))?[\"[\",\"]\"]:[\"{\",\"}\"];\n\t\t\t\ttxt += i+nm +\" : \" + opnCls[0] + \"\\n\";\/\/non-standard break, (no comma)\n\t\t\t\ttxt += printObject(o[nm], i+ind, \"\", used);\n\t\t\t\ttxt += i + opnCls[1] + br;\n\n\t\t\t}else if(typeof o[nm] == \"undefined\"){\n\t\t\t\ttxt += i+nm + \" : undefined\" + br;\n\t\t\t}else if(nm == \"toString\" && typeof o[nm] == \"function\"){\n\t\t\t\tvar toString = o[nm]();\n\t\t\t\tif(typeof toString == \"string\" && toString.match(\/function ?(.*?)\\(\/)){\n\t\t\t\t\ttoString = escapeHTML(getObjectAbbr(o[nm]));\n\t\t\t\t}\n\t\t\t\ttxt += i+nm +\" : \" + toString + br;\n\t\t\t}else{\n\t\t\t\ttxt += i+nm +\" : \"+ escapeHTML(getObjectAbbr(o[nm])) + br;\n\t\t\t}\n\t\t}\n\t\treturn txt;\n\t}\n\n\tfunction getObjectAbbr(obj){\n\t\t\/\/ Gets an abbreviation of an object for display in log\n\t\t\/\/ X items in object, including id\n\t\t\/\/ X items in an array\n\t\t\/\/ TODO: Firebug Sr. actually goes by char count\n\t\tvar isError = (obj instanceof Error);\n\t\tif(obj.nodeType == 1){\n\t\t\treturn escapeHTML('< '+obj.tagName.toLowerCase()+' id=\\\"'+ obj.id+ '\\\" \/>');\n\t\t}\n\t\tif(obj.nodeType == 3){\n\t\t\treturn escapeHTML('[TextNode: \"'+obj.nodeValue+'\"]');\n\t\t}\n\t\tvar nm = (obj && (obj.id || obj.name || obj.ObjectID || obj.widgetId));\n\t\tif(!isError && nm){ return \"{\"+nm+\"}\";\t}\n\n\t\tvar obCnt = 2;\n\t\tvar arCnt = 4;\n\t\tvar cnt = 0;\n\n\t\tif(isError){\n\t\t\tnm = \"[ Error: \"+(obj.message || obj.description || obj)+\" ]\";\n\t\t}else if(isArray(obj)){\n\t\t\tnm = \"[\" + obj.slice(0,arCnt).join(\",\");\n\t\t\tif(obj.length > arCnt){\n\t\t\t\tnm += \" ... (\"+obj.length+\" items)\";\n\t\t\t}\n\t\t\tnm += \"]\";\n\t\t}else if(typeof obj == \"function\"){\n\t\t\tnm = obj + \"\";\n\t\t\tvar reg = \/function\\s*([^\\(]*)(\\([^\\)]*\\))[^\\{]*\\{\/;\n\t\t\tvar m = reg.exec(nm);\n\t\t\tif(m){\n\t\t\t\tif(!m[1]){\n\t\t\t\t\tm[1] = \"function\";\n\t\t\t\t}\n\t\t\t\tnm = m[1] + m[2];\n\t\t\t}else{\n\t\t\t\tnm = \"function()\";\n\t\t\t}\n\t\t}else if(typeof obj != \"object\" || typeof obj == \"string\"){\n\t\t\tnm = obj + \"\";\n\t\t}else{\n\t\t\tnm = \"{\";\n\t\t\tfor(var i in obj){\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt > obCnt){ break; }\n\t\t\t\tnm += i+\":\"+escapeHTML(obj[i])+\"  \";\n\t\t\t}\n\t\t\tnm+=\"}\";\n\t\t}\n\n\t\treturn nm;\n\t}\n\n\t\/\/*************************************************************************************\n\n\t\/\/window.onerror = onError;\n\n\taddEvent(document, dojo.isIE || dojo.isSafari ? \"keydown\" : \"keypress\", onKeyDown);\n\n\tif(\t(document.documentElement.getAttribute(\"debug\") == \"true\")||\n\t\t(dojo.config.isDebug)\n\t){\n\t\ttoggleConsole(true);\n\t}\n\n\tdojo.addOnWindowUnload(function(){\n\t\t\/\/ Erase the globals and event handlers I created, to prevent spurious leak warnings\n\t\tremoveEvent(document, dojo.isIE || dojo.isSafari ? \"keydown\" : \"keypress\", onKeyDown);\n\t\twindow.onFirebugResize = null;\n\t\twindow.console = null;\n\t});\n\n});\n","dependencies":["dojo\/_base\/kernel","require","dojo\/_base\/html","dojo\/_base\/sniff","dojo\/_base\/array","dojo\/_base\/lang","dojo\/_base\/event","dojo\/_base\/unload"]},"dojo\/_base\/html":{"id":"dojo\/_base\/html","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/html.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \"..\/dom\", \"..\/dom-style\", \"..\/dom-attr\", \"..\/dom-prop\", \"..\/dom-class\", \"..\/dom-construct\", \"..\/dom-geometry\"], function(dojo, dom, style, attr, prop, cls, ctr, geom){\n\t\/\/ module:\n\t\/\/\t\tdojo\/dom\n\t\/\/ summary:\n\t\/\/\t\tThis module is a stub fot the core dojo DOM API.\n\n\t\/\/ mix-in dom\n\tdojo.byId = dom.byId;\n\tdojo.isDescendant = dom.isDescendant;\n\tdojo.setSelectable = dom.setSelectable;\n\n\t\/\/ mix-in dom-attr\n\tdojo.getAttr = attr.get;\n\tdojo.setAttr = attr.set;\n\tdojo.hasAttr = attr.has;\n\tdojo.removeAttr = attr.remove;\n\tdojo.getPropNode = attr.getNodeProp;\n\n\tdojo.attr = function(node, name, value){\n\t\t\/\/ summary:\n\t\t\/\/\t\tGets or sets an attribute on an HTML element.\n\t\t\/\/ description:\n\t\t\/\/\t\tHandles normalized getting and setting of attributes on DOM\n\t\t\/\/\t\tNodes. If 2 arguments are passed, and a the second argument is a\n\t\t\/\/\t\tstring, acts as a getter.\n\t\t\/\/\n\t\t\/\/\t\tIf a third argument is passed, or if the second argument is a\n\t\t\/\/\t\tmap of attributes, acts as a setter.\n\t\t\/\/\n\t\t\/\/\t\tWhen passing functions as values, note that they will not be\n\t\t\/\/\t\tdirectly assigned to slots on the node, but rather the default\n\t\t\/\/\t\tbehavior will be removed and the new behavior will be added\n\t\t\/\/\t\tusing `dojo.connect()`, meaning that event handler properties\n\t\t\/\/\t\twill be normalized and that some caveats with regards to\n\t\t\/\/\t\tnon-standard behaviors for onsubmit apply. Namely that you\n\t\t\/\/\t\tshould cancel form submission using `dojo.stopEvent()` on the\n\t\t\/\/\t\tpassed event object instead of returning a boolean value from\n\t\t\/\/\t\tthe handler itself.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to the element to get or set the attribute on\n\t\t\/\/ name: String|Object\n\t\t\/\/\t\tthe name of the attribute to get or set.\n\t\t\/\/ value: String?\n\t\t\/\/\t\tThe value to set for the attribute\n\t\t\/\/ returns:\n\t\t\/\/\t\twhen used as a getter, the value of the requested attribute\n\t\t\/\/\t\tor null if that attribute does not have a specified or\n\t\t\/\/\t\tdefault value;\n\t\t\/\/\n\t\t\/\/\t\twhen used as a setter, the DOM node\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t|\t\/\/ get the current value of the \"foo\" attribute on a node\n\t\t\/\/\t|\tdojo.attr(dojo.byId(\"nodeId\"), \"foo\");\n\t\t\/\/\t|\t\/\/ or we can just pass the id:\n\t\t\/\/\t|\tdojo.attr(\"nodeId\", \"foo\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t|\t\/\/ use attr() to set the tab index\n\t\t\/\/\t|\tdojo.attr(\"nodeId\", \"tabIndex\", 3);\n\t\t\/\/\t|\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tSet multiple values at once, including event handlers:\n\t\t\/\/\t|\tdojo.attr(\"formId\", {\n\t\t\/\/\t|\t\t\"foo\": \"bar\",\n\t\t\/\/\t|\t\t\"tabIndex\": -1,\n\t\t\/\/\t|\t\t\"method\": \"POST\",\n\t\t\/\/\t|\t\t\"onsubmit\": function(e){\n\t\t\/\/\t|\t\t\t\/\/ stop submitting the form. Note that the IE behavior\n\t\t\/\/\t|\t\t\t\/\/ of returning true or false will have no effect here\n\t\t\/\/\t|\t\t\t\/\/ since our handler is connect()ed to the built-in\n\t\t\/\/\t|\t\t\t\/\/ onsubmit behavior and so we need to use\n\t\t\/\/\t|\t\t\t\/\/ dojo.stopEvent() to ensure that the submission\n\t\t\/\/\t|\t\t\t\/\/ doesn't proceed.\n\t\t\/\/\t|\t\t\tdojo.stopEvent(e);\n\t\t\/\/\t|\n\t\t\/\/\t|\t\t\t\/\/ submit the form with Ajax\n\t\t\/\/\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tStyle is s special case: Only set with an object hash of styles\n\t\t\/\/\t|\tdojo.attr(\"someNode\",{\n\t\t\/\/\t|\t\tid:\"bar\",\n\t\t\/\/\t|\t\tstyle:{\n\t\t\/\/\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tAgain, only set style as an object hash of styles:\n\t\t\/\/\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\n\t\t\/\/\t|\tdojo.attr(\"someNode\", \"style\", obj);\n\t\t\/\/\t|\n\t\t\/\/\t|\t\/\/ though shorter to use `dojo.style()` in this case:\n\t\t\/\/\t|\tdojo.style(\"someNode\", obj);\n\n\t\tif(arguments.length == 2){\n\t\t\treturn attr[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\n\t\t}\n\t\treturn attr.set(node, name, value);\n\t};\n\n\t\/\/ mix-in dom-class\n\tdojo.hasClass = cls.contains;\n\tdojo.addClass = cls.add;\n\tdojo.removeClass = cls.remove;\n\tdojo.toggleClass = cls.toggle;\n\tdojo.replaceClass = cls.replace;\n\n\t\/\/ mix-in dom-construct\n\tdojo._toDom = dojo.toDom = ctr.toDom;\n\tdojo.place = ctr.place;\n\tdojo.create = ctr.create;\n\tdojo.empty = ctr.empty;\n\tdojo._destroyElement = dojo.destroy = ctr.destroy;\n\n\t\/\/ mix-in dom-geometry\n\tdojo._getPadExtents = dojo.getPadExtents = geom.getPadExtents;\n\tdojo._getBorderExtents = dojo.getBorderExtents = geom.getBorderExtents;\n\tdojo._getPadBorderExtents = dojo.getPadBorderExtents = geom.getPadBorderExtents;\n\tdojo._getMarginExtents = dojo.getMarginExtents = geom.getMarginExtents;\n\tdojo._getMarginSize = dojo.getMarginSize = geom.getMarginSize;\n\tdojo._getMarginBox = dojo.getMarginBox = geom.getMarginBox;\n\tdojo._setMarginBox = dojo.setMarginBox = geom.setMarginBox;\n\tdojo._getContentBox = dojo.getContentBox = geom.getContentBox;\n\tdojo._setContentSize = dojo.setContentSize = geom.setContentSize;\n\tdojo._isBodyLtr = dojo.isBodyLtr = geom.isBodyLtr;\n\tdojo._docScroll = dojo.docScroll = geom.docScroll;\n\tdojo._getIeDocumentElementOffset = dojo.getIeDocumentElementOffset = geom.getIeDocumentElementOffset;\n\tdojo._fixIeBiDiScrollLeft = dojo.fixIeBiDiScrollLeft = geom.fixIeBiDiScrollLeft;\n\tdojo.position = geom.position;\n\n\tdojo.marginBox = function marginBox(\/*DomNode|String*\/node, \/*Object?*\/box){\n\t\t\/\/ summary:\n\t\t\/\/\t\tGetter\/setter for the margin-box of node.\n\t\t\/\/ description:\n\t\t\/\/\t\tGetter\/setter for the margin-box of node.\n\t\t\/\/\t\tReturns an object in the expected format of box (regardless\n\t\t\/\/\t\tif box is passed). The object might look like:\n\t\t\/\/\t\t\t`{ l: 50, t: 200, w: 300: h: 150 }`\n\t\t\/\/\t\tfor a node offset from its parent 50px to the left, 200px from\n\t\t\/\/\t\tthe top with a margin width of 300px and a margin-height of\n\t\t\/\/\t\t150px.\n\t\t\/\/ node:\n\t\t\/\/\t\tid or reference to DOM Node to get\/set box for\n\t\t\/\/ box:\n\t\t\/\/\t\tIf passed, denotes that dojo.marginBox() should\n\t\t\/\/\t\tupdate\/set the margin box for node. Box is an object in the\n\t\t\/\/\t\tabove format. All properties are optional if passed.\n\t\t\/\/ example:\n\t\t\/\/\t\tRetrieve the margin box of a passed node\n\t\t\/\/\t|\tvar box = dojo.marginBox(\"someNodeId\");\n\t\t\/\/\t|\tconsole.dir(box);\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tSet a node's margin box to the size of another node\n\t\t\/\/\t|\tvar box = dojo.marginBox(\"someNodeId\");\n\t\t\/\/\t|\tdojo.marginBox(\"someOtherNode\", box);\n\t\treturn box ? geom.setMarginBox(node, box.l, box.t, box.w, box.h) : geom.getMarginBox(node); \/\/ Object\n\t};\n\n\tdojo.contentBox = function contentBox(\/*DomNode|String*\/node, \/*Object?*\/box){\n\t\t\/\/ summary:\n\t\t\/\/\t\tGetter\/setter for the content-box of node.\n\t\t\/\/ description:\n\t\t\/\/\t\tReturns an object in the expected format of box (regardless if box is passed).\n\t\t\/\/\t\tThe object might look like:\n\t\t\/\/\t\t\t`{ l: 50, t: 200, w: 300: h: 150 }`\n\t\t\/\/\t\tfor a node offset from its parent 50px to the left, 200px from\n\t\t\/\/\t\tthe top with a content width of 300px and a content-height of\n\t\t\/\/\t\t150px. Note that the content box may have a much larger border\n\t\t\/\/\t\tor margin box, depending on the box model currently in use and\n\t\t\/\/\t\tCSS values set\/inherited for node.\n\t\t\/\/\t\tWhile the getter will return top and left values, the\n\t\t\/\/\t\tsetter only accepts setting the width and height.\n\t\t\/\/ node:\n\t\t\/\/\t\tid or reference to DOM Node to get\/set box for\n\t\t\/\/ box:\n\t\t\/\/\t\tIf passed, denotes that dojo.contentBox() should\n\t\t\/\/\t\tupdate\/set the content box for node. Box is an object in the\n\t\t\/\/\t\tabove format, but only w (width) and h (height) are supported.\n\t\t\/\/\t\tAll properties are optional if passed.\n\t\treturn box ? geom.setContentSize(node, box.w, box.h) : geom.getContentBox(node); \/\/ Object\n\t};\n\n\tdojo.coords = function(\/*DomNode|String*\/node, \/*Boolean?*\/includeScroll){\n\t\t\/\/ summary:\n\t\t\/\/\t\tDeprecated: Use position() for border-box x\/y\/w\/h\n\t\t\/\/\t\tor marginBox() for margin-box w\/h\/l\/t.\n\t\t\/\/\t\tReturns an object representing a node's size and position.\n\t\t\/\/\n\t\t\/\/ description:\n\t\t\/\/\t\tReturns an object that measures margin-box (w)idth\/(h)eight\n\t\t\/\/\t\tand absolute position x\/y of the border-box. Also returned\n\t\t\/\/\t\tis computed (l)eft and (t)op values in pixels from the\n\t\t\/\/\t\tnode's offsetParent as returned from marginBox().\n\t\t\/\/\t\tReturn value will be in the form:\n\t\t\/\/|\t\t\t{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }\n\t\t\/\/\t\tDoes not act as a setter. If includeScroll is passed, the x and\n\t\t\/\/\t\ty params are affected as one would expect in dojo.position().\n\t\tdojo.deprecated(\"dojo.coords()\", \"Use dojo.position() or dojo.marginBox().\");\n\t\tnode = dom.byId(node);\n\t\tvar s = style.getComputedStyle(node), mb = geom.getMarginBox(node, s);\n\t\tvar abs = geom.position(node, includeScroll);\n\t\tmb.x = abs.x;\n\t\tmb.y = abs.y;\n\t\treturn mb;\t\/\/ Object\n\t};\n\n\t\/\/ mix-in dom-prop\n\tdojo.getProp = prop.get;\n\tdojo.setProp = prop.set;\n\n\tdojo.prop = function(\/*DomNode|String*\/node, \/*String|Object*\/name, \/*String?*\/value){\n\t\t\/\/ summary:\n\t\t\/\/\t\tGets or sets a property on an HTML element.\n\t\t\/\/ description:\n\t\t\/\/\t\tHandles normalized getting and setting of properties on DOM\n\t\t\/\/\t\tNodes. If 2 arguments are passed, and a the second argument is a\n\t\t\/\/\t\tstring, acts as a getter.\n\t\t\/\/\n\t\t\/\/\t\tIf a third argument is passed, or if the second argument is a\n\t\t\/\/\t\tmap of attributes, acts as a setter.\n\t\t\/\/\n\t\t\/\/\t\tWhen passing functions as values, note that they will not be\n\t\t\/\/\t\tdirectly assigned to slots on the node, but rather the default\n\t\t\/\/\t\tbehavior will be removed and the new behavior will be added\n\t\t\/\/\t\tusing `dojo.connect()`, meaning that event handler properties\n\t\t\/\/\t\twill be normalized and that some caveats with regards to\n\t\t\/\/\t\tnon-standard behaviors for onsubmit apply. Namely that you\n\t\t\/\/\t\tshould cancel form submission using `dojo.stopEvent()` on the\n\t\t\/\/\t\tpassed event object instead of returning a boolean value from\n\t\t\/\/\t\tthe handler itself.\n\t\t\/\/ node:\n\t\t\/\/\t\tid or reference to the element to get or set the property on\n\t\t\/\/ name:\n\t\t\/\/\t\tthe name of the property to get or set.\n\t\t\/\/ value:\n\t\t\/\/\t\tThe value to set for the property\n\t\t\/\/ returns:\n\t\t\/\/\t\twhen used as a getter, the value of the requested property\n\t\t\/\/\t\tor null if that attribute does not have a specified or\n\t\t\/\/\t\tdefault value;\n\t\t\/\/\n\t\t\/\/\t\twhen used as a setter, the DOM node\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t|\t\/\/ get the current value of the \"foo\" property on a node\n\t\t\/\/\t|\tdojo.prop(dojo.byId(\"nodeId\"), \"foo\");\n\t\t\/\/\t|\t\/\/ or we can just pass the id:\n\t\t\/\/\t|\tdojo.prop(\"nodeId\", \"foo\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t|\t\/\/ use prop() to set the tab index\n\t\t\/\/\t|\tdojo.prop(\"nodeId\", \"tabIndex\", 3);\n\t\t\/\/\t|\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tSet multiple values at once, including event handlers:\n\t\t\/\/\t|\tdojo.prop(\"formId\", {\n\t\t\/\/\t|\t\t\"foo\": \"bar\",\n\t\t\/\/\t|\t\t\"tabIndex\": -1,\n\t\t\/\/\t|\t\t\"method\": \"POST\",\n\t\t\/\/\t|\t\t\"onsubmit\": function(e){\n\t\t\/\/\t|\t\t\t\/\/ stop submitting the form. Note that the IE behavior\n\t\t\/\/\t|\t\t\t\/\/ of returning true or false will have no effect here\n\t\t\/\/\t|\t\t\t\/\/ since our handler is connect()ed to the built-in\n\t\t\/\/\t|\t\t\t\/\/ onsubmit behavior and so we need to use\n\t\t\/\/\t|\t\t\t\/\/ dojo.stopEvent() to ensure that the submission\n\t\t\/\/\t|\t\t\t\/\/ doesn't proceed.\n\t\t\/\/\t|\t\t\tdojo.stopEvent(e);\n\t\t\/\/\t|\n\t\t\/\/\t|\t\t\t\/\/ submit the form with Ajax\n\t\t\/\/\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tStyle is s special case: Only set with an object hash of styles\n\t\t\/\/\t|\tdojo.prop(\"someNode\",{\n\t\t\/\/\t|\t\tid:\"bar\",\n\t\t\/\/\t|\t\tstyle:{\n\t\t\/\/\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tAgain, only set style as an object hash of styles:\n\t\t\/\/\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\n\t\t\/\/\t|\tdojo.prop(\"someNode\", \"style\", obj);\n\t\t\/\/\t|\n\t\t\/\/\t|\t\/\/ though shorter to use `dojo.style()` in this case:\n\t\t\/\/\t|\tdojo.style(\"someNode\", obj);\n\n\t\tif(arguments.length == 2){\n\t\t\treturn prop[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\n\t\t}\n\t\t\/\/ setter\n\t\treturn prop.set(node, name, value);\n\t};\n\n\t\/\/ mix-in dom-style\n\tdojo.getStyle = style.get;\n\tdojo.setStyle = style.set;\n\tdojo.getComputedStyle = style.getComputedStyle;\n\tdojo.__toPixelValue = dojo.toPixelValue = style.toPixelValue;\n\n\tdojo.style = function(node, name, value){\n\t\t\/\/ summary:\n\t\t\/\/\t\tAccesses styles on a node. If 2 arguments are\n\t\t\/\/\t\tpassed, acts as a getter. If 3 arguments are passed, acts\n\t\t\/\/\t\tas a setter.\n\t\t\/\/ description:\n\t\t\/\/\t\tGetting the style value uses the computed style for the node, so the value\n\t\t\/\/\t\twill be a calculated value, not just the immediate node.style value.\n\t\t\/\/\t\tAlso when getting values, use specific style names,\n\t\t\/\/\t\tlike \"borderBottomWidth\" instead of \"border\" since compound values like\n\t\t\/\/\t\t\"border\" are not necessarily reflected as expected.\n\t\t\/\/\t\tIf you want to get node dimensions, use `dojo.marginBox()`,\n\t\t\/\/\t\t`dojo.contentBox()` or `dojo.position()`.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to node to get\/set style for\n\t\t\/\/ name: String?|Object?\n\t\t\/\/\t\tthe style property to set in DOM-accessor format\n\t\t\/\/\t\t(\"borderWidth\", not \"border-width\") or an object with key\/value\n\t\t\/\/\t\tpairs suitable for setting each property.\n\t\t\/\/ value: String?\n\t\t\/\/\t\tIf passed, sets value on the node for style, handling\n\t\t\/\/\t\tcross-browser concerns.  When setting a pixel value,\n\t\t\/\/\t\tbe sure to include \"px\" in the value. For instance, top: \"200px\".\n\t\t\/\/\t\tOtherwise, in some cases, some browsers will not apply the style.\n\t\t\/\/ returns:\n\t\t\/\/\t\twhen used as a getter, return the computed style of the node if passing in an ID or node,\n\t\t\/\/\t\tor return the normalized, computed value for the property when passing in a node and a style property\n\t\t\/\/ example:\n\t\t\/\/\t\tPassing only an ID or node returns the computed style object of\n\t\t\/\/\t\tthe node:\n\t\t\/\/\t|\tdojo.style(\"thinger\");\n\t\t\/\/ example:\n\t\t\/\/\t\tPassing a node and a style property returns the current\n\t\t\/\/\t\tnormalized, computed value for that property:\n\t\t\/\/\t|\tdojo.style(\"thinger\", \"opacity\"); \/\/ 1 by default\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tPassing a node, a style property, and a value changes the\n\t\t\/\/\t\tcurrent display of the node and returns the new computed value\n\t\t\/\/\t|\tdojo.style(\"thinger\", \"opacity\", 0.5); \/\/ == 0.5\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tPassing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:\n\t\t\/\/\t|\tdojo.style(\"thinger\", {\n\t\t\/\/\t|\t\t\"opacity\": 0.5,\n\t\t\/\/\t|\t\t\"border\": \"3px solid black\",\n\t\t\/\/\t|\t\t\"height\": \"300px\"\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tWhen the CSS style property is hyphenated, the JavaScript property is camelCased.\n\t\t\/\/\t\tfont-size becomes fontSize, and so on.\n\t\t\/\/\t|\tdojo.style(\"thinger\",{\n\t\t\/\/\t|\t\tfontSize:\"14pt\",\n\t\t\/\/\t|\t\tletterSpacing:\"1.2em\"\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tdojo.NodeList implements .style() using the same syntax, omitting the \"node\" parameter, calling\n\t\t\/\/\t\tdojo.style() on every element of the list. See: `dojo.query()` and `dojo.NodeList()`\n\t\t\/\/\t|\tdojo.query(\".someClassName\").style(\"visibility\",\"hidden\");\n\t\t\/\/\t|\t\/\/ or\n\t\t\/\/\t|\tdojo.query(\"#baz > div\").style({\n\t\t\/\/\t|\t\topacity:0.75,\n\t\t\/\/\t|\t\tfontSize:\"13pt\"\n\t\t\/\/\t|\t});\n\n\t\tswitch(arguments.length){\n\t\t\tcase 1:\n\t\t\t\treturn style.get(node);\n\t\t\tcase 2:\n\t\t\t\treturn style[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\n\t\t}\n\t\t\/\/ setter\n\t\treturn style.set(node, name, value);\n\t};\n\n\treturn dojo;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/dom","dojo\/dom-style","dojo\/dom-attr","dojo\/dom-prop","dojo\/dom-class","dojo\/dom-construct","dojo\/dom-geometry"]},"dojo\/dom":{"id":"dojo\/dom","url":"\/home\/arian\/www\/MooTools\/dojo\/dom.js","package":"dojo","amd":true,"content":"define([\".\/_base\/kernel\", \".\/_base\/sniff\", \".\/_base\/lang\", \".\/_base\/window\"],\n\t\tfunction(dojo, has, lang, win){\n\t\/\/ module:\n\t\/\/\t\tdojo\/dom\n\t\/\/ summary:\n\t\/\/\t\tThis module defines the core dojo DOM API.\n\n\t\/\/ FIXME: need to add unit tests for all the semi-public methods\n\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\ttry{\n\t\tdocument.execCommand(\"BackgroundImageCache\", false, true);\n\t}catch(e){\n\t\t\/\/ sane browsers don't have cache \"issues\"\n\t}\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\n\t\/\/ =============================\n\t\/\/ DOM Functions\n\t\/\/ =============================\n\n\t\/*=====\n\tdojo.byId = function(id, doc){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns DOM node with matching `id` attribute or `null`\n\t\t\/\/\t\tif not found. If `id` is a DomNode, this function is a no-op.\n\t\t\/\/\n\t\t\/\/ id: String|DOMNode\n\t\t\/\/\t \tA string to match an HTML id attribute or a reference to a DOM Node\n\t\t\/\/\n\t\t\/\/ doc: Document?\n\t\t\/\/\t\tDocument to work in. Defaults to the current value of\n\t\t\/\/\t\tdojo.doc.  Can be used to retrieve\n\t\t\/\/\t\tnode references from other documents.\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tLook up a node by ID:\n\t\t\/\/\t|\tvar n = dojo.byId(\"foo\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tCheck if a node exists, and use it.\n\t\t\/\/\t|\tvar n = dojo.byId(\"bar\");\n\t\t\/\/\t|\tif(n){ doStuff() ... }\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tAllow string or DomNode references to be passed to a custom function:\n\t\t\/\/\t|\tvar foo = function(nodeOrId){\n\t\t\/\/\t|\t\tnodeOrId = dojo.byId(nodeOrId);\n\t\t\/\/\t|\t\t\/\/ ... more stuff\n\t\t\/\/\t|\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.isDescendant = function(node, ancestor){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns true if node is a descendant of ancestor\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tstring id or node reference to test\n\t\t\/\/ ancestor: DOMNode|String\n\t\t\/\/\t\tstring id or node reference of potential parent to test against\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tTest is node id=\"bar\" is a descendant of node id=\"foo\"\n\t\t\/\/\t|\tif(dojo.isDescendant(\"bar\", \"foo\")){ ... }\n\t};\n\t=====*\/\n\n\t\/\/ TODO: do we need this function in the base?\n\n\t\/*=====\n\tdojo.setSelectable = function(node, selectable){\n\t\t\/\/ summary:\n\t\t\/\/\t\tEnable or disable selection on a node\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to node\n\t\t\/\/ selectable: Boolean\n\t\t\/\/\t\tstate to put the node in. false indicates unselectable, true\n\t\t\/\/\t\tallows selection.\n\t\t\/\/ example:\n\t\t\/\/\t\tMake the node id=\"bar\" unselectable\n\t\t\/\/\t|\tdojo.setSelectable(\"bar\");\n\t\t\/\/ example:\n\t\t\/\/\t\tMake the node id=\"bar\" selectable\n\t\t\/\/\t|\tdojo.setSelectable(\"bar\", true);\n\t};\n\t=====*\/\n\n\tvar dom = {};   \/\/ the result object\n\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\tif(has(\"ie\")){\n\t\tdom.byId = function(id, doc){\n\t\t\tif(typeof id != \"string\"){\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tvar _d = doc || win.doc, te = id && _d.getElementById(id);\n\t\t\t\/\/ attributes.id.value is better than just id in case the\n\t\t\t\/\/ user has a name=id inside a form\n\t\t\tif(te && (te.attributes.id.value == id || te.id == id)){\n\t\t\t\treturn te;\n\t\t\t}else{\n\t\t\t\tvar eles = _d.all[id];\n\t\t\t\tif(!eles || eles.nodeName){\n\t\t\t\t\teles = [eles];\n\t\t\t\t}\n\t\t\t\t\/\/ if more than 1, choose first with the correct id\n\t\t\t\tvar i = 0;\n\t\t\t\twhile((te = eles[i++])){\n\t\t\t\t\tif((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){\n\t\t\t\t\t\treturn te;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}else{\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\tdom.byId = function(id, doc){\n\t\t\t\/\/ inline'd type check.\n\t\t\t\/\/ be sure to return null per documentation, to match IE branch.\n\t\t\treturn ((typeof id == \"string\") ? (doc || win.doc).getElementById(id) : id) || null; \/\/ DOMNode\n\t\t};\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t}\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\/*=====\n\t};\n\t=====*\/\n\n\tdom.isDescendant = function(\/*DOMNode|String*\/node, \/*DOMNode|String*\/ancestor){\n\t\ttry{\n\t\t\tnode = dom.byId(node);\n\t\t\tancestor = dom.byId(ancestor);\n\t\t\twhile(node){\n\t\t\t\tif(node == ancestor){\n\t\t\t\t\treturn true; \/\/ Boolean\n\t\t\t\t}\n\t\t\t\tnode = node.parentNode;\n\t\t\t}\n\t\t}catch(e){ \/* squelch, return false *\/ }\n\t\treturn false; \/\/ Boolean\n\t};\n\n\t\/\/ TODO: do we need this function in the base?\n\n\tdom.setSelectable = function(\/*DOMNode|String*\/node, \/*Boolean*\/selectable){\n\t\tnode = dojo.byId(node);\n\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\tif(has(\"mozilla\")){\n\t\t\tnode.style.MozUserSelect = selectable ? \"\" : \"none\";\n\t\t}else if(has(\"khtml\") || has(\"webkit\")){\n\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\t\tnode.style.KhtmlUserSelect = selectable ? \"auto\" : \"none\";\n\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\t}else if(has(\"ie\")){\n\t\t\tvar v = (node.unselectable = selectable ? \"\" : \"on\"),\n\t\t\t\tcs = node.getElementsByTagName(\"*\"), i = 0, l = cs.length;\n\t\t\tfor(; i < l; ++i){\n\t\t\t\tcs.item(i).unselectable = v;\n\t\t\t}\n\t\t}\n\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\t\/\/FIXME: else?  Opera?\n\t};\n\n\treturn dom;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/_base\/sniff","dojo\/_base\/lang","dojo\/_base\/window"]},"dojo\/_base\/window":{"id":"dojo\/_base\/window","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/window.js","package":"dojo","amd":true,"content":"define([\".\/kernel\"], function(dojo){\n\t\/\/ module:\n\t\/\/\t\tdojo\/window\n\t\/\/ summary:\n\t\/\/\t\tThis module provides an API to save\/set\/restore the global\/document scope.\n\n\/*=====\ndojo.doc = {\n\t\/\/ summary:\n\t\/\/\t\tAlias for the current document. 'dojo.doc' can be modified\n\t\/\/\t\tfor temporary context shifting. Also see dojo.withDoc().\n\t\/\/ description:\n\t\/\/\t\tRefer to dojo.doc rather\n\t\/\/\t\tthan referring to 'window.document' to ensure your code runs\n\t\/\/\t\tcorrectly in managed contexts.\n\t\/\/ example:\n\t\/\/\t|\tn.appendChild(dojo.doc.createElement('div'));\n}\n=====*\/\ndojo.doc = window[\"document\"] || null;\n\ndojo.body = function(){\n\t\/\/ summary:\n\t\/\/\t\tReturn the body element of the document\n\t\/\/\t\treturn the body object associated with dojo.doc\n\t\/\/ example:\n\t\/\/\t|\tdojo.body().appendChild(dojo.doc.createElement('div'));\n\n\t\/\/ Note: document.body is not defined for a strict xhtml document\n\t\/\/ Would like to memoize this, but dojo.doc can change vi dojo.withDoc().\n\treturn dojo.doc.body || dojo.doc.getElementsByTagName(\"body\")[0]; \/\/ Node\n};\n\ndojo.setContext = function(\/*Object*\/globalObject, \/*DocumentElement*\/globalDocument){\n\t\/\/ summary:\n\t\/\/\t\tchanges the behavior of many core Dojo functions that deal with\n\t\/\/\t\tnamespace and DOM lookup, changing them to work in a new global\n\t\/\/\t\tcontext (e.g., an iframe). The varibles dojo.global and dojo.doc\n\t\/\/\t\tare modified as a result of calling this function and the result of\n\t\/\/\t\t`dojo.body()` likewise differs.\n\tdojo.global = ret.global = globalObject;\n\tdojo.doc = ret.doc = globalDocument;\n};\n\ndojo.withGlobal = function(\t\/*Object*\/globalObject,\n\t\t\t\t\t\t\t\/*Function*\/callback,\n\t\t\t\t\t\t\t\/*Object?*\/thisObject,\n\t\t\t\t\t\t\t\/*Array?*\/cbArguments){\n\t\/\/ summary:\n\t\/\/\t\tInvoke callback with globalObject as dojo.global and\n\t\/\/\t\tglobalObject.document as dojo.doc.\n\t\/\/ description:\n\t\/\/\t\tInvoke callback with globalObject as dojo.global and\n\t\/\/\t\tglobalObject.document as dojo.doc. If provided, globalObject\n\t\/\/\t\twill be executed in the context of object thisObject\n\t\/\/\t\tWhen callback() returns or throws an error, the dojo.global\n\t\/\/\t\tand dojo.doc will be restored to its previous state.\n\n\tvar oldGlob = dojo.global;\n\ttry{\n\t\tdojo.global = ret.global = globalObject;\n\t\treturn dojo.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);\n\t}finally{\n\t\tdojo.global = ret.global = oldGlob;\n\t}\n};\n\ndojo.withDoc = function(\t\/*DocumentElement*\/documentObject,\n\t\t\t\t\t\t\t\/*Function*\/callback,\n\t\t\t\t\t\t\t\/*Object?*\/thisObject,\n\t\t\t\t\t\t\t\/*Array?*\/cbArguments){\n\t\/\/ summary:\n\t\/\/\t\tInvoke callback with documentObject as dojo.doc.\n\t\/\/ description:\n\t\/\/\t\tInvoke callback with documentObject as dojo.doc. If provided,\n\t\/\/\t\tcallback will be executed in the context of object thisObject\n\t\/\/\t\tWhen callback() returns or throws an error, the dojo.doc will\n\t\/\/\t\tbe restored to its previous state.\n\n\tvar oldDoc = dojo.doc,\n\t\toldQ = dojo.isQuirks;\n\n\ttry{\n\t\tdojo.doc = ret.doc = documentObject;\n\t\tdojo.isQuirks = dojo.doc.compatMode == \"BackCompat\"; \/\/ no need to check for QuirksMode which was Opera 7 only\n\n\t\tif(thisObject && typeof callback == \"string\"){\n\t\t\tcallback = thisObject[callback];\n\t\t}\n\n\t\treturn callback.apply(thisObject, cbArguments || []);\n\t}finally{\n\t\tdojo.doc = ret.doc = oldDoc;\n\t\tdojo.isQuirks = oldQ;\n\t}\n};\n\nvar ret = {\n\tglobal: dojo.global,\n\tdoc: dojo.doc,\n\tbody: dojo.body,\n\tsetContext: dojo.setContext,\n\twithGlobal: dojo.withGlobal,\n\twithDoc: dojo.withDoc\n};\n\nreturn ret;\n\n});\n","dependencies":["dojo\/_base\/kernel"]},"dojo\/dom-style":{"id":"dojo\/dom-style","url":"\/home\/arian\/www\/MooTools\/dojo\/dom-style.js","package":"dojo","amd":true,"content":"define([\".\/_base\/kernel\", \".\/_base\/sniff\", \".\/dom\"], function(dojo, has, dom){\n\t\/\/ module:\n\t\/\/\t\tdojo\/dom-style\n\t\/\/ summary:\n\t\/\/\t\tThis module defines the core dojo DOM style API.\n\n\t\/\/ =============================\n\t\/\/ Style Functions\n\t\/\/ =============================\n\n\t\/\/ getComputedStyle drives most of the style code.\n\t\/\/ Wherever possible, reuse the returned object.\n\t\/\/\n\t\/\/ API functions below that need to access computed styles accept an\n\t\/\/ optional computedStyle parameter.\n\t\/\/ If this parameter is omitted, the functions will call getComputedStyle themselves.\n\t\/\/ This way, calling code can access computedStyle once, and then pass the reference to\n\t\/\/ multiple API functions.\n\n\t\/*=====\n\tdojo.getComputedStyle = function(node){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns a \"computed style\" object.\n\t\t\/\/\n\t\t\/\/ description:\n\t\t\/\/\t\tGets a \"computed style\" object which can be used to gather\n\t\t\/\/\t\tinformation about the current state of the rendered node.\n\t\t\/\/\n\t\t\/\/\t\tNote that this may behave differently on different browsers.\n\t\t\/\/\t\tValues may have different formats and value encodings across\n\t\t\/\/\t\tbrowsers.\n\t\t\/\/\n\t\t\/\/\t\tNote also that this method is expensive.  Wherever possible,\n\t\t\/\/\t\treuse the returned object.\n\t\t\/\/\n\t\t\/\/\t\tUse the dojo.style() method for more consistent (pixelized)\n\t\t\/\/\t\treturn values.\n\t\t\/\/\n\t\t\/\/ node: DOMNode\n\t\t\/\/\t\tA reference to a DOM node. Does NOT support taking an\n\t\t\/\/\t\tID string for speed reasons.\n\t\t\/\/ example:\n\t\t\/\/\t|\tdojo.getComputedStyle(dojo.byId('foo')).borderWidth;\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tReusing the returned object, avoiding multiple lookups:\n\t\t\/\/\t|\tvar cs = dojo.getComputedStyle(dojo.byId(\"someNode\"));\n\t\t\/\/\t|\tvar w = cs.width, h = cs.height;\n\t\treturn; \/\/ CSS2Properties\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.toPixelValue = function(node, value){\n\t\t\/\/ summary:\n\t\t\/\/      converts style value to pixels on IE or return a numeric value.\n\t\t\/\/ node: DOMNode\n\t\t\/\/ value: String\n\t\t\/\/ returns: Number\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._toPixelValue = function(node, value){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo._toPixelValue`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.getStyle = function(node, name){\n\t\t\/\/ summary:\n\t\t\/\/\t\tAccesses styles on a node.\n\t\t\/\/ description:\n\t\t\/\/\t\tGetting the style value uses the computed style for the node, so the value\n\t\t\/\/\t\twill be a calculated value, not just the immediate node.style value.\n\t\t\/\/\t\tAlso when getting values, use specific style names,\n\t\t\/\/\t\tlike \"borderBottomWidth\" instead of \"border\" since compound values like\n\t\t\/\/\t\t\"border\" are not necessarily reflected as expected.\n\t\t\/\/\t\tIf you want to get node dimensions, use `dojo.marginBox()`,\n\t\t\/\/\t\t`dojo.contentBox()` or `dojo.position()`.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to node to get style for\n\t\t\/\/ name: String?\n\t\t\/\/\t\tthe style property to get\n\t\t\/\/ example:\n\t\t\/\/\t\tPassing only an ID or node returns the computed style object of\n\t\t\/\/\t\tthe node:\n\t\t\/\/\t|\tdojo.getStyle(\"thinger\");\n\t\t\/\/ example:\n\t\t\/\/\t\tPassing a node and a style property returns the current\n\t\t\/\/\t\tnormalized, computed value for that property:\n\t\t\/\/\t|\tdojo.getStyle(\"thinger\", \"opacity\"); \/\/ 1 by default\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.setStyle = function(node, name, value){\n\t\t\/\/ summary:\n\t\t\/\/\t\tSets styles on a node.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to node to set style for\n\t\t\/\/ name: String|Object\n\t\t\/\/\t\tthe style property to set in DOM-accessor format\n\t\t\/\/\t\t(\"borderWidth\", not \"border-width\") or an object with key\/value\n\t\t\/\/\t\tpairs suitable for setting each property.\n\t\t\/\/ value: String?\n\t\t\/\/\t\tIf passed, sets value on the node for style, handling\n\t\t\/\/\t\tcross-browser concerns.  When setting a pixel value,\n\t\t\/\/\t\tbe sure to include \"px\" in the value. For instance, top: \"200px\".\n\t\t\/\/\t\tOtherwise, in some cases, some browsers will not apply the style.\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tPassing a node, a style property, and a value changes the\n\t\t\/\/\t\tcurrent display of the node and returns the new computed value\n\t\t\/\/\t|\tdojo.setStyle(\"thinger\", \"opacity\", 0.5); \/\/ == 0.5\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tPassing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:\n\t\t\/\/\t|\tdojo.setStyle(\"thinger\", {\n\t\t\/\/\t|\t\t\"opacity\": 0.5,\n\t\t\/\/\t|\t\t\"border\": \"3px solid black\",\n\t\t\/\/\t|\t\t\"height\": \"300px\"\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tWhen the CSS style property is hyphenated, the JavaScript property is camelCased.\n\t\t\/\/\t\tfont-size becomes fontSize, and so on.\n\t\t\/\/\t|\tdojo.setStyle(\"thinger\",{\n\t\t\/\/\t|\t\tfontSize:\"14pt\",\n\t\t\/\/\t|\t\tletterSpacing:\"1.2em\"\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tdojo.NodeList implements .style() using the same syntax, omitting the \"node\" parameter, calling\n\t\t\/\/\t\tdojo.style() on every element of the list. See: `dojo.query()` and `dojo.NodeList()`\n\t\t\/\/\t|\tdojo.query(\".someClassName\").style(\"visibility\",\"hidden\");\n\t\t\/\/\t|\t\/\/ or\n\t\t\/\/\t|\tdojo.query(\"#baz > div\").style({\n\t\t\/\/\t|\t\topacity:0.75,\n\t\t\/\/\t|\t\tfontSize:\"13pt\"\n\t\t\/\/\t|\t});\n\t};\n\t=====*\/\n\n\t\/\/ Although we normally eschew argument validation at this\n\t\/\/ level, here we test argument 'node' for (duck)type,\n\t\/\/ by testing nodeType, ecause 'document' is the 'parentNode' of 'body'\n\t\/\/ it is frequently sent to this function even\n\t\/\/ though it is not Element.\n\tvar getComputedStyle, style = {};\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\tif(has(\"webkit\")){\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\tgetComputedStyle = function(\/*DomNode*\/node){\n\t\t\tvar s;\n\t\t\tif(node.nodeType == 1){\n\t\t\t\tvar dv = node.ownerDocument.defaultView;\n\t\t\t\ts = dv.getComputedStyle(node, null);\n\t\t\t\tif(!s && node.style){\n\t\t\t\t\tnode.style.display = \"\";\n\t\t\t\t\ts = dv.getComputedStyle(node, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s || {};\n\t\t};\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t}else if(has(\"ie\")){\n\t\tgetComputedStyle = function(node){\n\t\t\t\/\/ IE (as of 7) doesn't expose Element like sane browsers\n\t\t\treturn node.nodeType == 1 \/* ELEMENT_NODE*\/ ? node.currentStyle : {};\n\t\t};\n\t}else{\n\t\tgetComputedStyle = function(node){\n\t\t\treturn node.nodeType == 1 ?\n\t\t\t\tnode.ownerDocument.defaultView.getComputedStyle(node, null) : {};\n\t\t};\n\t}\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\tstyle.getComputedStyle = getComputedStyle;\n\n\tvar toPixel;\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\tif(!has(\"ie\")){\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\ttoPixel = function(element, value){\n\t\t\t\/\/ style values can be floats, client code may want\n\t\t\t\/\/ to round for integer pixels.\n\t\t\treturn parseFloat(value) || 0;\n\t\t};\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t}else{\n\t\ttoPixel = function(element, avalue){\n\t\t\tif(!avalue){ return 0; }\n\t\t\t\/\/ on IE7, medium is usually 4 pixels\n\t\t\tif(avalue == \"medium\"){ return 4; }\n\t\t\t\/\/ style values can be floats, client code may\n\t\t\t\/\/ want to round this value for integer pixels.\n\t\t\tif(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }\n\t\t\tvar s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,\n\t\t\t\tsLeft = s.left, rsLeft = rs.left;\n\t\t\trs.left = cs.left;\n\t\t\ttry{\n\t\t\t\t\/\/ 'avalue' may be incompatible with style.left, which can cause IE to throw\n\t\t\t\t\/\/ this has been observed for border widths using \"thin\", \"medium\", \"thick\" constants\n\t\t\t\t\/\/ those particular constants could be trapped by a lookup\n\t\t\t\t\/\/ but perhaps there are more\n\t\t\t\ts.left = avalue;\n\t\t\t\tavalue = s.pixelLeft;\n\t\t\t}catch(e){\n\t\t\t\tavalue = 0;\n\t\t\t}\n\t\t\ts.left = sLeft;\n\t\t\trs.left = rsLeft;\n\t\t\treturn avalue;\n\t\t}\n\t}\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\tstyle.toPixelValue = toPixel;\n\n\t\/\/ FIXME: there opacity quirks on FF that we haven't ported over. Hrm.\n\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\tvar astr = \"DXImageTransform.Microsoft.Alpha\";\n\tvar af = function(n, f){\n\t\ttry{\n\t\t\treturn n.filters.item(astr);\n\t\t}catch(e){\n\t\t\treturn f ? {} : null;\n\t\t}\n\t};\n\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\tvar _getOpacity =\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\thas(\"ie\") < 9 || (has(\"ie\") && dojo.isQuirks) ? function(node){\n\t\t\ttry{\n\t\t\t\treturn af(node).Opacity \/ 100; \/\/ Number\n\t\t\t}catch(e){\n\t\t\t\treturn 1; \/\/ Number\n\t\t\t}\n\t\t} :\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\tfunction(node){\n\t\t\treturn getComputedStyle(node).opacity;\n\t\t};\n\n\tvar _setOpacity =\n\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\thas(\"ie\") < 9 || (has(\"ie\") && dojo.isQuirks) ? function(\/*DomNode*\/node, \/*Number*\/opacity){\n\t\t\tvar ov = opacity * 100, opaque = opacity == 1;\n\t\t\tnode.style.zoom = opaque ? \"\" : 1;\n\n\t\t\tif(!af(node)){\n\t\t\t\tif(opaque){\n\t\t\t\t\treturn opacity;\n\t\t\t\t}\n\t\t\t\tnode.style.filter += \" progid:\" + astr + \"(Opacity=\" + ov + \")\";\n\t\t\t}else{\n\t\t\t\taf(node, 1).Opacity = ov;\n\t\t\t}\n\n\t\t\t\/\/ on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),\n\t\t\t\/\/but still update the opacity value so we can get a correct reading if it is read later.\n\t\t\taf(node, 1).Enabled = !opaque;\n\n\t\t\tif(node.tagName.toLowerCase() == \"tr\"){\n\t\t\t\tfor(var td = node.firstChild; td; td = td.nextSibling){\n\t\t\t\t\tif(td.tagName.toLowerCase() == \"td\"){\n\t\t\t\t\t\t_setOpacity(td, opacity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opacity;\n\t\t} :\n\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\tfunction(node, opacity){\n\t\t\treturn node.style.opacity = opacity;\n\t\t};\n\n\tvar _pixelNamesCache = {\n\t\tleft: true, top: true\n\t};\n\tvar _pixelRegExp = \/margin|padding|width|height|max|min|offset\/; \/\/ |border\n\tfunction _toStyleValue(node, type, value){\n\t\t\/\/TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!\n\t\ttype = type.toLowerCase();\n\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\tif(has(\"ie\")){\n\t\t\tif(value == \"auto\"){\n\t\t\t\tif(type == \"height\"){ return node.offsetHeight; }\n\t\t\t\tif(type == \"width\"){ return node.offsetWidth; }\n\t\t\t}\n\t\t\tif(type == \"fontweight\"){\n\t\t\t\tswitch(value){\n\t\t\t\t\tcase 700: return \"bold\";\n\t\t\t\t\tcase 400:\n\t\t\t\t\tdefault: return \"normal\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\tif(!(type in _pixelNamesCache)){\n\t\t\t_pixelNamesCache[type] = _pixelRegExp.test(type);\n\t\t}\n\t\treturn _pixelNamesCache[type] ? toPixel(node, value) : value;\n\t}\n\n\tvar _floatStyle = has(\"ie\") ? \"styleFloat\" : \"cssFloat\",\n\t\t_floatAliases = {\"cssFloat\": _floatStyle, \"styleFloat\": _floatStyle, \"float\": _floatStyle};\n\n\t\/\/ public API\n\n\tstyle.get = function getStyle(\/*DOMNode|String*\/ node, \/*String?*\/ name){\n\t\tvar n = dom.byId(node), l = arguments.length, op = (name == \"opacity\");\n\t\tif(l == 2 && op){\n\t\t\treturn _getOpacity(n);\n\t\t}\n\t\tname = _floatAliases[name] || name;\n\t\tvar s = style.getComputedStyle(n);\n\t\treturn (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); \/* CSS2Properties||String||Number *\/\n\t};\n\n\tstyle.set = function setStyle(\/*DOMNode|String*\/ node, \/*String|Object*\/ name, \/*String?*\/ value){\n\t\tvar n = dom.byId(node), l = arguments.length, op = (name == \"opacity\");\n\t\tname = _floatAliases[name] || name;\n\t\tif(l == 3){\n\t\t\treturn op ? _setOpacity(n, value) : n.style[name] = value; \/\/ Number\n\t\t}\n\t\tfor(var x in name){\n\t\t\tstyle.set(node, x, name[x]);\n\t\t}\n\t\treturn style.getComputedStyle(n);\n\t};\n\n\treturn style;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/_base\/sniff","dojo\/dom"]},"dojo\/dom-attr":{"id":"dojo\/dom-attr","url":"\/home\/arian\/www\/MooTools\/dojo\/dom-attr.js","package":"dojo","amd":true,"content":"define([\".\/_base\/kernel\", \".\/_base\/sniff\", \".\/_base\/lang\", \".\/dom\", \".\/dom-style\", \".\/dom-prop\"],\n\t\tfunction(dojo, has, lang, dom, style, prop){\n\t\/\/ module:\n\t\/\/\t\tdojo\/dom-attr\n\t\/\/ summary:\n\t\/\/\t\tThis module defines the core dojo DOM attributes API.\n\n\t\/\/TODO: split getters and setters? Examples: attr - getAttr\/setAttr.\n\n\t\/\/ =============================\n\t\/\/ Element attribute Functions\n\t\/\/ =============================\n\n\t\/\/ This module will be obsolete soon. Use dojo.prop instead.\n\n\t\/\/ dojo.attr() should conform to http:\/\/www.w3.org\/TR\/DOM-Level-2-Core\/\n\n\t\/\/ attribute-related functions (to be obsolete soon)\n\n\t\/*=====\n\tdojo.hasAttr = function(node, name){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns true if the requested attribute is specified on the\n\t\t\/\/\t\tgiven element, and false otherwise.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to the element to check\n\t\t\/\/ name: String\n\t\t\/\/\t\tthe name of the attribute\n\t\t\/\/ returns: Boolean\n\t\t\/\/\t\ttrue if the requested attribute is specified on the\n\t\t\/\/\t\tgiven element, and false otherwise\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.getAttr = function(node, name){\n\t\t\/\/ summary:\n\t\t\/\/\t\tGets an attribute on an HTML element.\n\t\t\/\/ description:\n\t\t\/\/\t\tHandles normalized getting of attributes on DOM Nodes.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to the element to get the attribute on\n\t\t\/\/ name: String\n\t\t\/\/\t\tthe name of the attribute to get.\n\t\t\/\/ returns:\n\t\t\/\/\t\tthe value of the requested attribute or null if that attribute does not have a specified or\n\t\t\/\/\t\tdefault value;\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t|\t\/\/ get the current value of the \"foo\" attribute on a node\n\t\t\/\/\t|\tdojo.getAttr(dojo.byId(\"nodeId\"), \"foo\");\n\t\t\/\/\t|\t\/\/ or we can just pass the id:\n\t\t\/\/\t|\tdojo.getAttr(\"nodeId\", \"foo\");\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.setAttr = function(node, name, value){\n\t\t\/\/ summary:\n\t\t\/\/\t\tSets an attribute on an HTML element.\n\t\t\/\/ description:\n\t\t\/\/\t\tHandles normalized setting of attributes on DOM Nodes.\n\t\t\/\/\n\t\t\/\/\t\tWhen passing functions as values, note that they will not be\n\t\t\/\/\t\tdirectly assigned to slots on the node, but rather the default\n\t\t\/\/\t\tbehavior will be removed and the new behavior will be added\n\t\t\/\/\t\tusing `dojo.connect()`, meaning that event handler properties\n\t\t\/\/\t\twill be normalized and that some caveats with regards to\n\t\t\/\/\t\tnon-standard behaviors for onsubmit apply. Namely that you\n\t\t\/\/\t\tshould cancel form submission using `dojo.stopEvent()` on the\n\t\t\/\/\t\tpassed event object instead of returning a boolean value from\n\t\t\/\/\t\tthe handler itself.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to the element to set the attribute on\n\t\t\/\/ name: String|Object\n\t\t\/\/\t\tthe name of the attribute to set, or a hash of key-value pairs to set.\n\t\t\/\/ value: String?\n\t\t\/\/\t\tthe value to set for the attribute, if the name is a string.\n\t\t\/\/ returns:\n\t\t\/\/\t\tthe DOM node\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t|\t\/\/ use attr() to set the tab index\n\t\t\/\/\t|\tdojo.setAttr(\"nodeId\", \"tabIndex\", 3);\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tSet multiple values at once, including event handlers:\n\t\t\/\/\t|\tdojo.setAttr(\"formId\", {\n\t\t\/\/\t|\t\t\"foo\": \"bar\",\n\t\t\/\/\t|\t\t\"tabIndex\": -1,\n\t\t\/\/\t|\t\t\"method\": \"POST\",\n\t\t\/\/\t|\t\t\"onsubmit\": function(e){\n\t\t\/\/\t|\t\t\t\/\/ stop submitting the form. Note that the IE behavior\n\t\t\/\/\t|\t\t\t\/\/ of returning true or false will have no effect here\n\t\t\/\/\t|\t\t\t\/\/ since our handler is connect()ed to the built-in\n\t\t\/\/\t|\t\t\t\/\/ onsubmit behavior and so we need to use\n\t\t\/\/\t|\t\t\t\/\/ dojo.stopEvent() to ensure that the submission\n\t\t\/\/\t|\t\t\t\/\/ doesn't proceed.\n\t\t\/\/\t|\t\t\tdojo.stopEvent(e);\n\t\t\/\/\t|\n\t\t\/\/\t|\t\t\t\/\/ submit the form with Ajax\n\t\t\/\/\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tStyle is s special case: Only set with an object hash of styles\n\t\t\/\/\t|\tdojo.setAttr(\"someNode\",{\n\t\t\/\/\t|\t\tid:\"bar\",\n\t\t\/\/\t|\t\tstyle:{\n\t\t\/\/\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tAgain, only set style as an object hash of styles:\n\t\t\/\/\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\n\t\t\/\/\t|\tdojo.setAttr(\"someNode\", \"style\", obj);\n\t\t\/\/\t|\n\t\t\/\/\t|\t\/\/ though shorter to use `dojo.style()` in this case:\n\t\t\/\/\t|\tdojo.setStyle(\"someNode\", obj);\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.removeAttr = function(node, name){\n\t\t\/\/ summary:\n\t\t\/\/\t\tRemoves an attribute from an HTML element.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to the element to remove the attribute from\n\t\t\/\/ name: String\n\t\t\/\/\t\tthe name of the attribute to remove\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.getNodeProp = function(node, name){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns an effective value of a property or an attribute.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to the element to remove the attribute from\n\t\t\/\/ name: String\n\t\t\/\/\t\tthe name of the attribute\n\t\t\/\/ returns:\n\t\t\/\/      the value of the attribute\n\t};\n\t=====*\/\n\n\tvar forcePropNames = {\n\t\t\tinnerHTML:\t1,\n\t\t\tclassName:\t1,\n\t\t\thtmlFor:\thas(\"ie\"),\n\t\t\tvalue:\t\t1\n\t\t},\n\t\tattrNames = {\n\t\t\t\/\/ original attribute names\n\t\t\tclassname: \"class\",\n\t\t\thtmlfor: \"for\",\n\t\t\t\/\/ for IE\n\t\t\ttabindex: \"tabIndex\",\n\t\t\treadonly: \"readOnly\"\n\t\t},\n\t\tattr; \/\/ the result object\n\n\tfunction _hasAttr(node, name){\n\t\tvar attr = node.getAttributeNode && node.getAttributeNode(name);\n\t\treturn attr && attr.specified; \/\/ Boolean\n\t}\n\n\t\/\/ There is a difference in the presence of certain properties and their default values\n\t\/\/ between browsers. For example, on IE \"disabled\" is present on all elements,\n\t\/\/ but it is value is \"false\"; \"tabIndex\" of <div> returns 0 by default on IE, yet other browsers\n\t\/\/ can return -1.\n\n\tattr = {\n\t\thas: function hasAttr(\/*DOMNode|String*\/node, \/*String*\/name){\n\t\t\tvar lc = name.toLowerCase();\n\t\t\treturn forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);\t\/\/ Boolean\n\t\t},\n\n\t\tget: function getAttr(\/*DOMNode|String*\/node, \/*String*\/name){\n\t\t\tnode = dom.byId(node);\n\t\t\tvar lc = name.toLowerCase(),\n\t\t\t\tpropName = prop.names[lc] || name,\n\t\t\t\tforceProp = forcePropNames[propName];\n\t\t\t\/\/ should we access this attribute via a property or via getAttribute()?\n\t\t\tvalue = node[propName];\n\t\t\tif(forceProp && typeof value != \"undefined\"){\n\t\t\t\t\/\/ node's property\n\t\t\t\treturn value;\t\/\/ Anything\n\t\t\t}\n\t\t\tif(propName != \"href\" && (typeof value == \"boolean\" || lang.isFunction(value))){\n\t\t\t\t\/\/ node's property\n\t\t\t\treturn value;\t\/\/ Anything\n\t\t\t}\n\t\t\t\/\/ node's attribute\n\t\t\t\/\/ we need _hasAttr() here to guard against IE returning a default value\n\t\t\tvar attrName = attrNames[lc] || name;\n\t\t\treturn _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; \/\/ Anything\n\t\t},\n\n\t\tset: function setAttr(\/*DOMNode|String*\/node, \/*String|Object*\/name, \/*String?*\/value){\n\t\t\tnode = dom.byId(node);\n\t\t\tif(arguments.length == 2){ \/\/ inline'd type check\n\t\t\t\t\/\/ the object form of setter: the 2nd argument is a dictionary\n\t\t\t\tfor(var x in name){\n\t\t\t\t\tattr.set(node, x, name[x]);\n\t\t\t\t}\n\t\t\t\treturn node; \/\/ DomNode\n\t\t\t}\n\t\t\tvar lc = name.toLowerCase(),\n\t\t\t\tpropName = prop.names[lc] || name,\n\t\t\t\tforceProp = forcePropNames[propName];\n\t\t\tif(propName == \"style\" && typeof value != \"string\"){ \/\/ inline'd type check\n\t\t\t\t\/\/ special case: setting a style\n\t\t\t\tstyle.set(node, value);\n\t\t\t\treturn node; \/\/ DomNode\n\t\t\t}\n\t\t\tif(forceProp || typeof value == \"boolean\" || lang.isFunction(value)){\n\t\t\t\treturn prop.set(node, name, value)\n\t\t\t}\n\t\t\t\/\/ node's attribute\n\t\t\tnode.setAttribute(attrNames[lc] || name, value);\n\t\t\treturn node; \/\/ DomNode\n\t\t},\n\n\t\tremove: function removeAttr(\/*DOMNode|String*\/ node, \/*String*\/ name){\n\t\t\tdom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);\n\t\t},\n\n\t\tgetNodeProp: function getNodeProp(\/*DomNode|String*\/ node, \/*String*\/ name){\n\t\t\tnode = dom.byId(node);\n\t\t\tvar lc = name.toLowerCase(), propName = prop.names[lc] || name;\n\t\t\tif((propName in node) && propName != \"href\"){\n\t\t\t\t\/\/ node's property\n\t\t\t\treturn node[propName];\t\/\/ Anything\n\t\t\t}\n\t\t\t\/\/ node's attribute\n\t\t\tvar attrName = attrNames[lc] || name;\n\t\t\treturn _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; \/\/ Anything\n\t\t}\n\t};\n\n\treturn attr;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/_base\/sniff","dojo\/_base\/lang","dojo\/dom","dojo\/dom-style","dojo\/dom-prop"]},"dojo\/dom-prop":{"id":"dojo\/dom-prop","url":"\/home\/arian\/www\/MooTools\/dojo\/dom-prop.js","package":"dojo","amd":true,"content":"define([\".\/_base\/kernel\", \".\/_base\/sniff\", \".\/_base\/lang\", \".\/dom\", \".\/dom-style\", \".\/_base\/connect\"],\n\t\tfunction(dojo, has, lang, dom, style, connect){\n\t\/\/ module:\n\t\/\/\t\tdojo\/dom-prop\n\t\/\/ summary:\n\t\/\/\t\tThis module defines the core dojo DOM properties API.\n\t\/\/      Indirectly depends on dojo.empty() and dojo.toDom().\n\n\t\/\/ =============================\n\t\/\/ Element properties Functions\n\t\/\/ =============================\n\n\t\/*=====\n\tprop.get = function(\/node, name){\n\t\t\/\/ summary:\n\t\t\/\/\t\tGets a property on an HTML element.\n\t\t\/\/ description:\n\t\t\/\/\t\tHandles normalized getting of properties on DOM nodes.\n\t\t\/\/\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to the element to get the property on\n\t\t\/\/ name: String\n\t\t\/\/\t\tthe name of the property to get.\n\t\t\/\/ returns:\n\t\t\/\/\t\tthe value of the requested property or its default value\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t|\t\/\/ get the current value of the \"foo\" property on a node\n\t\t\/\/\t|\tdojo.getProp(dojo.byId(\"nodeId\"), \"foo\");\n\t\t\/\/\t|\t\/\/ or we can just pass the id:\n\t\t\/\/\t|\tdojo.getProp(\"nodeId\", \"foo\");\n\t};\n\t=====*\/\n\n\t\/*=====\n\tprop.set = function(node, name, value){\n\t\t\/\/ summary:\n\t\t\/\/\t\tSets a property on an HTML element.\n\t\t\/\/ description:\n\t\t\/\/\t\tHandles normalized setting of properties on DOM nodes.\n\t\t\/\/\n\t\t\/\/\t\tWhen passing functions as values, note that they will not be\n\t\t\/\/\t\tdirectly assigned to slots on the node, but rather the default\n\t\t\/\/\t\tbehavior will be removed and the new behavior will be added\n\t\t\/\/\t\tusing `dojo.connect()`, meaning that event handler properties\n\t\t\/\/\t\twill be normalized and that some caveats with regards to\n\t\t\/\/\t\tnon-standard behaviors for onsubmit apply. Namely that you\n\t\t\/\/\t\tshould cancel form submission using `dojo.stopEvent()` on the\n\t\t\/\/\t\tpassed event object instead of returning a boolean value from\n\t\t\/\/\t\tthe handler itself.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or reference to the element to set the property on\n\t\t\/\/ name: String|Object\n\t\t\/\/\t\tthe name of the property to set, or a hash object to set\n\t\t\/\/\t\tmultiple properties at once.\n\t\t\/\/ value: String?\n\t\t\/\/\t\tThe value to set for the property\n\t\t\/\/ returns:\n\t\t\/\/\t\tthe DOM node\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t|\t\/\/ use prop() to set the tab index\n\t\t\/\/\t|\tdojo.setProp(\"nodeId\", \"tabIndex\", 3);\n\t\t\/\/\t|\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tSet multiple values at once, including event handlers:\n\t\t\/\/\t|\tdojo.setProp(\"formId\", {\n\t\t\/\/\t|\t\t\"foo\": \"bar\",\n\t\t\/\/\t|\t\t\"tabIndex\": -1,\n\t\t\/\/\t|\t\t\"method\": \"POST\",\n\t\t\/\/\t|\t\t\"onsubmit\": function(e){\n\t\t\/\/\t|\t\t\t\/\/ stop submitting the form. Note that the IE behavior\n\t\t\/\/\t|\t\t\t\/\/ of returning true or false will have no effect here\n\t\t\/\/\t|\t\t\t\/\/ since our handler is connect()ed to the built-in\n\t\t\/\/\t|\t\t\t\/\/ onsubmit behavior and so we need to use\n\t\t\/\/\t|\t\t\t\/\/ dojo.stopEvent() to ensure that the submission\n\t\t\/\/\t|\t\t\t\/\/ doesn't proceed.\n\t\t\/\/\t|\t\t\tdojo.stopEvent(e);\n\t\t\/\/\t|\n\t\t\/\/\t|\t\t\t\/\/ submit the form with Ajax\n\t\t\/\/\t|\t\t\tdojo.xhrPost({ form: \"formId\" });\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tStyle is s special case: Only set with an object hash of styles\n\t\t\/\/\t|\tdojo.setProp(\"someNode\",{\n\t\t\/\/\t|\t\tid:\"bar\",\n\t\t\/\/\t|\t\tstyle:{\n\t\t\/\/\t|\t\t\twidth:\"200px\", height:\"100px\", color:\"#000\"\n\t\t\/\/\t|\t\t}\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tAgain, only set style as an object hash of styles:\n\t\t\/\/\t|\tvar obj = { color:\"#fff\", backgroundColor:\"#000\" };\n\t\t\/\/\t|\tdojo.setProp(\"someNode\", \"style\", obj);\n\t\t\/\/\t|\n\t\t\/\/\t|\t\/\/ though shorter to use `dojo.style()` in this case:\n\t\t\/\/\t|\tdojo.style(\"someNode\", obj);\n\t};\n\t=====*\/\n\n\t\/\/ helper to connect events\n\tvar _evtHdlrMap = {}, _ctr = 0, _attrId = dojo._scopeName + \"attrid\";\n\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\/\/ the next dictionary lists elements with read-only innerHTML on IE\n\tvar _roInnerHtml = {col: 1, colgroup: 1,\n\t\t\t\/\/ frameset: 1, head: 1, html: 1, style: 1,\n\t\t\ttable: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1};\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\n\tvar prop = {\n\t\tnames: {\n\t\t\t\/\/ properties renamed to avoid clashes with reserved words\n\t\t\t\"class\": \"className\",\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\/\/ properties written as camelCase\n\t\t\ttabindex: \"tabIndex\",\n\t\t\treadonly: \"readOnly\",\n\t\t\tcolspan: \"colSpan\",\n\t\t\tframeborder: \"frameBorder\",\n\t\t\trowspan: \"rowSpan\",\n\t\t\tvaluetype: \"valueType\"\n\t\t},\n\n\t\tget: function getProp(\/*DOMNode|String*\/node, \/*String*\/name){\n\t\t\tnode = dom.byId(node);\n\t\t\tvar lc = name.toLowerCase(), propName = prop.names[lc] || name;\n\t\t\treturn node[propName];\t\/\/ Anything\n\t\t},\n\n\t\tset: function setProp(\/*DOMNode|String*\/node, \/*String|Object*\/name, \/*String?*\/value){\n\t\t\tnode = dom.byId(node);\n\t\t\tvar l = arguments.length;\n\t\t\tif(l == 2 && typeof name != \"string\"){ \/\/ inline'd type check\n\t\t\t\t\/\/ the object form of setter: the 2nd argument is a dictionary\n\t\t\t\tfor(var x in name){\n\t\t\t\t\tprop.set(node, x, name[x]);\n\t\t\t\t}\n\t\t\t\treturn node; \/\/ DomNode\n\t\t\t}\n\t\t\tvar lc = name.toLowerCase(), propName = prop.names[lc] || name;\n\t\t\tif(propName == \"style\" && typeof value != \"string\"){ \/\/ inline'd type check\n\t\t\t\t\/\/ special case: setting a style\n\t\t\t\tstyle.style(node, value);\n\t\t\t\treturn node; \/\/ DomNode\n\t\t\t}\n\t\t\tif(propName == \"innerHTML\"){\n\t\t\t\t\/\/ special case: assigning HTML\n\t\t\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\t\t\tif(has(\"ie\") && node.tagName.toLowerCase() in _roInnerHtml){\n\t\t\t\t\tdojo.empty(node);\n\t\t\t\t\tnode.appendChild(dojo.toDom(value, node.ownerDocument));\n\t\t\t\t}else{\n\t\t\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\t\t\t\tnode[propName] = value;\n\t\t\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\t\t\t}\n\t\t\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\t\t\treturn node; \/\/ DomNode\n\t\t\t}\n\t\t\tif(lang.isFunction(value)){\n\t\t\t\t\/\/ special case: assigning an event handler\n\t\t\t\t\/\/ clobber if we can\n\t\t\t\tvar attrId = node[_attrId];\n\t\t\t\tif(!attrId){\n\t\t\t\t\tattrId = _ctr++;\n\t\t\t\t\tnode[_attrId] = attrId;\n\t\t\t\t}\n\t\t\t\tif(!_evtHdlrMap[attrId]){\n\t\t\t\t\t_evtHdlrMap[attrId] = {};\n\t\t\t\t}\n\t\t\t\tvar h = _evtHdlrMap[attrId][propName];\n\t\t\t\tif(h){\n\t\t\t\t\tdojo.disconnect(h);\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tdelete node[propName];\n\t\t\t\t\t}catch(e){}\n\t\t\t\t}\n\t\t\t\t\/\/ ensure that event objects are normalized, etc.\n\t\t\t\tif(value){\n\t\t\t\t\t_evtHdlrMap[attrId][propName] = dojo.connect(node, propName, value);\n\t\t\t\t}else{\n\t\t\t\t\tnode[propName] = null;\n\t\t\t\t}\n\t\t\t\treturn node; \/\/ DomNode\n\t\t\t}\n\t\t\tnode[propName] = value;\n\t\t\treturn node;\t\/\/ DomNode\n\t\t}\n\t};\n\n\treturn prop;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/_base\/sniff","dojo\/_base\/lang","dojo\/dom","dojo\/dom-style","dojo\/_base\/connect"]},"dojo\/_base\/connect":{"id":"dojo\/_base\/connect","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/connect.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \"..\/on\", \"..\/aspect\", \".\/event\", \"..\/mouse\", \".\/sniff\", \".\/lang\", \"..\/keys\"], function(kernel, on, aspect, eventModule, mouse, has, lang){\n\/\/  module:\n\/\/    dojo\/_base\/connect\n\/\/  summary:\n\/\/    This module defines the dojo.connect API.\n\/\/\t\tThis modules also provides keyboard event handling helpers.\n\/\/\t\tThis module exports an extension event for emulating Firefox's keypress handling.\n\/\/\t\tHowever, this extension event exists primarily for backwards compatibility and\n\/\/\t\tis not recommended. WebKit and IE uses an alternate keypress handling (only\n\/\/\t\tfiring for printable characters, to distinguish from keydown events), and most\n\/\/\t\tconsider the WebKit\/IE behavior more desirable.\nhas.add(\"events-keypress-typed\", function(){ \/\/ keypresses should only occur a printable character is hit\n\tvar testKeyEvent = {charCode: 0};\n\ttry{\n\t\ttestKeyEvent = document.createEvent(\"KeyboardEvent\");\n\t\t(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, \"keypress\", true, true, null, false, false, false, false, 9, 3);\n\t}catch(e){}\n\treturn testKeyEvent.charCode == 0 && !has(\"opera\");\n});\n\nfunction connect_(obj, event, context, method, dontFix){\n\tif(typeof event == \"string\" && event.substring(0, 2) == \"on\"){\n\t\tevent = event.substring(2);\n\t}else if(!obj || !(obj.addEventListener || obj.attachEvent)){\n\t\t\/\/ it is a not a DOM node and we are using the dojo.connect style of treating a\n\t\t\/\/ method like an event, must go right to aspect\n\t\treturn aspect.after(obj || kernel.global, event, lang.hitch(context, method), true);\n\t}\n\tif(!obj){\n\t\tobj = kernel.global;\n\t}\n\tif(!dontFix){\n\t\tswitch(event){\n\t\t\t\/\/ dojo.connect has special handling for these event types\n\t\t\tcase \"keypress\":\n\t\t\t\tevent = keypress;\n\t\t\t\tbreak;\n\t\t\tcase \"mouseenter\":\n\t\t\t\tevent = mouse.enter;\n\t\t\t\tbreak;\n\t\t\tcase \"mouseleave\":\n\t\t\t\tevent = mouse.leave;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn on(obj, event, lang.hitch(context, method), dontFix);\n};\n\nvar _punctMap = {\n\t106:42,\n\t111:47,\n\t186:59,\n\t187:43,\n\t188:44,\n\t189:45,\n\t190:46,\n\t191:47,\n\t192:96,\n\t219:91,\n\t220:92,\n\t221:93,\n\t222:39,\n\t229:113\n};\nvar evtCopyKey = has(\"mac\") ? \"metaKey\" : \"ctrlKey\";\n\n\nvar _synthesizeEvent = function(evt, props){\n\tvar faux = lang.mixin({}, evt, props);\n\tsetKeyChar(faux);\n\t\/\/ FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);\n\t\/\/ but it throws an error when preventDefault is invoked on Safari\n\t\/\/ does Event.preventDefault not support \"apply\" on Safari?\n\tfaux.preventDefault = function(){ evt.preventDefault(); };\n\tfaux.stopPropagation = function(){ evt.stopPropagation(); };\n\treturn faux;\n};\nfunction setKeyChar(evt){\n\tevt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';\n\tevt.charOrCode = evt.keyChar || evt.keyCode;\n}\nvar keypress;\nif(has(\"events-keypress-typed\")){\n\t\/\/ this emulates Firefox's keypress behavior where every keydown can correspond to a keypress\n\tvar _trySetKeyCode = function(e, code){\n\t\ttry{\n\t\t\t\/\/ squelch errors when keyCode is read-only\n\t\t\t\/\/ (e.g. if keyCode is ctrl or shift)\n\t\t\treturn (e.keyCode = code);\n\t\t}catch(e){\n\t\t\treturn 0;\n\t\t}\n\t};\n\tkeypress = function(object, listener){\n\t\tvar keydownSignal = on(object, \"keydown\", function(evt){\n\t\t\t\/\/ munge key\/charCode\n\t\t\tvar k=evt.keyCode;\n\t\t\t\/\/ These are Windows Virtual Key Codes\n\t\t\t\/\/ http:\/\/msdn.microsoft.com\/library\/default.asp?url=\/library\/en-us\/winui\/WinUI\/WindowsUserInterface\/UserInput\/VirtualKeyCodes.asp\n\t\t\tvar unprintable = (k!=13 || (has(\"ie\") >= 9 && !has(\"quirks\"))) && k!=32 && (k!=27||!has(\"ie\")) && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222) && k!=229;\n\t\t\t\/\/ synthesize keypress for most unprintables and CTRL-keys\n\t\t\tif(unprintable||evt.ctrlKey){\n\t\t\t\tvar c = unprintable ? 0 : k;\n\t\t\t\tif(evt.ctrlKey){\n\t\t\t\t\tif(k==3 || k==13){\n\t\t\t\t\t\treturn listener.call(evt.currentTarget, evt); \/\/ IE will post CTRL-BREAK, CTRL-ENTER as keypress natively\n\t\t\t\t\t}else if(c>95 && c<106){\n\t\t\t\t\t\tc -= 48; \/\/ map CTRL-[numpad 0-9] to ASCII\n\t\t\t\t\t}else if((!evt.shiftKey)&&(c>=65&&c<=90)){\n\t\t\t\t\t\tc += 32; \/\/ map CTRL-[A-Z] to lowercase\n\t\t\t\t\t}else{\n\t\t\t\t\t\tc = _punctMap[c] || c; \/\/ map other problematic CTRL combinations to ASCII\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\/\/ simulate a keypress event\n\t\t\t\tvar faux = _synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});\n\t\t\t\tlistener.call(evt.currentTarget, faux);\n\t\t\t\tif(has(\"ie\")){\n\t\t\t\t\t_trySetKeyCode(evt, faux.keyCode);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvar keypressSignal = on(object, \"keypress\", function(evt){\n\t\t\tvar c = evt.charCode;\n\t\t\tc = c>=32 ? c : 0;\n\t\t\tevt = _synthesizeEvent(evt, {charCode: c, faux: true});\n\t\t\treturn listener.call(this, evt);\n\t\t});\n\t\treturn {\n\t\t\tremove: function(){\n\t\t\t\tkeydownSignal.remove();\n\t\t\t\tkeypressSignal.remove();\n\t\t\t}\n\t\t};\n\t};\n}else{\n\tif(has(\"opera\")){\n\t\tkeypress = function(object, listener){\n\t\t\treturn on(object, \"keypress\", function(evt){\n\t\t\t\tvar c = evt.which;\n\t\t\t\tif(c==3){\n\t\t\t\t\tc=99; \/\/ Mozilla maps CTRL-BREAK to CTRL-c\n\t\t\t\t}\n\t\t\t\t\/\/ can't trap some keys at all, like INSERT and DELETE\n\t\t\t\t\/\/ there is no differentiating info between DELETE and \".\", or INSERT and \"-\"\n\t\t\t\tc = c<32 && !evt.shiftKey ? 0 : c;\n\t\t\t\tif(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){\n\t\t\t\t\t\/\/ lowercase CTRL-[A-Z] keys\n\t\t\t\t\tc += 32;\n\t\t\t\t}\n\t\t\t\treturn listener.call(this, _synthesizeEvent(evt, { charCode: c }));\n\t\t\t});\n\t\t};\n\t}else{\n\t\tkeypress = function(object, listener){\n\t\t\treturn on(object, \"keypress\", function(evt){\n\t\t\t\tsetKeyChar(evt);\n\t\t\t\treturn listener.call(this, evt);\n\t\t\t});\n\t\t};\n\t}\n}\n\nvar connect = {\n\t_keypress:keypress,\n\n\tconnect:function(obj, event, context, method, dontFix){\n\t\t\/\/ normalize arguments\n\t\tvar a=arguments, args=[], i=0;\n\t\t\/\/ if a[0] is a String, obj was omitted\n\t\targs.push(typeof a[0] == \"string\" ? null : a[i++], a[i++]);\n\t\t\/\/ if the arg-after-next is a String or Function, context was NOT omitted\n\t\tvar a1 = a[i+1];\n\t\targs.push(typeof a1 == \"string\" || typeof a1 == \"function\" ? a[i++] : null, a[i++]);\n\t\t\/\/ absorb any additional arguments\n\t\tfor(var l=a.length; i<l; i++){\targs.push(a[i]); }\n\t\treturn connect_.apply(this, args);\n\t},\n\n\tdisconnect:function(handle){\n\t\tif(handle){\n\t\t\thandle.remove();\n\t\t}\n\t},\n\n\tsubscribe:function(topic, context, method){\n\t\treturn on(topic, lang.hitch(context, method));\n\t},\n\n\tpublish:function(topic, args){\n\t\ttopic = \"on\" + topic;\n\t\ton[topic] && on[topic].apply(this, args || []);\n\t},\n\n\tconnectPublisher:function(topic, obj, event){\n\t\tvar pf = function(){ connect.publish(topic, arguments); };\n\t\treturn event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); \/\/Handle\n\t},\n\n\tisCopyKey: function(e){\n\t\treturn e[evtCopyKey];\t\/\/ Boolean\n\t}\n};\nconnect.unsubscribe = connect.disconnect;\n\nhas(\"dojo-1x-base\") && lang.mixin(kernel, connect);\nreturn connect;\n\n\/*=====\ndojo.connect = function(obj, event, context, method, dontFix){\n\t\/\/ summary:\n\t\/\/\t\t`dojo.connect` is the core event handling and delegation method in\n\t\/\/\t\tDojo. It allows one function to \"listen in\" on the execution of\n\t\/\/\t\tany other, triggering the second whenever the first is called. Many\n\t\/\/\t\tlisteners may be attached to a function, and source functions may\n\t\/\/\t\tbe either regular function calls or DOM events.\n\t\/\/\n\t\/\/ description:\n\t\/\/\t\tConnects listeners to actions, so that after event fires, a\n\t\/\/\t\tlistener is called with the same arguments passed to the original\n\t\/\/\t\tfunction.\n\t\/\/\n\t\/\/\t\tSince `dojo.connect` allows the source of events to be either a\n\t\/\/\t\t\"regular\" JavaScript function or a DOM event, it provides a uniform\n\t\/\/\t\tinterface for listening to all the types of events that an\n\t\/\/\t\tapplication is likely to deal with though a single, unified\n\t\/\/\t\tinterface. DOM programmers may want to think of it as\n\t\/\/\t\t\"addEventListener for everything and anything\".\n\t\/\/\n\t\/\/\t\tWhen setting up a connection, the `event` parameter must be a\n\t\/\/\t\tstring that is the name of the method\/event to be listened for. If\n\t\/\/\t\t`obj` is null, `kernel.global` is assumed, meaning that connections\n\t\/\/\t\tto global methods are supported but also that you may inadvertently\n\t\/\/\t\tconnect to a global by passing an incorrect object name or invalid\n\t\/\/\t\treference.\n\t\/\/\n\t\/\/\t\t`dojo.connect` generally is forgiving. If you pass the name of a\n\t\/\/\t\tfunction or method that does not yet exist on `obj`, connect will\n\t\/\/\t\tnot fail, but will instead set up a stub method. Similarly, null\n\t\/\/\t\targuments may simply be omitted such that fewer than 4 arguments\n\t\/\/\t\tmay be required to set up a connection See the examples for details.\n\t\/\/\n\t\/\/\t\tThe return value is a handle that is needed to\n\t\/\/\t\tremove this connection with `dojo.disconnect`.\n\t\/\/\n\t\/\/ obj: Object|null:\n\t\/\/\t\tThe source object for the event function.\n\t\/\/\t\tDefaults to `kernel.global` if null.\n\t\/\/\t\tIf obj is a DOM node, the connection is delegated\n\t\/\/\t\tto the DOM event manager (unless dontFix is true).\n\t\/\/\n\t\/\/ event: String:\n\t\/\/\t\tString name of the event function in obj.\n\t\/\/\t\tI.e. identifies a property `obj[event]`.\n\t\/\/\n\t\/\/ context: Object|null\n\t\/\/\t\tThe object that method will receive as \"this\".\n\t\/\/\n\t\/\/\t\tIf context is null and method is a function, then method\n\t\/\/\t\tinherits the context of event.\n\t\/\/\n\t\/\/\t\tIf method is a string then context must be the source\n\t\/\/\t\tobject object for method (context[method]). If context is null,\n\t\/\/\t\tkernel.global is used.\n\t\/\/\n\t\/\/ method: String|Function:\n\t\/\/\t\tA function reference, or name of a function in context.\n\t\/\/\t\tThe function identified by method fires after event does.\n\t\/\/\t\tmethod receives the same arguments as the event.\n\t\/\/\t\tSee context argument comments for information on method's scope.\n\t\/\/\n\t\/\/ dontFix: Boolean?\n\t\/\/\t\tIf obj is a DOM node, set dontFix to true to prevent delegation\n\t\/\/\t\tof this connection to the DOM event manager.\n\t\/\/\n\t\/\/ example:\n\t\/\/\t\tWhen obj.onchange(), do ui.update():\n\t\/\/\t|\tdojo.connect(obj, \"onchange\", ui, \"update\");\n\t\/\/\t|\tdojo.connect(obj, \"onchange\", ui, ui.update); \/\/ same\n\t\/\/\n\t\/\/ example:\n\t\/\/\t\tUsing return value for disconnect:\n\t\/\/\t|\tvar link = dojo.connect(obj, \"onchange\", ui, \"update\");\n\t\/\/\t|\t...\n\t\/\/\t|\tdojo.disconnect(link);\n\t\/\/\n\t\/\/ example:\n\t\/\/\t\tWhen onglobalevent executes, watcher.handler is invoked:\n\t\/\/\t|\tdojo.connect(null, \"onglobalevent\", watcher, \"handler\");\n\t\/\/\n\t\/\/ example:\n\t\/\/\t\tWhen ob.onCustomEvent executes, customEventHandler is invoked:\n\t\/\/\t|\tdojo.connect(ob, \"onCustomEvent\", null, \"customEventHandler\");\n\t\/\/\t|\tdojo.connect(ob, \"onCustomEvent\", \"customEventHandler\"); \/\/ same\n\t\/\/\n\t\/\/ example:\n\t\/\/\t\tWhen ob.onCustomEvent executes, customEventHandler is invoked\n\t\/\/\t\twith the same scope (this):\n\t\/\/\t|\tdojo.connect(ob, \"onCustomEvent\", null, customEventHandler);\n\t\/\/\t|\tdojo.connect(ob, \"onCustomEvent\", customEventHandler); \/\/ same\n\t\/\/\n\t\/\/ example:\n\t\/\/\t\tWhen globalEvent executes, globalHandler is invoked\n\t\/\/\t\twith the same scope (this):\n\t\/\/\t|\tdojo.connect(null, \"globalEvent\", null, globalHandler);\n\t\/\/\t|\tdojo.connect(\"globalEvent\", globalHandler); \/\/ same\n}\n=====*\/\n\n\/*=====\ndojo.disconnect = function(handle){\n\t\/\/ summary:\n\t\/\/\t\tRemove a link created by dojo.connect.\n\t\/\/ description:\n\t\/\/\t\tRemoves the connection between event and the method referenced by handle.\n\t\/\/ handle: Handle:\n\t\/\/\t\tthe return value of the dojo.connect call that created the connection.\n}\n=====*\/\n\n\/*=====\ndojo.subscribe = function(topic, context, method){\n\t\/\/\tsummary:\n\t\/\/\t\tAttach a listener to a named topic. The listener function is invoked whenever the\n\t\/\/\t\tnamed topic is published (see: dojo.publish).\n\t\/\/\t\tReturns a handle which is needed to unsubscribe this listener.\n\t\/\/\ttopic: String:\n\t\/\/\t\tThe topic to which to subscribe.\n\t\/\/\tcontext: Object|null:\n\t\/\/\t\tScope in which method will be invoked, or null for default scope.\n\t\/\/\tmethod: String|Function:\n\t\/\/\t\tThe name of a function in context, or a function reference. This is the function that\n\t\/\/\t\tis invoked when topic is published.\n\t\/\/\texample:\n\t\/\/\t|\tdojo.subscribe(\"alerts\", null, function(caption, message){ alert(caption + \"\\n\" + message); });\n\t\/\/\t|\tdojo.publish(\"alerts\", [ \"read this\", \"hello world\" ]);\n}\n=====*\/\n\n\/*=====\ndojo.unsubscribe = function(handle){\n\t\/\/\tsummary:\n\t\/\/\t\tRemove a topic listener.\n\t\/\/\thandle: Handle\n\t\/\/\t\tThe handle returned from a call to subscribe.\n\t\/\/\texample:\n\t\/\/\t|\tvar alerter = dojo.subscribe(\"alerts\", null, function(caption, message){ alert(caption + \"\\n\" + message); };\n\t\/\/\t|\t...\n\t\/\/\t|\tdojo.unsubscribe(alerter);\n}\n=====*\/\n\n\/*=====\ndojo.publish = function(topic, args){\n\t\/\/\tsummary:\n\t\/\/\t\tInvoke all listener method subscribed to topic.\n\t\/\/\ttopic: String:\n\t\/\/\t\tThe name of the topic to publish.\n\t\/\/\targs: Array?\n\t\/\/\t\tAn array of arguments. The arguments will be applied\n\t\/\/\t\tto each topic subscriber (as first class parameters, via apply).\n\t\/\/\texample:\n\t\/\/\t|\tdojo.subscribe(\"alerts\", null, function(caption, message){ alert(caption + \"\\n\" + message); };\n\t\/\/\t|\tdojo.publish(\"alerts\", [ \"read this\", \"hello world\" ]);\n}\n=====*\/\n\n\/*=====\ndojo.connectPublisher = function(topic, obj, event){\n\t\/\/\tsummary:\n\t\/\/\t\tEnsure that every time obj.event() is called, a message is published\n\t\/\/\t\ton the topic. Returns a handle which can be passed to\n\t\/\/\t\tdojo.disconnect() to disable subsequent automatic publication on\n\t\/\/\t\tthe topic.\n\t\/\/\ttopic: String:\n\t\/\/\t\tThe name of the topic to publish.\n\t\/\/\tobj: Object|null:\n\t\/\/\t\tThe source object for the event function. Defaults to kernel.global\n\t\/\/\t\tif null.\n\t\/\/\tevent: String:\n\t\/\/\t\tThe name of the event function in obj.\n\t\/\/\t\tI.e. identifies a property obj[event].\n\t\/\/\texample:\n\t\/\/\t|\tdojo.connectPublisher(\"\/ajax\/start\", dojo, \"xhrGet\");\n}\n=====*\/\n\n\/*=====\ndojo.isCopyKey = function(e){\n\t\/\/ summary:\n\t\/\/\t\tChecks an event for the copy key (meta on Mac, and ctrl anywhere else)\n\t\/\/ e: Event\n\t\/\/\t\tEvent object to examine\n}\n=====*\/\n\n});\n\n\n","dependencies":["dojo\/_base\/kernel","dojo\/on","dojo\/aspect","dojo\/_base\/event","dojo\/mouse","dojo\/_base\/sniff","dojo\/_base\/lang","dojo\/keys"]},"dojo\/on":{"id":"dojo\/on","url":"\/home\/arian\/www\/MooTools\/dojo\/on.js","package":"dojo","amd":true,"content":"define([\".\/aspect\", \".\/_base\/kernel\", \".\/has\"], function(aspect, dojo, has){\r\n\t\/\/ summary:\r\n\t\/\/\t\tThe export of this module is a function that provides core event listening functionality. With this function\r\n\t\/\/\t\tyou can provide a target, event type, and listener to be notified of\r\n\t\/\/\t\tfuture matching events that are fired.\r\n\t\/\/ target: Element|Object\r\n\t\/\/\t\tThis is the target object or DOM element that to receive events from\r\n\t\/\/ type: String|Function\r\n\t\/\/ \t\tThis is the name of the event to listen for or an extension event type.\r\n\t\/\/ listener: Function\r\n\t\/\/ \t\tThis is the function that should be called when the event fires.\r\n\t\/\/ returns: Object\r\n\t\/\/ \t\tAn object with a remove() method that can be used to stop listening for this\r\n\t\/\/ \t\tevent.\r\n\t\/\/ description:\r\n\t\/\/ \t\tTo listen for \"click\" events on a button node, we can do:\r\n\t\/\/ \t\t|\tdefine([\"dojo\/on\"], function(listen){\r\n\t\/\/ \t\t|\t\ton(button, \"click\", clickHandler);\r\n\t\/\/\t\t|\t\t...\r\n\t\/\/  \tPlain JavaScript objects can also have their own events.\r\n\t\/\/ \t\t|\tvar obj = {};\r\n\t\/\/\t\t|\ton(obj, \"foo\", fooHandler);\r\n\t\/\/\t\tAnd then we could publish a \"foo\" event:\r\n\t\/\/\t\t|\ton.emit(obj, \"foo\", {key: \"value\"});\r\n\t\/\/\t\tWe can use extension events as well. For example, you could listen for a tap gesture:\r\n\t\/\/ \t\t|\tdefine([\"dojo\/on\", \"dojo\/gesture\/tap\", function(listen, tap){\r\n\t\/\/ \t\t|\t\ton(button, tap, tapHandler);\r\n\t\/\/\t\t|\t\t...\r\n\t\/\/\t\twhich would trigger fooHandler. Note that for a simple object this is equivalent to calling:\r\n\t\/\/\t\t|\tobj.onfoo({key:\"value\"});\r\n\t\/\/\t\tIf you use on.emit on a DOM node, it will use native event dispatching when possible.\r\n\t\/\/\t\tYou can also use listen function itself as a pub\/sub hub:\r\n\t\/\/\t\t| \ton(\"some\/topic\", function(event){\r\n\t\/\/\t\t|\t... do something with event\r\n\t\/\/\t\t|\t});\r\n\t\/\/\t\t|\ton.publish(\"some\/topic\", {name:\"some event\", ...});\r\n\t\/\/ Evented:\r\n\t\/\/ \t\tThe \"Evented\" property of the export of this module can be used as a mixin or base class, to add on() and emit() methods to a class\r\n\t\/\/ \t\tfor listening for events and emiting events:\r\n\t\/\/ \t\t|\tvar Evented = on.Evented;\r\n\t\/\/ \t\t|\tvar EventedWidget = dojo.declare([Evented, dijit._Widget], {...});\r\n\t\/\/\t\t|\twidget = new EventedWidget();\r\n\t\/\/\t\t|\twidget.on(\"open\", function(event){\r\n\t\/\/\t\t|\t... do something with event\r\n\t\/\/\t\t|\t });\r\n\t\/\/\t\t|\r\n\t\/\/\t\t|\twidget.emit(\"open\", {name:\"some event\", ...});\r\n\r\n \t\"use strict\";\r\n\tvar after = aspect.after;\r\n\tif(has(\"dom\")){ \/\/ check to make sure we are in a browser, this module should work anywhere\r\n\t\tvar major = window.ScriptEngineMajorVersion;\r\n\t\thas.add(\"jscript\", major && (major() + ScriptEngineMinorVersion() \/ 10));\r\n\t\thas.add(\"event-orientationchange\", has(\"touch\") && !has(\"android\")); \/\/ TODO: how do we detect this?\r\n\t}\r\n\tvar on = function(target, type, listener, dontFix){\r\n\t\tif(!listener){\r\n\t\t\t\/\/ two args, do pub\/sub or window listening\r\n\t\t\t\/\/ if there is a window event for the given target, we will target the window\r\n\t\t\treturn on(has(\"dom\") && (\"on\" + target) in window ? window : on, \r\n\t\t\t\ttarget, type);\r\n\t\t}\r\n\t\tif(target.on){ \r\n\t\t\t\/\/ delegate to the target's on() method, so it can handle it's own listening if it wants\r\n\t\t\treturn target.on(type, listener);\r\n\t\t}\r\n\t\t\/\/ delegate to main listener code\r\n\t\treturn addListener(target, type, listener, dontFix, this);\r\n\t};\r\n\ton.pausable =  function(target, type, listener, dontFix){\r\n\t\t\/\/ summary:\r\n\t\t\/\/\t\tThis function acts the same as on(), but with pausable functionality. The\r\n\t\t\/\/ \t\treturned signal object has pause() and resume() functions. Calling the\r\n\t\t\/\/\t\tpause() method will cause the listener to not be called for future events. Calling the\r\n\t\t\/\/\t\tresume() method will cause the listener to again be called for future events.\r\n\t\tvar paused;\r\n\t\tvar signal = on(target, type, function(){\r\n\t\t\tif(!paused){\r\n\t\t\t\treturn listener.apply(this, arguments);\r\n\t\t\t}\r\n\t\t}, dontFix);\r\n\t\tsignal.pause = function(){\r\n\t\t\tpaused = true;\r\n\t\t};\r\n\t\tsignal.resume = function(){\r\n\t\t\tpaused = false;\r\n\t\t};\r\n\t\treturn signal;\r\n\t};\r\n\ton.once = function(target, type, listener, dontFix){\r\n\t\t\/\/ summary:\r\n\t\t\/\/\t\tThis function acts the same as on(), but will only call the listener once. The \r\n\t\t\/\/ \t\tlistener will be called for the first\r\n\t\t\/\/\t\tevent that takes place and then listener will automatically be removed.\r\n\t\tvar signal = on(target, type, function(){\r\n\t\t\t\/\/ remove this listener\r\n\t\t\tsignal.remove();\r\n\t\t\t\/\/ proceed to call the listener\r\n\t\t\treturn listener.apply(this, arguments);\r\n\t\t});\r\n\t\treturn signal;\r\n\t};\r\n\tvar prototype = (on.Evented = function(){}).prototype;\r\n\tprototype.on = function(type, listener, dontFix){\r\n\t\treturn addListener(this, type, listener, dontFix, this);\r\n\t};\r\n\tvar touchEvents = \/^touch\/;\r\n\tfunction addListener(target, type, listener, dontFix, matchesTarget){\r\n\t\tif(type.call){\r\n\t\t\t\/\/ event handler function\r\n\t\t\t\/\/ on(node, dojo.touch.press, touchListener);\r\n\t\t\treturn type.call(matchesTarget, target, listener);\r\n\t\t}\r\n\r\n\t\tif(type.indexOf(\",\") > -1){\r\n\t\t\t\/\/ we allow comma delimited event names, so you can register for multiple events at once\r\n\t\t\tvar events = type.split(\/\\s*,\\s*\/);\r\n\t\t\tvar handles = [];\r\n\t\t\tvar i = 0;\r\n\t\t\tvar eventName;\r\n\t\t\twhile(eventName = events[i++]){\r\n\t\t\t\thandles.push(addListener(target, eventName, listener, dontFix, matchesTarget));\r\n\t\t\t}\r\n\t\t\thandles.remove = function(){\r\n\t\t\t\tfor(var i = 0; i < handles.length; i++){\r\n\t\t\t\t\thandles[i].remove();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treturn handles;\r\n\t\t}\r\n\t\t\r\n\t\t\/\/ event delegation:\r\n\t\tvar selector = type.match(\/(.*):(.*)\/);\r\n\t\t\/\/ if we have a selector:event, the last one is interpreted as an event, and we use event delegation\r\n\t\tif(selector){\r\n\t\t\ttype = selector[2];\r\n\t\t\tselector = selector[1];\r\n\t\t\t\/\/ create the extension event for selectors and directly call it\r\n\t\t\treturn on.selector(selector, type).call(matchesTarget, target, listener);\r\n\t\t}\r\n\t\t\/\/ test to see if it a touch event right now, so we don't have to do it every time it fires\r\n\t\tif(has(\"touch\")){\r\n\t\t\tif(touchEvents.test(type)){\r\n\t\t\t\t\/\/ touch event, fix it\r\n\t\t\t\tlistener = fixTouchListener(listener);\r\n\t\t\t}\r\n\t\t\tif(!has(\"event-orientationchange\") && (type == \"orientationchange\")){\r\n\t\t\t\t\/\/\"orientationchange\" not supported <= Android 2.1, \r\n\t\t\t\t\/\/but works through \"resize\" on window\r\n\t\t\t\ttype = \"resize\"; \r\n\t\t\t\ttarget = window;\r\n\t\t\t\tlistener = fixTouchListener(listener);\r\n\t\t\t} \r\n\t\t}\r\n\t\t\/\/ normal path, the target is |this|\r\n\t\tif(target.addEventListener){\r\n\t\t\t\/\/ the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)\r\n\t\t\t\/\/ check for capture conversions\r\n\t\t\tvar capture = type in captures;\r\n\t\t\ttarget.addEventListener(capture ? captures[type] : type, listener, capture);\r\n\t\t\t\/\/ create and return the signal\r\n\t\t\treturn {\r\n\t\t\t\tremove: function(){\r\n\t\t\t\t\ttarget.removeEventListener(type, listener, capture);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t\ttype = \"on\" + type;\r\n\t\tif(fixAttach && target.attachEvent){\r\n\t\t\treturn fixAttach(target, type, listener);\r\n\t\t}\r\n\t \/\/ use aop\r\n\t\treturn after(target, type, listener, true);\r\n\t}\r\n\r\n\ton.selector = function(selector, eventType){\r\n\t\t\/\/ summary:\r\n\t\t\/\/\t\tCreates a new extension event with event delegation. This is based on\r\n\t\t\/\/ \t\tthe provided event type (can be extension event) that\r\n\t\t\/\/ \t\tonly calls the listener when the CSS selector matches the target of the event.\r\n\t\t\/\/\tselector:\r\n\t\t\/\/\t\tThe CSS selector to use for filter events and determine the |this| of the event listener.\r\n\t\t\/\/\teventType:\r\n\t\t\/\/\t\tThe event to listen for\r\n\t\t\/\/\texample:\r\n\t\t\/\/\t\tdefine([\"dojo\/on\", \"dojo\/mouse\"], function(listen, mouse){\r\n\t\t\/\/\t\t\ton(node, on.selector(\".my-class\", mouse.enter), handlerForMyHover);\r\n\t\treturn function(target, listener){\r\n\t\t\tvar matchesTarget = this;\r\n\t\t\treturn on(target, eventType, function(event){\r\n\t\t\t\tvar eventTarget = event.target;\r\n\t\t\t\t\/\/ see if we have a valid matchesTarget or default to dojo.query\r\n\t\t\t\tmatchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;\r\n\t\t\t\t\/\/ there is a selector, so make sure it matches\r\n\t\t\t\twhile(!matchesTarget.matches(eventTarget, selector, target)){\r\n\t\t\t\t\tif(eventTarget == target || !(eventTarget = eventTarget.parentNode)){ \/\/ intentional assignment\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn listener.call(eventTarget, event);\r\n\t\t\t});\r\n\t\t};\r\n\t};\r\n\r\n\tfunction syntheticPreventDefault(){\r\n\t\tthis.cancelable = false;\r\n\t}\r\n\tfunction syntheticStopPropagation(){\r\n\t\tthis.bubbles = false;\r\n\t}\r\n\tvar slice = [].slice,\r\n\t\tsyntheticDispatch = prototype.emit = on.emit = function(target, type, event){\r\n\t\t\/\/ summary:\r\n\t\t\/\/\t\tFires an event on the target object.\r\n\t\t\/\/\ttarget:\r\n\t\t\/\/\t\tThe target object to fire the event on. This can be a DOM element or a plain \r\n\t\t\/\/ \t\tJS object. If the target is a DOM element, native event emiting mechanisms\r\n\t\t\/\/\t\tare used when possible.\r\n\t\t\/\/\ttype:\r\n\t\t\/\/\t\tThe event type name. You can emulate standard native events like \"click\" and \r\n\t\t\/\/ \t\t\"mouseover\" or create custom events like \"open\" or \"finish\".\r\n\t\t\/\/\tevent:\r\n\t\t\/\/\t\tAn object that provides the properties for the event. See https:\/\/developer.mozilla.org\/en\/DOM\/event.initEvent \r\n\t\t\/\/ \t\tfor some of the properties. These properties are copied to the event object.\r\n\t\t\/\/\t\tOf particular importance are the cancelable and bubbles properties. The\r\n\t\t\/\/\t\tcancelable property indicates whether or not the event has a default action\r\n\t\t\/\/ \t\tthat can be cancelled. The event is cancelled by calling preventDefault() on\r\n\t\t\/\/ \t\tthe event object. The bubbles property indicates whether or not the\r\n\t\t\/\/\t\tevent will bubble up the DOM tree. If bubbles is true, the event will be called\r\n\t\t\/\/\t\ton the target and then each parent successively until the top of the tree\r\n\t\t\/\/\t\tis reached or stopPropagation() is called. Both bubbles and cancelable \r\n\t\t\/\/ \t\tdefault to false.\r\n\t\t\/\/\treturns:\r\n\t\t\/\/\t\tIf the event is cancelable and the event is not cancelled,\r\n\t\t\/\/ \t\temit will return true. If the event is cancelable and the event is cancelled,\r\n\t\t\/\/ \t\temit will return false.\r\n\t\t\/\/\tdetails:\r\n\t\t\/\/\t\tNote that this is designed to emit events for listeners registered through\r\n\t\t\/\/\t\tdojo\/on. It should actually work with any event listener except those\r\n\t\t\/\/ \t\tadded through IE's attachEvent (IE8 and below's non-W3C event emiting\r\n\t\t\/\/ \t\tdoesn't support custom event types). It should work with all events registered\r\n\t\t\/\/ \t\tthrough dojo\/on. Also note that the emit method does do any default\r\n\t\t\/\/ \t\taction, it only returns a value to indicate if the default action should take\r\n\t\t\/\/ \t\tplace. For example, emiting a keypress event would not cause a character\r\n\t\t\/\/ \t\tto appear in a textbox.\r\n\t\t\/\/\texample:\r\n\t\t\/\/\t\tTo fire our own click event\r\n\t\t\/\/\t|\ton.emit(dojo.byId(\"button\"), \"click\", {\r\n\t\t\/\/\t|\t\tcancelable: true,\r\n\t\t\/\/\t|\t\tbubbles: true,\r\n\t\t\/\/\t|\t\tscreenX: 33,\r\n\t\t\/\/\t|\t\tscreenY: 44\r\n\t\t\/\/\t|\t});\r\n\t\t\/\/\t\tWe can also fire our own custom events:\r\n\t\t\/\/\t|\ton.emit(dojo.byId(\"slider\"), \"slide\", {\r\n\t\t\/\/\t|\t\tcancelable: true,\r\n\t\t\/\/\t|\t\tbubbles: true,\r\n\t\t\/\/\t|\t\tdirection: \"left-to-right\"\r\n\t\t\/\/\t|\t});\r\n\t\tvar args = slice.call(arguments, 2);\r\n\t\tif(typeof target == \"string\"){\r\n\t\t\t\/\/ two argument case\r\n\t\t\targs.unshift(event = type);\r\n\t\t\ttype = target;\r\n\t\t\ttarget = this;\r\n\t\t}\r\n\t\tvar method = \"on\" + type;\r\n\t\tif(\"parentNode\" in target){\r\n\t\t\t\/\/ node (or node-like), create event controller methods\r\n\t\t\tvar newEvent = args[0] = {};\r\n\t\t\tfor(var i in event){\r\n\t\t\t\tnewEvent[i] = event[i];\r\n\t\t\t}\r\n\t\t\tnewEvent.preventDefault = syntheticPreventDefault;\r\n\t\t\tnewEvent.stopPropagation = syntheticStopPropagation;\r\n\t\t\tnewEvent.target = target;\r\n\t\t\tnewEvent.type = type;\r\n\t\t\tevent = newEvent;\r\n\t\t}\r\n\t\tdo{\r\n\t\t\t\/\/ call any node which has a handler (note that ideally we would try\/catch to simulate normal event propagation but that causes too much pain for debugging)\r\n\t\t\ttarget[method] && target[method].apply(target, args);\r\n\t\t\t\/\/ and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)\r\n\t\t}while(event && event.bubbles && (target = target.parentNode));\r\n\t\treturn event && event.cancelable && event; \/\/ if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen\r\n\t};\r\n\r\n\tif(has(\"dom-addeventlistener\")){\r\n\t\t\/\/ normalize focusin and focusout\r\n\t\tvar captures = {\r\n\t\t\tfocusin: \"focus\",\r\n\t\t\tfocusout: \"blur\"\r\n\t\t};\r\n\t\tif(has(\"opera\")){\r\n\t\t\tcaptures.keydown = \"keypress\"; \/\/ this one needs to be transformed because Opera doesn't support repeating keys on keydown (and keypress works because it incorrectly fires on all keydown events)\r\n\t\t}\r\n\r\n\t\t\/\/ emiter that works with native event handling\r\n\t\ton.emit = function(target, type, event){\r\n\t\t\tif(target.dispatchEvent && document.createEvent){\r\n\t\t\t\t\/\/ use the native event emiting mechanism if it is available on the target object\r\n\t\t\t\t\/\/ create a generic event\t\t\t\t\r\n\t\t\t\t\/\/ we could create branch into the different types of event constructors, but \r\n\t\t\t\t\/\/ that would be a lot of extra code, with little benefit that I can see, seems \r\n\t\t\t\t\/\/ best to use the generic constructor and copy properties over, making it \r\n\t\t\t\t\/\/ easy to have events look like the ones created with specific initializers\r\n\t\t\t\tvar nativeEvent = document.createEvent(\"HTMLEvents\");\r\n\t\t\t\tnativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);\r\n\t\t\t\t\/\/ and copy all our properties over\r\n\t\t\t\tfor(var i in event){\r\n\t\t\t\t\tvar value = event[i];\r\n\t\t\t\t\tif(!(i in nativeEvent)){\r\n\t\t\t\t\t\tnativeEvent[i] = event[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target.dispatchEvent(nativeEvent) && nativeEvent;\r\n\t\t\t}\r\n\t\t\treturn syntheticDispatch.call(on, target, type, event); \/\/ emit for a non-node\r\n\t\t};\r\n\t}else{\r\n\t\t\/\/ no addEventListener, basically old IE event normalization\r\n\t\ton._fixEvent = function(evt, sender){\r\n\t\t\t\/\/ summary:\r\n\t\t\t\/\/\t\tnormalizes properties on the event object including event\r\n\t\t\t\/\/\t\tbubbling methods, keystroke normalization, and x\/y positions\r\n\t\t\t\/\/ evt:\r\n\t\t\t\/\/\t\tnative event object\r\n\t\t\t\/\/ sender:\r\n\t\t\t\/\/\t\tnode to treat as \"currentTarget\"\r\n\t\t\tif(!evt){\r\n\t\t\t\tvar w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;\r\n\t\t\t\tevt = w.event;\r\n\t\t\t}\r\n\t\t\tif(!evt){return(evt);}\r\n\t\t\tif(!evt.target){ \/\/ check to see if it has been fixed yet\r\n\t\t\t\tevt.target = evt.srcElement;\r\n\t\t\t\tevt.currentTarget = (sender || evt.srcElement);\r\n\t\t\t\tif(evt.type == \"mouseover\"){\r\n\t\t\t\t\tevt.relatedTarget = evt.fromElement;\r\n\t\t\t\t}\r\n\t\t\t\tif(evt.type == \"mouseout\"){\r\n\t\t\t\t\tevt.relatedTarget = evt.toElement;\r\n\t\t\t\t}\r\n\t\t\t\tif(!evt.stopPropagation){\r\n\t\t\t\t\tevt.stopPropagation = stopPropagation;\r\n\t\t\t\t\tevt.preventDefault = preventDefault;\r\n\t\t\t\t}\r\n\t\t\t\tswitch(evt.type){\r\n\t\t\t\t\tcase \"keypress\":\r\n\t\t\t\t\t\tvar c = (\"charCode\" in evt ? evt.charCode : evt.keyCode);\r\n\t\t\t\t\t\tif (c==10){\r\n\t\t\t\t\t\t\t\/\/ CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla\r\n\t\t\t\t\t\t\tc=0;\r\n\t\t\t\t\t\t\tevt.keyCode = 13;\r\n\t\t\t\t\t\t}else if(c==13||c==27){\r\n\t\t\t\t\t\t\tc=0; \/\/ Mozilla considers ENTER and ESC non-printable\r\n\t\t\t\t\t\t}else if(c==3){\r\n\t\t\t\t\t\t\tc=99; \/\/ Mozilla maps CTRL-BREAK to CTRL-c\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\/\/ Mozilla sets keyCode to 0 when there is a charCode\r\n\t\t\t\t\t\t\/\/ but that stops the event on IE.\r\n\t\t\t\t\t\tevt.charCode = c;\r\n\t\t\t\t\t\t_setKeyChar(evt);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn evt;\r\n\t\t};\r\n\t\tvar IESignal = function(handle){\r\n\t\t\tthis.handle = handle;\r\n\t\t};\r\n\t\tIESignal.prototype.remove = function(){\r\n\t\t\tdelete _dojoIEListeners_[this.handle];\r\n\t\t};\r\n\t\tvar fixListener = function(listener){\r\n\t\t\t\/\/ this is a minimal function for closing on the previous listener with as few as variables as possible\r\n\t\t\treturn function(evt){\r\n\t\t\t\tevt = on._fixEvent(evt, this);\r\n\t\t\t\treturn listener.call(this, evt);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar fixAttach = function(target, type, listener){\r\n\t\t\tlistener = fixListener(listener);\r\n\t\t\tif(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || \r\n\t\t\t\t\t\thas(\"jscript\") < 5.8) && \r\n\t\t\t\t\t!has(\"config-_allow_leaks\")){\r\n\t\t\t\t\/\/ IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.\r\n\t\t\t\t\/\/ Here we use global redirection to solve the memory leaks\r\n\t\t\t\tif(typeof _dojoIEListeners_ == \"undefined\"){\r\n\t\t\t\t\t_dojoIEListeners_ = [];\r\n\t\t\t\t}\r\n\t\t\t\tvar emiter = target[type];\r\n\t\t\t\tif(!emiter || !emiter.listeners){\r\n\t\t\t\t\tvar oldListener = emiter;\r\n\t\t\t\t\ttarget[type] = emiter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');\r\n\t\t\t\t\temiter.listeners = [];\r\n\t\t\t\t\tif(oldListener){\r\n\t\t\t\t\t\temiter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar handle;\r\n\t\t\t\temiter.listeners.push(handle = (_dojoIEListeners_.push(listener) - 1));\r\n\t\t\t\treturn new IESignal(handle);\r\n\t\t\t}\r\n\t\t\treturn after(target, type, listener, true);\r\n\t\t};\r\n\r\n\t\tvar _setKeyChar = function(evt){\r\n\t\t\tevt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';\r\n\t\t\tevt.charOrCode = evt.keyChar || evt.keyCode;\r\n\t\t};\r\n\t\t\/\/ Called in Event scope\r\n\t\tvar stopPropagation = function(){\r\n\t\t\tthis.cancelBubble = true;\r\n\t\t};\r\n\t\tvar preventDefault = on._preventDefault = function(){\r\n\t\t\t\/\/ Setting keyCode to 0 is the only way to prevent certain keypresses (namely\r\n\t\t\t\/\/ ctrl-combinations that correspond to menu accelerator keys).\r\n\t\t\t\/\/ Otoh, it prevents upstream listeners from getting this information\r\n\t\t\t\/\/ Try to split the difference here by clobbering keyCode only for ctrl\r\n\t\t\t\/\/ combinations. If you still need to access the key upstream, bubbledKeyCode is\r\n\t\t\t\/\/ provided as a workaround.\r\n\t\t\tthis.bubbledKeyCode = this.keyCode;\r\n\t\t\tif(this.ctrlKey){\r\n\t\t\t\ttry{\r\n\t\t\t\t\t\/\/ squelch errors when keyCode is read-only\r\n\t\t\t\t\t\/\/ (e.g. if keyCode is ctrl or shift)\r\n\t\t\t\t\tthis.keyCode = 0;\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.returnValue = false;\r\n\t\t};\r\n\t}\r\n\tif(has(\"touch\")){ \r\n\t\tvar Event = function (){};\r\n\t\tvar windowOrientation = window.orientation; \r\n\t\tvar fixTouchListener = function(listener){ \r\n\t\t\treturn function(originalEvent){ \r\n\t\t\t\t\/\/Event normalization(for ontouchxxx and resize): \r\n\t\t\t\t\/\/1.incorrect e.pageX|pageY in iOS \r\n\t\t\t\t\/\/2.there are no \"e.rotation\", \"e.scale\" and \"onorientationchange\" in Andriod\r\n\t\t\t\t\/\/3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY\r\n\r\n\t\t\t\t\/\/ see if it has already been corrected\r\n\t\t\t\tvar event = originalEvent.corrected;\r\n\t\t\t\tif(!event){\r\n\t\t\t\t\tvar type = originalEvent.type;\r\n\t\t\t\t\tdelete originalEvent.type; \/\/ on some JS engines (android), deleting properties make them mutable \r\n\t\t\t\t\tif(originalEvent.type){\r\n\t\t\t\t\t\t\/\/ deleting properites doesn't work (older iOS), have to use delegation\r\n\t\t\t\t\t\tEvent.prototype = originalEvent;\r\n\t\t\t\t\t\tvar event = new Event;\r\n\t\t\t\t\t\t\/\/ have to delegate methods to make them work\r\n\t\t\t\t\t\tevent.preventDefault = function(){\r\n\t\t\t\t\t\t\toriginalEvent.preventDefault();\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tevent.stopPropagation = function(){\r\n\t\t\t\t\t\t\toriginalEvent.stopPropagation();\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\/\/ deletion worked, use property as is\r\n\t\t\t\t\t\tevent = originalEvent;\r\n\t\t\t\t\t\tevent.type = type;\r\n\t\t\t\t\t}\r\n\t\t\t\t\toriginalEvent.corrected = event;\r\n\t\t\t\t\tif(type == 'resize'){\r\n\t\t\t\t\t\tif(windowOrientation == window.orientation){ \r\n\t\t\t\t\t\t\treturn null;\/\/double tap causes an unexpected 'resize' in Andriod \r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t\twindowOrientation = window.orientation;\r\n\t\t\t\t\t\tevent.type = \"orientationchange\"; \r\n\t\t\t\t\t\treturn listener.call(this, event);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\/\/ We use the original event and augment, rather than doing an expensive mixin operation\r\n\t\t\t\t\tif(!(\"rotation\" in event)){ \/\/ test to see if it has rotation\r\n\t\t\t\t\t\tevent.rotation = 0; \r\n\t\t\t\t\t\tevent.scale = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\/\/use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target\r\n\t\t\t\t\tvar firstChangeTouch = event.changedTouches[0];\r\n\t\t\t\t\tfor(var i in firstChangeTouch){ \/\/ use for-in, we don't need to have dependency on dojo\/_base\/lang here\r\n\t\t\t\t\t\tdelete event[i]; \/\/ delete it first to make it mutable\r\n\t\t\t\t\t\tevent[i] = firstChangeTouch[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn listener.call(this, event); \r\n\t\t\t}; \r\n\t\t}; \r\n\t}\r\n\treturn on;\r\n});\r\n","dependencies":["dojo\/aspect","dojo\/_base\/kernel","dojo\/has"]},"dojo\/aspect":{"id":"dojo\/aspect","url":"\/home\/arian\/www\/MooTools\/dojo\/aspect.js","package":"dojo","amd":true,"content":"define([], function(){\r\n\r\n\/\/ TODOC: after\/before\/around return object\r\n\/\/ TODOC: after\/before\/around param types. \r\n\r\n\/*=====\r\n\tdojo.aspect = {\r\n\t\t\/\/ summary: provides aspect oriented programming functionality, allowing for\r\n\t\t\/\/\t\tone to add before, around, or after advice on existing methods.\r\n\t\t\/\/\r\n\t\t\/\/ example:\r\n\t\t\/\/\t|\tdefine([\"dojo\/aspect\"], function(aspect){\r\n\t\t\/\/\t|\t\tvar signal = aspect.after(targetObject, \"methodName\", function(someArgument){\r\n\t\t\/\/\t|\t\t\tthis will be called when targetObject.methodName() is called, after the original function is called\r\n\t\t\/\/\t|\t\t});\r\n\t\t\/\/\r\n\t\t\/\/ example:\r\n\t\t\/\/\tThe returned signal object can be used to cancel the advice.\r\n\t\t\/\/\t|\tsignal.remove(); \/\/ this will stop the advice from being executed anymore\r\n\t\t\/\/\t|\taspect.before(targetObject, \"methodName\", function(someArgument){\r\n\t\t\/\/\t|\t\t\/\/ this will be called when targetObject.methodName() is called, before the original function is called\r\n\t\t\/\/\t|\t });\r\n\t\t\r\n\t\tafter: function(target, methodName, advice, receiveArguments){\r\n\t\t\t\/\/ summary: The \"after\" export of the aspect module is a function that can be used to attach\r\n\t\t\t\/\/\t\t\"after\" advice to a method. This function will be executed after the original method\r\n\t\t\t\/\/\t\tis executed. By default the function will be called with a single argument, the return\r\n\t\t\t\/\/\t\tvalue of the original method, or the the return value of the last executed advice (if a previous one exists).\r\n\t\t\t\/\/\t\tThe fourth (optional) argument can be set to true to so the function receives the original\r\n\t\t\t\/\/\t\targuments (from when the original method was called) rather than the return value.\r\n\t\t\t\/\/\t\tIf there are multiple \"after\" advisors, they are executed in the order they were registered.\r\n\t\t\t\/\/ target: Object\r\n\t\t\t\/\/\t\tThis is the target object\r\n\t\t\t\/\/ methodName: String\r\n\t\t\t\/\/\t\tThis is the name of the method to attach to.\r\n\t\t\t\/\/ advice: Function\r\n\t\t\t\/\/\t\tThis is function to be called after the original method\r\n\t\t\t\/\/ receiveArguments: Boolean?\r\n\t\t\t\/\/\t\tIf this is set to true, the advice function receives the original arguments (from when the original mehtod\r\n\t\t\t\/\/\t\twas called) rather than the return value of the original\/previous method.\r\n\t\t\t\/\/ returns:\r\n\t\t\t\/\/\t\tA signal object that can be used to cancel the advice. If remove() is called on this signal object, it will\r\n\t\t\t\/\/\t\tstop the advice function from being executed.\r\n\t\t},\r\n\t\t\r\n\t\tbefore: function(target, methodName, advice){\r\n\t\t\t\/\/ summary: The \"before\" export of the aspect module is a function that can be used to attach\r\n\t\t\t\/\/\t\t\"before\" advice to a method. This function will be executed before the original method\r\n\t\t\t\/\/\t\tis executed. This function will be called with the arguments used to call the method.\r\n\t\t\t\/\/\t\tThis function may optionally return an array as the new arguments to use to call\r\n\t\t\t\/\/\t\tthe original method (or the previous, next-to-execute before advice, if one exists).\r\n\t\t\t\/\/\t\tIf the before method doesn't return anything (returns undefined) the original arguments\r\n\t\t\t\/\/\t\twill be preserved.\r\n\t\t\t\/\/\t\tIf there are multiple \"before\" advisors, they are executed in the reverse order they were registered.\r\n\t\t\t\/\/\r\n\t\t\t\/\/ target: Object\r\n\t\t\t\/\/\t\tThis is the target object\r\n\t\t\t\/\/ methodName: String\r\n\t\t\t\/\/\t\tThis is the name of the method to attach to.\r\n\t\t\t\/\/ advice: Function\r\n\t\t\t\/\/\t\tThis is function to be called before the original method\t \r\n\t\t},\r\n\r\n\t\taround: function(target, methodName, advice){\r\n\t\t\t\/\/ summary: The \"around\" export of the aspect module is a function that can be used to attach\r\n\t\t\t\/\/\t\t\"around\" advice to a method. The advisor function is immediately executed when\r\n\t\t\t\/\/\t\tthe around() is called, is passed a single argument that is a function that can be\r\n\t\t\t\/\/\t\tcalled to continue execution of the original method (or the next around advisor).\r\n\t\t\t\/\/\t\tThe advisor function should return a function, and this function will be called whenever\r\n\t\t\t\/\/\t\tthe method is called. It will be called with the arguments used to call the method.\r\n\t\t\t\/\/\t\tWhatever this function returns will be returned as the result of the method call (unless after advise changes it).\r\n\t\t\t\/\/\r\n\t\t\t\/\/ example:\r\n\t\t\t\/\/\t\tIf there are multiple \"around\" advisors, the most recent one is executed first,\r\n\t\t\t\/\/\t\twhich can then delegate to the next one and so on. For example:\r\n\t\t\t\/\/\t\t|\taround(obj, \"foo\", function(originalFoo){\r\n\t\t\t\/\/\t\t|\t\treturn function(){\r\n\t\t\t\/\/\t\t|\t\t\tvar start = new Date().getTime();\r\n\t\t\t\/\/\t\t|\t\t\tvar results = originalFoo.apply(this, arguments); \/\/ call the original\r\n\t\t\t\/\/\t\t|\t\t\tvar end = new Date().getTime();\r\n\t\t\t\/\/\t\t|\t\t\tconsole.log(\"foo execution took \" + (end - start) + \" ms\");\r\n\t\t\t\/\/\t\t|\t\t\treturn results;\r\n\t\t\t\/\/\t\t|\t\t};\r\n\t\t\t\/\/\t\t|\t});\r\n\t\t\t\/\/\r\n\t\t\t\/\/ target: Object\r\n\t\t\t\/\/\t\tThis is the target object\r\n\t\t\t\/\/ methodName: String\r\n\t\t\t\/\/\t\tThis is the name of the method to attach to.\r\n\t\t\t\/\/ advice: Function\r\n\t\t\t\/\/\t\tThis is function to be called around the original method\r\n\t\t}\r\n\r\n\t};\r\n=====*\/\r\n\r\n\t\"use strict\";\r\n\tfunction advise(dispatcher, type, advice, receiveArguments){\r\n\t\tvar previous = dispatcher[type];\r\n\t\tvar around = type == \"around\";\r\n\t\tvar signal;\r\n\t\tif(around){\r\n\t\t\tvar advised = advice(function(){\r\n\t\t\t\treturn previous.advice(this, arguments);\r\n\t\t\t});\r\n\t\t\tsignal = {\r\n\t\t\t\tremove: function(){\r\n\t\t\t\t\tsignal.cancelled = true;\r\n\t\t\t\t},\r\n\t\t\t\tadvice: function(target, args){\r\n\t\t\t\t\treturn signal.cancelled ?\r\n\t\t\t\t\t\tprevious.advice(target, args) : \/\/ cancelled, skip to next one\r\n\t\t\t\t\t\tadvised.apply(target, args);\t\/\/ called the advised function\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}else{\r\n\t\t\t\/\/ create the remove handler\r\n\t\t\tsignal = {\r\n\t\t\t\tremove: function(){\r\n\t\t\t\t\tvar previous = signal.previous;\r\n\t\t\t\t\tvar next = signal.next;\r\n\t\t\t\t\tif(!next && !previous){\r\n\t\t\t\t\t\tdelete dispatcher[type];\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(previous){\r\n\t\t\t\t\t\t\tprevious.next = next;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tdispatcher[type] = next;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(next){\r\n\t\t\t\t\t\t\tnext.previous = previous;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tadvice: advice,\r\n\t\t\t\treceiveArguments: receiveArguments\r\n\t\t\t};\r\n\t\t}\r\n\t\tif(previous && !around){\r\n\t\t\tif(type == \"after\"){\r\n\t\t\t\t\/\/ add the listener to the end of the list\r\n\t\t\t\tvar next = previous;\r\n\t\t\t\twhile(next){\r\n\t\t\t\t\tprevious = next;\r\n\t\t\t\t\tnext = next.next;\r\n\t\t\t\t}\r\n\t\t\t\tprevious.next = signal;\r\n\t\t\t\tsignal.previous = previous;\r\n\t\t\t}else if(type == \"before\"){\r\n\t\t\t\t\/\/ add to beginning\r\n\t\t\t\tdispatcher[type] = signal;\r\n\t\t\t\tsignal.next = previous;\r\n\t\t\t\tprevious.previous = signal;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t\/\/ around or first one just replaces\r\n\t\t\tdispatcher[type] = signal;\r\n\t\t}\r\n\t\treturn signal;\r\n\t}\r\n\tfunction aspect(type){\r\n\t\treturn function(target, methodName, advice, receiveArguments){\r\n\t\t\tvar existing = target[methodName], dispatcher;\r\n\t\t\tif(!existing || existing.target != target){\r\n\t\t\t\t\/\/ no dispatcher in place\r\n\t\t\t\tdispatcher = target[methodName] = function(){\r\n\t\t\t\t\t\/\/ before advice\r\n\t\t\t\t\tvar args = arguments;\r\n\t\t\t\t\tvar before = dispatcher.before;\r\n\t\t\t\t\twhile(before){\r\n\t\t\t\t\t\targs = before.advice.apply(this, args) || args;\r\n\t\t\t\t\t\tbefore = before.next;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\/\/ around advice\r\n\t\t\t\t\tif(dispatcher.around){\r\n\t\t\t\t\t\tvar results = dispatcher.around.advice(this, args);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\/\/ after advice\r\n\t\t\t\t\tvar after = dispatcher.after;\r\n\t\t\t\t\twhile(after){\r\n\t\t\t\t\t\tresults = after.receiveArguments ? after.advice.apply(this, args) || results :\r\n\t\t\t\t\t\t\t\tafter.advice.call(this, results);\r\n\t\t\t\t\t\tafter = after.next;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t};\r\n\t\t\t\tif(existing){\r\n\t\t\t\t\tdispatcher.around = {advice: function(target, args){\r\n\t\t\t\t\t\treturn existing.apply(target, args);\r\n\t\t\t\t\t}};\r\n\t\t\t\t}\r\n\t\t\t\tdispatcher.target = target;\r\n\t\t\t}\r\n\t\t\tvar results = advise((dispatcher || existing), type, advice, receiveArguments);\r\n\t\t\tadvice = null;\r\n\t\t\treturn results;\r\n\t\t};\r\n\t}\r\n\treturn {\r\n\t\tbefore: aspect(\"before\"),\r\n\t\taround: aspect(\"around\"),\r\n\t\tafter: aspect(\"after\")\r\n\t};\r\n});\r\n","dependencies":[]},"dojo\/_base\/event":{"id":"dojo\/_base\/event","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/event.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \"..\/on\", \"..\/has\", \"..\/dom-geometry\"], function(dojo, on, has, dom){\n  \/\/  module:\n  \/\/    dojo\/_base\/event\n  \/\/  summary:\n  \/\/    This module defines dojo DOM event API.\n\tif(on._fixEvent){\n\t\tvar fixEvent = on._fixEvent;\n\t\ton._fixEvent = function(evt, se){\n\t\t\t\/\/ add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive\n\t\t\tevt = fixEvent(evt, se);\n\t\t\tif(evt){\n\t\t\t\tdom.normalizeEvent(evt);\n\t\t\t}\n\t\t\treturn evt;\n\t\t};\t\t\n\t}\n\tdojo.fixEvent = function(\/*Event*\/ evt, \/*DOMNode*\/ sender){\n\t\t\/\/ summary:\n\t\t\/\/\t\tnormalizes properties on the event object including event\n\t\t\/\/\t\tbubbling methods, keystroke normalization, and x\/y positions\n\t\t\/\/ evt: Event\n\t\t\/\/\t\tnative event object\n\t\t\/\/ sender: DOMNode\n\t\t\/\/\t\tnode to treat as \"currentTarget\"\n\t\tif(on._fixEvent){\n\t\t\treturn on._fixEvent(evt, sender);\n\t\t}\n\t\treturn evt;\t\/\/ Event\n\t};\n\t\n\tdojo.stopEvent = function(\/*Event*\/ evt){\n\t\t\/\/ summary:\n\t\t\/\/\t\tprevents propagation and clobbers the default action of the\n\t\t\/\/\t\tpassed event\n\t\t\/\/ evt: Event\n\t\t\/\/\t\tThe event object. If omitted, window.event is used on IE.\n\t\tif(has(\"dom-addeventlistener\") || (evt && evt.preventDefault)){\n\t\t\tevt.preventDefault();\n\t\t\tevt.stopPropagation();\n\t\t}else{\n\t\t\tevt = evt || window.event;\n\t\t\tevt.cancelBubble = true;\n\t\t\ton._preventDefault.call(evt);\n\t\t}\n\t};\n\n\treturn {\n\t\tfix: dojo.fixEvent,\n\t\tstop: dojo.stopEvent\n\t};\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/on","dojo\/has","dojo\/dom-geometry"]},"dojo\/dom-geometry":{"id":"dojo\/dom-geometry","url":"\/home\/arian\/www\/MooTools\/dojo\/dom-geometry.js","package":"dojo","amd":true,"content":"define([\".\/_base\/kernel\", \".\/_base\/sniff\", \".\/_base\/window\",\".\/dom\", \".\/dom-style\"],\n\t\tfunction(dojo, has, win, dom, style){\n\t\/\/ module:\n\t\/\/\t\tdojo\/dom-geometry\n\t\/\/ summary:\n\t\/\/\t\tThis module defines the core dojo DOM geometry API.\n\n\tvar geom = {};  \/\/ the result object\n\n\t\/\/ Box functions will assume this model.\n\t\/\/ On IE\/Opera, BORDER_BOX will be set if the primary document is in quirks mode.\n\t\/\/ Can be set to change behavior of box setters.\n\n\t\/\/ can be either:\n\t\/\/\t\"border-box\"\n\t\/\/\t\"content-box\" (default)\n\tgeom.boxModel = \"content-box\";\n\n\t\/\/ We punt per-node box mode testing completely.\n\t\/\/ If anybody cares, we can provide an additional (optional) unit\n\t\/\/ that overrides existing code to include per-node box sensitivity.\n\n\t\/\/ Opera documentation claims that Opera 9 uses border-box in BackCompat mode.\n\t\/\/ but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.\n\t\/\/ IIRC, earlier versions of Opera did in fact use border-box.\n\t\/\/ Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.\n\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\tif(has(\"ie\") \/*|| has(\"opera\")*\/){\n\t\t\/\/ client code may have to adjust if compatMode varies across iframes\n\t\tgeom.boxModel = document.compatMode == \"BackCompat\" ? \"border-box\" : \"content-box\";\n\t}\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\n\t\/\/ =============================\n\t\/\/ Box Functions\n\t\/\/ =============================\n\n\t\/*=====\n\tdojo.getPadExtents = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns object with special values specifically useful for node\n\t\t\/\/\t\tfitting.\n\t\t\/\/ description:\n\t\t\/\/\t\tReturns an object with `w`, `h`, `l`, `t` properties:\n\t\t\/\/\t|\t\tl\/t\/r\/b = left\/top\/right\/bottom padding (respectively)\n\t\t\/\/\t|\t\tw = the total of the left and right padding\n\t\t\/\/\t|\t\th = the total of the top and bottom padding\n\t\t\/\/\t\tIf 'node' has position, l\/t forms the origin for child nodes.\n\t\t\/\/\t\tThe w\/h are used for calculating boxes.\n\t\t\/\/\t\tNormally application code will not need to invoke this\n\t\t\/\/\t\tdirectly, and will use the ...box... functions instead.\n\t\t\/\/ node: DOMNode\n\t\t\/\/ computedStyle: Object?\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._getPadExtents = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.getPadExtents`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.getBorderExtents = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\treturns an object with properties useful for noting the border\n\t\t\/\/\t\tdimensions.\n\t\t\/\/ description:\n\t\t\/\/\t\t* l\/t\/r\/b = the sum of left\/top\/right\/bottom border (respectively)\n\t\t\/\/\t\t* w = the sum of the left and right border\n\t\t\/\/\t\t* h = the sum of the top and bottom border\n\t\t\/\/\n\t\t\/\/\t\tThe w\/h are used for calculating boxes.\n\t\t\/\/\t\tNormally application code will not need to invoke this\n\t\t\/\/\t\tdirectly, and will use the ...box... functions instead.\n\t\t\/\/ node: DOMNode\n\t\t\/\/ computedStyle: Object?\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._getBorderExtents = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.getBorderExtents`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.getPadBorderExtents = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns object with properties useful for box fitting with\n\t\t\/\/\t\tregards to padding.\n\t\t\/\/ description:\n\t\t\/\/\t\t* l\/t\/r\/b = the sum of left\/top\/right\/bottom padding and left\/top\/right\/bottom border (respectively)\n\t\t\/\/\t\t* w = the sum of the left and right padding and border\n\t\t\/\/\t\t* h = the sum of the top and bottom padding and border\n\t\t\/\/\n\t\t\/\/\t\tThe w\/h are used for calculating boxes.\n\t\t\/\/\t\tNormally application code will not need to invoke this\n\t\t\/\/\t\tdirectly, and will use the ...box... functions instead.\n\t\t\/\/ node: DOMNode\n\t\t\/\/ computedStyle: Object?\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._getPadBorderExtents = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.getPadBorderExtents`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.getMarginExtents = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\treturns object with properties useful for box fitting with\n\t\t\/\/\t\tregards to box margins (i.e., the outer-box).\n\t\t\/\/\n\t\t\/\/\t\t* l\/t = marginLeft, marginTop, respectively\n\t\t\/\/\t\t* w = total width, margin inclusive\n\t\t\/\/\t\t* h = total height, margin inclusive\n\t\t\/\/\n\t\t\/\/\t\tThe w\/h are used for calculating boxes.\n\t\t\/\/\t\tNormally application code will not need to invoke this\n\t\t\/\/\t\tdirectly, and will use the ...box... functions instead.\n\t\t\/\/ node: DOMNode\n\t\t\/\/ computedStyle: Object?\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._getMarginExtents = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.getMarginExtents`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.getMarginSize = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\treturns an object that encodes the width and height of\n\t\t\/\/\t\tthe node's margin box\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/ computedStyle: Object?\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._getMarginSize = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.getMarginSize`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.getMarginBox = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\treturns an object that encodes the width, height, left and top\n\t\t\/\/\t\tpositions of the node's margin box.\n\t\t\/\/ node: DOMNode\n\t\t\/\/ computedStyle: Object?\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._getMarginBox = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.getMarginBox`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.setMarginBox = function(node, leftPx, topPx, widthPx, heightPx, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tsets the size of the node's margin box and placement\n\t\t\/\/\t\t(left\/top), irrespective of box model. Think of it as a\n\t\t\/\/\t\tpassthrough to setBox that handles box-model vagaries for\n\t\t\/\/\t\tyou.\n\t\t\/\/ node: DOMNode\n\t\t\/\/ leftPx: Number?\n\t\t\/\/ topPx: Number?\n\t\t\/\/ widthPx: Number?\n\t\t\/\/ heightPx: Number?\n\t\t\/\/ computedStyle: Object?\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._setMarginBox = function(node, leftPx, topPx, widthPx, heightPx, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.setMarginBox`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.getContentBox = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns an object that encodes the width, height, left and top\n\t\t\/\/\t\tpositions of the node's content box, irrespective of the\n\t\t\/\/\t\tcurrent box model.\n\t\t\/\/ node: DOMNode\n\t\t\/\/ computedStyle: Object?\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._getContentBox = function(node, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.getContentBox`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.setContentSize = function(node, widthPx, heightPx, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tSets the size of the node's contents, irrespective of margins,\n\t\t\/\/\t\tpadding, or borders.\n\t\t\/\/ node: DOMNode\n\t\t\/\/ widthPx: Number?\n\t\t\/\/ heightPx: Number?\n\t\t\/\/ computedStyle: Object?\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._setContentSize = function(node, widthPx, heightPx, computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.setContentSize`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.isBodyLtr = function(){\n\t\t\/\/ summary:\n\t\t\/\/      Returns true if the current language is left-to-right, and false otherwise.\n\t\t\/\/ returns: Boolean\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._isBodyLtr = function(){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.isBodyLtr`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.docScroll = function(){\n\t\t\/\/ summary:\n\t\t\/\/      Returns an object with {node, x, y} with corresponding offsets.\n\t\t\/\/ returns: Object\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._docScroll = function(){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.docScroll`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.getIeDocumentElementOffset = function(){\n\t\t\/\/ summary:\n\t\t\/\/\t\treturns the offset in x and y from the document body to the\n\t\t\/\/\t\tvisual edge of the page for IE\n\t\t\/\/ description:\n\t\t\/\/\t\tThe following values in IE contain an offset:\n\t\t\/\/\t|\t\tevent.clientX\n\t\t\/\/\t|\t\tevent.clientY\n\t\t\/\/\t|\t\tnode.getBoundingClientRect().left\n\t\t\/\/\t|\t\tnode.getBoundingClientRect().top\n\t\t\/\/\t\tBut other position related values do not contain this offset,\n\t\t\/\/\t\tsuch as node.offsetLeft, node.offsetTop, node.style.left and\n\t\t\/\/\t\tnode.style.top. The offset is always (2, 2) in LTR direction.\n\t\t\/\/\t\tWhen the body is in RTL direction, the offset counts the width\n\t\t\/\/\t\tof left scroll bar's width.  This function computes the actual\n\t\t\/\/\t\toffset.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._getIeDocumentElementOffset = function(){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.getIeDocumentElementOffset`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.fixIeBiDiScrollLeft = function(scrollLeft){\n\t\t\/\/ summary:\n\t\t\/\/      In RTL direction, scrollLeft should be a negative value, but IE\n\t\t\/\/      returns a positive one. All codes using documentElement.scrollLeft\n\t\t\/\/      must call this function to fix this error, otherwise the position\n\t\t\/\/      will offset to right when there is a horizontal scrollbar.\n\t\t\/\/ scrollLeft: NUmber\n\t\t\/\/ returns: Number\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._fixIeBiDiScrollLeft = function(scrollLeft){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.fixIeBiDiScrollLeft`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.position = function(node, includeScroll){\n\t\t\/\/ summary:\n\t\t\/\/\t\tGets the position and size of the passed element relative to\n\t\t\/\/\t\tthe viewport (if includeScroll==false), or relative to the\n\t\t\/\/\t\tdocument root (if includeScroll==true).\n\t\t\/\/\n\t\t\/\/ description:\n\t\t\/\/\t\tReturns an object of the form:\n\t\t\/\/\t\t\t{ x: 100, y: 300, w: 20, h: 15 }\n\t\t\/\/\t\tIf includeScroll==true, the x and y values will include any\n\t\t\/\/\t\tdocument offsets that may affect the position relative to the\n\t\t\/\/\t\tviewport.\n\t\t\/\/\t\tUses the border-box model (inclusive of border and padding but\n\t\t\/\/\t\tnot margin).  Does not act as a setter.\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/ includeScroll: Boolean?\n\t\t\/\/ returns: Object\n\t};\n\t=====*\/\n\n\tgeom.getPadExtents = function getPadExtents(\/*DomNode*\/node, \/*Object*\/computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,\n\t\t\tl = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\n\t};\n\n\tvar none = \"none\";\n\n\tgeom.getBorderExtents = function getBorderExtents(\/*DomNode*\/node, \/*Object*\/computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),\n\t\t\tl = (s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0),\n\t\t\tt = (s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0),\n\t\t\tr = (s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0),\n\t\t\tb = (s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0);\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\n\t};\n\n\tgeom.getPadBorderExtents = function getPadBorderExtents(\/*DomNode*\/node, \/*Object*\/computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node),\n\t\t\tp = geom.getPadExtents(node, s),\n\t\t\tb = geom.getBorderExtents(node, s);\n\t\treturn {\n\t\t\tl: p.l + b.l,\n\t\t\tt: p.t + b.t,\n\t\t\tr: p.r + b.r,\n\t\t\tb: p.b + b.b,\n\t\t\tw: p.w + b.w,\n\t\t\th: p.h + b.h\n\t\t};\n\t};\n\n\tgeom.getMarginExtents = function getMarginExtents(node, computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,\n\t\t\tl = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);\n\t\tif(has(\"webkit\") && (s.position != \"absolute\")){\n\t\t\t\/\/ FIXME: Safari's version of the computed right margin\n\t\t\t\/\/ is the space between our right edge and the right edge\n\t\t\t\/\/ of our offsetParent.\n\t\t\t\/\/ What we are looking for is the actual margin value as\n\t\t\t\/\/ determined by CSS.\n\t\t\t\/\/ Hack solution is to assume left\/right margins are the same.\n\t\t\tr = l;\n\t\t}\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\n\t};\n\n\t\/\/ Box getters work in any box context because offsetWidth\/clientWidth\n\t\/\/ are invariant wrt box context\n\t\/\/\n\t\/\/ They do *not* work for display: inline objects that have padding styles\n\t\/\/ because the user agent ignores padding (it's bogus styling in any case)\n\t\/\/\n\t\/\/ Be careful with IMGs because they are inline or block depending on\n\t\/\/ browser and browser mode.\n\n\t\/\/ Although it would be easier to read, there are not separate versions of\n\t\/\/ _getMarginBox for each browser because:\n\t\/\/ 1. the branching is not expensive\n\t\/\/ 2. factoring the shared code wastes cycles (function call overhead)\n\t\/\/ 3. duplicating the shared code wastes bytes\n\n\tgeom.getMarginBox = function getMarginBox(\/*DomNode*\/node, \/*Object*\/computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\treturns an object that encodes the width, height, left and top\n\t\t\/\/\t\tpositions of the node's margin box.\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),\n\t\t\tl = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;\n\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\tif(has(\"moz\")){\n\t\t\t\/\/ Mozilla:\n\t\t\t\/\/ If offsetParent has a computed overflow != visible, the offsetLeft is decreased\n\t\t\t\/\/ by the parent's border.\n\t\t\t\/\/ We don't want to compute the parent's style, so instead we examine node's\n\t\t\t\/\/ computed left\/top which is more stable.\n\t\t\tvar sl = parseFloat(s.left), st = parseFloat(s.top);\n\t\t\tif(!isNaN(sl) && !isNaN(st)){\n\t\t\t\tl = sl, t = st;\n\t\t\t}else{\n\t\t\t\t\/\/ If child's computed left\/top are not parseable as a number (e.g. \"auto\"), we\n\t\t\t\t\/\/ have no choice but to examine the parent's computed style.\n\t\t\t\tif(p && p.style){\n\t\t\t\t\tpcs = style.getComputedStyle(p);\n\t\t\t\t\tif(pcs.overflow != \"visible\"){\n\t\t\t\t\t\tl += (pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0);\n\t\t\t\t\t\tt += (pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(has(\"opera\") || (has(\"ie\") == 8 && !dojo.isQuirks)){\n\t\t\t\/\/ On Opera and IE 8, offsetLeft\/Top includes the parent's border\n\t\t\tif(p){\n\t\t\t\tpcs = style.getComputedStyle(p);\n\t\t\t\tl -= (pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0);\n\t\t\t\tt -= (pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0);\n\t\t\t}\n\t\t}\n\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\treturn {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};\n\t};\n\n\tgeom.getContentBox = function getContentBox(node, computedStyle){\n\t\t\/\/ clientWidth\/Height are important since the automatically account for scrollbars\n\t\t\/\/ fallback to offsetWidth\/Height for special cases (see #3378)\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,\n\t\t\tpe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);\n\t\tif(!w){\n\t\t\tw = node.offsetWidth;\n\t\t\th = node.offsetHeight;\n\t\t}else{\n\t\t\th = node.clientHeight;\n\t\t\tbe.w = be.h = 0;\n\t\t}\n\t\t\/\/ On Opera, offsetLeft includes the parent's border\n\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\tif(has(\"opera\")){\n\t\t\tpe.l += be.l;\n\t\t\tpe.t += be.t;\n\t\t}\n\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\treturn {l: pe.l, t: pe.t, w: w - pe.w - be.w, h: h - pe.h - be.h};\n\t};\n\n\t\/\/ Box setters depend on box context because interpretation of width\/height styles\n\t\/\/ vary wrt box context.\n\t\/\/\n\t\/\/ The value of dojo.boxModel is used to determine box context.\n\t\/\/ dojo.boxModel can be set directly to change behavior.\n\t\/\/\n\t\/\/ Beware of display: inline objects that have padding styles\n\t\/\/ because the user agent ignores padding (it's a bogus setup anyway)\n\t\/\/\n\t\/\/ Be careful with IMGs because they are inline or block depending on\n\t\/\/ browser and browser mode.\n\t\/\/\n\t\/\/ Elements other than DIV may have special quirks, like built-in\n\t\/\/ margins or padding, or values not detectable via computedStyle.\n\t\/\/ In particular, margins on TABLE do not seems to appear\n\t\/\/ at all in computedStyle on Mozilla.\n\n\tfunction setBox(\/*DomNode*\/node, \/*Number?*\/l, \/*Number?*\/t, \/*Number?*\/w, \/*Number?*\/h, \/*String?*\/u){\n\t\t\/\/ summary:\n\t\t\/\/\t\tsets width\/height\/left\/top in the current (native) box-model\n\t\t\/\/\t\tdimensions. Uses the unit passed in u.\n\t\t\/\/ node:\n\t\t\/\/\t\tDOM Node reference. Id string not supported for performance\n\t\t\/\/\t\treasons.\n\t\t\/\/ l:\n\t\t\/\/\t\tleft offset from parent.\n\t\t\/\/ t:\n\t\t\/\/\t\ttop offset from parent.\n\t\t\/\/ w:\n\t\t\/\/\t\twidth in current box model.\n\t\t\/\/ h:\n\t\t\/\/\t\twidth in current box model.\n\t\t\/\/ u:\n\t\t\/\/\t\tunit measure to use for other measures. Defaults to \"px\".\n\t\tu = u || \"px\";\n\t\tvar s = node.style;\n\t\tif(!isNaN(l)){\n\t\t\ts.left = l + u;\n\t\t}\n\t\tif(!isNaN(t)){\n\t\t\ts.top = t + u;\n\t\t}\n\t\tif(w >= 0){\n\t\t\ts.width = w + u;\n\t\t}\n\t\tif(h >= 0){\n\t\t\ts.height = h + u;\n\t\t}\n\t}\n\n\tfunction isButtonTag(\/*DomNode*\/node){\n\t\t\/\/ summary:\n\t\t\/\/\t\tTrue if the node is BUTTON or INPUT.type=\"button\".\n\t\treturn node.tagName.toLowerCase() == \"button\" ||\n\t\t\tnode.tagName.toLowerCase() == \"input\" && (node.getAttribute(\"type\") || \"\").toLowerCase() == \"button\"; \/\/ boolean\n\t}\n\n\tfunction usesBorderBox(\/*DomNode*\/node){\n\t\t\/\/ summary:\n\t\t\/\/\t\tTrue if the node uses border-box layout.\n\n\t\t\/\/ We could test the computed style of node to see if a particular box\n\t\t\/\/ has been specified, but there are details and we choose not to bother.\n\n\t\t\/\/ TABLE and BUTTON (and INPUT type=button) are always border-box by default.\n\t\t\/\/ If you have assigned a different box to either one via CSS then\n\t\t\/\/ box functions will break.\n\n\t\treturn geom.boxModel == \"border-box\" || node.tagName.toLowerCase() == \"table\" || isButtonTag(node); \/\/ boolean\n\t}\n\n\tgeom.setContentSize = function setContentSize(\/*DomNode*\/node,\n\t\t\t\/*Number*\/widthPx, \/*Number*\/heightPx, \/*Object*\/computedStyle){\n\t\t\/\/ summary:\n\t\t\/\/\t\tSets the size of the node's contents, irrespective of margins,\n\t\t\/\/\t\tpadding, or borders.\n\n\t\tnode = dom.byId(node);\n\t\tif(usesBorderBox(node)){\n\t\t\tvar pb = geom.getPadBorderExtents(node, computedStyle);\n\t\t\tif(widthPx >= 0){\n\t\t\t\twidthPx += pb.w;\n\t\t\t}\n\t\t\tif(heightPx >= 0){\n\t\t\t\theightPx += pb.h;\n\t\t\t}\n\t\t}\n\t\tsetBox(node, NaN, NaN, widthPx, heightPx);\n\t};\n\n\tvar nilExtents = {l: 0, t: 0, w: 0, h: 0};\n\n\tgeom.setMarginBox = function setMarginBox(\/*DomNode*\/node,\n\t\t\t\/*Number?*\/leftPx, \/*Number?*\/topPx, \/*Number?*\/widthPx, \/*Number?*\/heightPx, \/*Object*\/computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node),\n\t\t\/\/ Some elements have special padding, margin, and box-model settings.\n\t\t\/\/ To use box functions you may need to set padding, margin explicitly.\n\t\t\/\/ Controlling box-model is harder, in a pinch you might set dojo.boxModel.\n\t\t\tpb = (usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s));\n\t\tif(has(\"webkit\")){\n\t\t\t\/\/ on Safari (3.1.2), button nodes with no explicit size have a default margin\n\t\t\t\/\/ setting an explicit size eliminates the margin.\n\t\t\t\/\/ We have to swizzle the width to get correct margin reading.\n\t\t\tif(isButtonTag(node)){\n\t\t\t\tvar ns = node.style;\n\t\t\t\tif(widthPx >= 0 && !ns.width){\n\t\t\t\t\tns.width = \"4px\";\n\t\t\t\t}\n\t\t\t\tif(heightPx >= 0 && !ns.height){\n\t\t\t\t\tns.height = \"4px\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar mb = geom.getMarginExtents(node, s);\n\t\tif(widthPx >= 0){\n\t\t\twidthPx = Math.max(widthPx - pb.w - mb.w, 0);\n\t\t}\n\t\tif(heightPx >= 0){\n\t\t\theightPx = Math.max(heightPx - pb.h - mb.h, 0);\n\t\t}\n\t\tsetBox(node, leftPx, topPx, widthPx, heightPx);\n\t};\n\n\t\/\/ =============================\n\t\/\/ Positioning\n\t\/\/ =============================\n\n\tgeom.isBodyLtr = function isBodyLtr(){\n\t\treturn (win.body().dir || win.doc.documentElement.dir || \"ltr\").toLowerCase() == \"ltr\"; \/\/ Boolean\n\t};\n\n\tgeom.docScroll = function docScroll(){\n\t\tvar node = win.doc.parentWindow || win.doc.defaultView;   \/\/ use UI window, not dojo.global window\n\t\treturn \"pageXOffset\" in node ? {x: node.pageXOffset, y: node.pageYOffset } :\n\t\t\t(node = dojo.isQuirks ? win.body() : win.doc.documentElement,\n\t\t\t\t{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0), y: node.scrollTop || 0 });\n\t};\n\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\tgeom.getIeDocumentElementOffset = function getIeDocumentElementOffset(){\n\t\t\/\/NOTE: assumes we're being called in an IE browser\n\n\t\tvar de = win.doc.documentElement; \/\/ only deal with HTML element here, position() handles body\/quirks\n\n\t\tif(has(\"ie\") < 8){\n\t\t\tvar r = de.getBoundingClientRect(), \/\/ works well for IE6+\n\t\t\t\tl = r.left, t = r.top;\n\t\t\tif(has(\"ie\") < 7){\n\t\t\t\tl += de.clientLeft;\t\/\/ scrollbar size in strict\/RTL, or,\n\t\t\t\tt += de.clientTop;\t\/\/ HTML border size in strict\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tx: l < 0 ? 0 : l, \/\/ FRAME element border size can lead to inaccurate negative values\n\t\t\t\ty: t < 0 ? 0 : t\n\t\t\t};\n\t\t}else{\n\t\t\treturn {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t};\n\t\t}\n\t};\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\n\tgeom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(\/*Integer*\/ scrollLeft){\n\t\t\/\/ In RTL direction, scrollLeft should be a negative value, but IE\n\t\t\/\/ returns a positive one. All codes using documentElement.scrollLeft\n\t\t\/\/ must call this function to fix this error, otherwise the position\n\t\t\/\/ will offset to right when there is a horizontal scrollbar.\n\n\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\tvar ie = has(\"ie\");\n\t\tif(ie && !geom.isBodyLtr()){\n\t\t\tvar qk = dojo.isQuirks,\n\t\t\t\tde = qk ? win.body() : win.doc.documentElement;\n\t\t\tif(ie == 6 && !qk && win.global.frameElement && de.scrollHeight > de.clientHeight){\n\t\t\t\tscrollLeft += de.clientLeft; \/\/ workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels\n\t\t\t}\n\t\t\treturn (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; \/\/ Integer\n\t\t}\n\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\treturn scrollLeft; \/\/ Integer\n\t};\n\n\tgeom.position = function(\/*DomNode*\/node, \/*Boolean?*\/includeScroll){\n\t\tnode = dom.byId(node);\n\t\tvar\tdb = win.body(),\n\t\t\tdh = db.parentNode,\n\t\t\tret = node.getBoundingClientRect();\n\t\tret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};\n\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\tif(has(\"ie\")){\n\t\t\t\/\/ On IE there's a 2px offset that we need to adjust for, see dojo.getIeDocumentElementOffset()\n\t\t\tvar offset = geom.getIeDocumentElementOffset();\n\n\t\t\t\/\/ fixes the position in IE, quirks mode\n\t\t\tret.x -= offset.x + (dojo.isQuirks ? db.clientLeft + db.offsetLeft : 0);\n\t\t\tret.y -= offset.y + (dojo.isQuirks ? db.clientTop + db.offsetTop : 0);\n\t\t}else if(has(\"ff\") == 3){\n\t\t\t\/\/ In FF3 you have to subtract the document element margins.\n\t\t\t\/\/ Fixed in FF3.5 though.\n\t\t\tvar cs = style.getComputedStyle(dh), px = style.toPixelValue;\n\t\t\tret.x -= px(dh, cs.marginLeft) + px(dh, cs.borderLeftWidth);\n\t\t\tret.y -= px(dh, cs.marginTop) + px(dh, cs.borderTopWidth);\n\t\t}\n\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\t\/\/ account for document scrolling\n\t\t\/\/ if offsetParent is used, ret value already includes scroll position\n\t\t\/\/ so we may have to actually remove that value if !includeScroll\n\t\tif(includeScroll){\n\t\t\tvar scroll = geom.docScroll();\n\t\t\tret.x += scroll.x;\n\t\t\tret.y += scroll.y;\n\t\t}\n\n\t\treturn ret; \/\/ Object\n\t};\n\n\t\/\/ random \"private\" functions wildly used throughout the toolkit\n\n\tgeom.getMarginSize = function getMarginSize(\/*DomNode*\/node, \/*Object*\/computedStyle){\n\t\tnode = dom.byId(node);\n\t\tvar me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));\n\t\tvar size = node.getBoundingClientRect();\n\t\treturn {\n\t\t\tw: (size.right - size.left) + me.w,\n\t\t\th: (size.bottom - size.top) + me.h\n\t\t}\n\t};\n\n\tgeom.normalizeEvent = function(event){\n\t\t\/\/ summary:\n\t\t\/\/ \t\tNormalizes the geometry of a DOM event, normalizing the pageX, pageY,\n\t\t\/\/ \t\toffsetX, offsetY, layerX, and layerX properties\n\t\t\/\/ event: Object\n\t\tif(!(\"layerX\" in event)){\n\t\t\tevent.layerX = event.offsetX;\n\t\t\tevent.layerY = event.offsetY;\n\t\t}\n\t\tif(!has(\"dom-addeventlistener\")){\n\t\t\t\/\/ old IE version\n\t\t\t\/\/ FIXME: scroll position query is duped from dojo.html to\n\t\t\t\/\/ avoid dependency on that entire module. Now that HTML is in\n\t\t\t\/\/ Base, we should convert back to something similar there.\n\t\t\tvar se = event.target;\n\t\t\tvar doc = (se && se.ownerDocument) || document;\n\t\t\t\/\/ DO NOT replace the following to use dojo.body(), in IE, document.documentElement should be used\n\t\t\t\/\/ here rather than document.body\n\t\t\tvar docBody = dojo.isQuirks ? doc.body : doc.documentElement;\n\t\t\tvar offset = geom.getIeDocumentElementOffset();\n\t\t\tevent.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0) - offset.x;\n\t\t\tevent.pageY = event.clientY + (docBody.scrollTop || 0) - offset.y;\n\t\t}\n\t};\n\n\t\/\/ TODO: evaluate separate getters\/setters for position and sizes?\n\n\treturn geom;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/_base\/sniff","dojo\/_base\/window","dojo\/dom","dojo\/dom-style"]},"dojo\/mouse":{"id":"dojo\/mouse","url":"\/home\/arian\/www\/MooTools\/dojo\/mouse.js","package":"dojo","amd":true,"content":"define([\".\/_base\/kernel\", \".\/on\", \".\/has\"], function(dojo, on, has){\r\n\t\r\n\t\/*===== dojo.mouse = {\r\n\t\/\/ summary:\r\n\t\/\/ \t\tThis module provide mouse event handling utility functions and exports\r\n\t\/\/ \t\tmouseenter and mouseleave event emulation.\r\n\t\/\/ enter:\r\n\t\/\/\t\tThis is an extension event for the mouseenter that IE provides, emulating the\r\n\t\/\/\t\tbehavior on other browsers.\r\n\t\/\/ leave:\r\n\t\/\/\t\tThis is an extension event for the mouseleave that IE provides, emulating the\r\n\t\/\/\t\tbehavior on other browsers.\r\n\t\/\/ example:\r\n\t\/\/\t\tTo use these events, you register a mouseenter like this:\r\n\t\/\/\t\t|\tdefine([\"dojo\/on\", dojo\/mouse\"], function(on, mouse){\r\n\t\/\/\t\t|\t\ton(targetNode, mouse.enter, function(event){\r\n\t\/\/ \t\t|\t\t\tdojo.addClass(targetNode, \"highlighted\");\r\n\t\/\/\t\t|\t\t});\r\n\t\/\/\t\t|\t\ton(targetNode, mouse.leave, function(event){\r\n\t\/\/ \t\t|\t\t\tdojo.removeClass(targetNode, \"highlighted\");\r\n\t\/\/\t\t|\t\t});\r\n\t\r\n\t};\r\n\t======*\/\r\n\t\r\n\thas.add(\"dom-quirks\", document.compatMode == \"BackCompat\");\r\n\thas.add(\"events-mouseenter\", \"onmouseenter\" in document.createElement(\"div\"));\r\n\tvar mouseButtons;\r\n\tif(has(\"dom-quirks\") || !has(\"dom-addeventlistener\")){\r\n\t\tmouseButtons = {\r\n\t\t\tLEFT:   1,\r\n\t\t\tMIDDLE: 4,\r\n\t\t\tRIGHT:  2,\r\n\t\t\t\/\/ helper functions\r\n\t\t\tisButton: function(e, button){ return e.button & button; },\r\n\t\t\tisLeft:   function(e){ return e.button & 1; },\r\n\t\t\tisMiddle: function(e){ return e.button & 4; },\r\n\t\t\tisRight:  function(e){ return e.button & 2; }\r\n\t\t};\r\n\t}else{\r\n\t\tmouseButtons = {\r\n\t\t\tLEFT:   0,\r\n\t\t\tMIDDLE: 1,\r\n\t\t\tRIGHT:  2,\r\n\t\t\t\/\/ helper functions\r\n\t\t\tisButton: function(e, button){ return e.button == button; },\r\n\t\t\tisLeft:   function(e){ return e.button == 0; },\r\n\t\t\tisMiddle: function(e){ return e.button == 1; },\r\n\t\t\tisRight:  function(e){ return e.button == 2; }\r\n\t\t};\r\n\t}\r\n\tdojo.mouseButtons = mouseButtons;\r\n\r\n\/*=====\r\n\tdojo.mouseButtons = {\r\n\t\t\/\/ LEFT: Number\r\n\t\t\/\/\t\tNumeric value of the left mouse button for the platform.\r\n\t\tLEFT:   0,\r\n\t\t\/\/ MIDDLE: Number\r\n\t\t\/\/\t\tNumeric value of the middle mouse button for the platform.\r\n\t\tMIDDLE: 1,\r\n\t\t\/\/ RIGHT: Number\r\n\t\t\/\/\t\tNumeric value of the right mouse button for the platform.\r\n\t\tRIGHT:  2,\r\n\t\r\n\t\tisButton: function(e, button){\r\n\t\t\t\/\/ summary:\r\n\t\t\t\/\/\t\tChecks an event object for a pressed button\r\n\t\t\t\/\/ e: Event\r\n\t\t\t\/\/\t\tEvent object to examine\r\n\t\t\t\/\/ button: Number\r\n\t\t\t\/\/\t\tThe button value (example: dojo.mouseButton.LEFT)\r\n\t\t\treturn e.button == button; \/\/ Boolean\r\n\t\t},\r\n\t\tisLeft: function(e){\r\n\t\t\t\/\/ summary:\r\n\t\t\t\/\/\t\tChecks an event object for the pressed left button\r\n\t\t\t\/\/ e: Event\r\n\t\t\t\/\/\t\tEvent object to examine\r\n\t\t\treturn e.button == 0; \/\/ Boolean\r\n\t\t},\r\n\t\tisMiddle: function(e){\r\n\t\t\t\/\/ summary:\r\n\t\t\t\/\/\t\tChecks an event object for the pressed middle button\r\n\t\t\t\/\/ e: Event\r\n\t\t\t\/\/\t\tEvent object to examine\r\n\t\t\treturn e.button == 1; \/\/ Boolean\r\n\t\t},\r\n\t\tisRight: function(e){\r\n\t\t\t\/\/ summary:\r\n\t\t\t\/\/\t\tChecks an event object for the pressed right button\r\n\t\t\t\/\/ e: Event\r\n\t\t\t\/\/\t\tEvent object to examine\r\n\t\t\treturn e.button == 2; \/\/ Boolean\r\n\t\t}\r\n\t};\r\n=====*\/\r\n\r\n\tif(has(\"events-mouseenter\")){\r\n\t\tvar eventHandler = function(type){\r\n\t\t\t\/\/ essentially a pass through, the browser already has mouseenter\/leave\r\n\t\t\treturn function(node, listener){\r\n\t\t\t\treturn on(node, type, listener);\r\n\t\t\t};\r\n\t\t};\r\n\t\treturn {\r\n\t\t\tmouseButtons: mouseButtons,\r\n\t\t\tenter: eventHandler(\"mouseenter\"),\r\n\t\t\tleave: eventHandler(\"mouseleave\") \r\n\t\t};\r\n\t}\r\n\telse{\r\n\t\tvar eventHandler = function(type){\r\n\t\t\t\/\/ emulation of mouseenter\/leave with mouseover\/out using descendant checking\r\n\t\t\treturn function(node, listener){\r\n\t\t\t\treturn on(node, type, function(evt){\r\n\t\t\t\t\tif(!dojo.isDescendant(evt.relatedTarget, node)){\r\n\t\t\t\t\t\treturn listener.call(this, evt);\r\n\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t};\r\n\t\treturn {\r\n\t\t\tmouseButtons: mouseButtons,\r\n\t\t\tenter: eventHandler(\"mouseover\"),\r\n\t\t\tleave: eventHandler(\"mouseout\")\r\n\t\t};\r\n\t}\r\n});\r\n","dependencies":["dojo\/_base\/kernel","dojo\/on","dojo\/has"]},"dojo\/keys":{"id":"dojo\/keys","url":"\/home\/arian\/www\/MooTools\/dojo\/keys.js","package":"dojo","amd":true,"content":"define([\".\/_base\/kernel\", \".\/_base\/sniff\"], function(dojo, has) {\r\n\t\/\/ module:\r\n\t\/\/\t\tdojo\/keys\r\n\t\/\/ summary:\r\n\t\/\/\t\tkey constants\r\n\/\/ Constants\r\n\r\n\/\/ Public: client code should test\r\n\/\/ keyCode against these named constants, as the\r\n\/\/ actual codes can vary by browser.\r\nreturn dojo.keys = {\r\n\t\/\/ summary:\r\n\t\/\/\t\tDefinitions for common key values\r\n\tBACKSPACE: 8,\r\n\tTAB: 9,\r\n\tCLEAR: 12,\r\n\tENTER: 13,\r\n\tSHIFT: 16,\r\n\tCTRL: 17,\r\n\tALT: 18,\r\n\tMETA: has(\"safari\") ? 91 : 224,\t\t\/\/ the apple key on macs\r\n\tPAUSE: 19,\r\n\tCAPS_LOCK: 20,\r\n\tESCAPE: 27,\r\n\tSPACE: 32,\r\n\tPAGE_UP: 33,\r\n\tPAGE_DOWN: 34,\r\n\tEND: 35,\r\n\tHOME: 36,\r\n\tLEFT_ARROW: 37,\r\n\tUP_ARROW: 38,\r\n\tRIGHT_ARROW: 39,\r\n\tDOWN_ARROW: 40,\r\n\tINSERT: 45,\r\n\tDELETE: 46,\r\n\tHELP: 47,\r\n\tLEFT_WINDOW: 91,\r\n\tRIGHT_WINDOW: 92,\r\n\tSELECT: 93,\r\n\tNUMPAD_0: 96,\r\n\tNUMPAD_1: 97,\r\n\tNUMPAD_2: 98,\r\n\tNUMPAD_3: 99,\r\n\tNUMPAD_4: 100,\r\n\tNUMPAD_5: 101,\r\n\tNUMPAD_6: 102,\r\n\tNUMPAD_7: 103,\r\n\tNUMPAD_8: 104,\r\n\tNUMPAD_9: 105,\r\n\tNUMPAD_MULTIPLY: 106,\r\n\tNUMPAD_PLUS: 107,\r\n\tNUMPAD_ENTER: 108,\r\n\tNUMPAD_MINUS: 109,\r\n\tNUMPAD_PERIOD: 110,\r\n\tNUMPAD_DIVIDE: 111,\r\n\tF1: 112,\r\n\tF2: 113,\r\n\tF3: 114,\r\n\tF4: 115,\r\n\tF5: 116,\r\n\tF6: 117,\r\n\tF7: 118,\r\n\tF8: 119,\r\n\tF9: 120,\r\n\tF10: 121,\r\n\tF11: 122,\r\n\tF12: 123,\r\n\tF13: 124,\r\n\tF14: 125,\r\n\tF15: 126,\r\n\tNUM_LOCK: 144,\r\n\tSCROLL_LOCK: 145,\r\n\tUP_DPAD: 175,\r\n\tDOWN_DPAD: 176,\r\n\tLEFT_DPAD: 177,\r\n\tRIGHT_DPAD: 178,\r\n\t\/\/ virtual key mapping\r\n\tcopyKey: has(\"mac\") && !has(\"air\") ? (has(\"safari\") ? 91 : 224 ) : 17\r\n};\r\n});\r\n","dependencies":["dojo\/_base\/kernel","dojo\/_base\/sniff"]},"dojo\/dom-class":{"id":"dojo\/dom-class","url":"\/home\/arian\/www\/MooTools\/dojo\/dom-class.js","package":"dojo","amd":true,"content":"define([\".\/_base\/lang\", \".\/_base\/array\", \".\/dom\"], function(lang, array, dom){\n\t\/\/ module:\n\t\/\/\t\tdojo\/dom-class\n\t\/\/ summary:\n\t\/\/\t\tThis module defines the core dojo DOM class API.\n\n\tvar className = \"className\";\n\n\t\/* Part I of classList-based implementation is preserved here for posterity\n\tvar classList = \"classList\";\n\thas.add(\"dom-classList\", function(){\n\t\treturn classList in document.createElement(\"p\");\n\t});\n\t*\/\n\n\t\/\/ =============================\n\t\/\/ (CSS) Class Functions\n\t\/\/ =============================\n\n\t\/*=====\n\tdojo.hasClass = function(node, classStr){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReturns whether or not the specified classes are a portion of the\n\t\t\/\/\t\tclass list currently applied to the node.\n\t\t\/\/\n\t\t\/\/ node: String|DOMNode\n\t\t\/\/\t\tString ID or DomNode reference to check the class for.\n\t\t\/\/\n\t\t\/\/ classStr: String\n\t\t\/\/\t\tA string class name to look for.\n\t\t\/\/\n\t\t\/\/ returns: Boolean\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tDo something if a node with id=\"someNode\" has class=\"aSillyClassName\" present\n\t\t\/\/\t|\tif(dojo.hasClass(\"someNode\",\"aSillyClassName\")){ ... }\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.addClass = function(node, classStr){\n\t\t\/\/ summary:\n\t\t\/\/\t\tAdds the specified classes to the end of the class list on the\n\t\t\/\/\t\tpassed node. Will not re-apply duplicate classes.\n\t\t\/\/\n\t\t\/\/ node: String|DOMNode\n\t\t\/\/\t\tString ID or DomNode reference to add a class string too\n\t\t\/\/\n\t\t\/\/ classStr: String|Array\n\t\t\/\/\t\tA String class name to add, or several space-separated class names,\n\t\t\/\/\t\tor an array of class names.\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tAdd a class to some node:\n\t\t\/\/\t|\tdojo.addClass(\"someNode\", \"anewClass\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tAdd two classes at once:\n\t\t\/\/\t|\tdojo.addClass(\"someNode\", \"firstClass secondClass\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tAdd two classes at once (using array):\n\t\t\/\/\t|\tdojo.addClass(\"someNode\", [\"firstClass\", \"secondClass\"]);\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tAvailable in `dojo.NodeList` for multiple additions\n\t\t\/\/\t|\tdojo.query(\"ul > li\").addClass(\"firstLevel\");\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.removeClass = function(node, classStr){\n\t\t\/\/ summary:\n\t\t\/\/\t\tRemoves the specified classes from node. No `dojo.hasClass`\n\t\t\/\/\t\tcheck is required.\n\t\t\/\/\n\t\t\/\/ node: String|DOMNode\n\t\t\/\/\t\tString ID or DomNode reference to remove the class from.\n\t\t\/\/\n\t\t\/\/ classStr: String|Array\n\t\t\/\/\t\tAn optional String class name to remove, or several space-separated\n\t\t\/\/\t\tclass names, or an array of class names. If omitted, all class names\n\t\t\/\/\t\twill be deleted.\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tRemove a class from some node:\n\t\t\/\/\t|\tdojo.removeClass(\"someNode\", \"firstClass\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tRemove two classes from some node:\n\t\t\/\/\t|\tdojo.removeClass(\"someNode\", \"firstClass secondClass\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tRemove two classes from some node (using array):\n\t\t\/\/\t|\tdojo.removeClass(\"someNode\", [\"firstClass\", \"secondClass\"]);\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tRemove all classes from some node:\n\t\t\/\/\t|\tdojo.removeClass(\"someNode\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tAvailable in `dojo.NodeList()` for multiple removal\n\t\t\/\/\t|\tdojo.query(\".foo\").removeClass(\"foo\");\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.replaceClass = function(node, addClassStr, removeClassStr){\n\t\t\/\/ summary:\n\t\t\/\/\t\tReplaces one or more classes on a node if not present.\n\t\t\/\/\t\tOperates more quickly than calling dojo.removeClass and dojo.addClass\n\t\t\/\/\n\t\t\/\/ node: String|DOMNode\n\t\t\/\/\t\tString ID or DomNode reference to remove the class from.\n\t\t\/\/\n\t\t\/\/ addClassStr: String|Array\n\t\t\/\/\t\tA String class name to add, or several space-separated class names,\n\t\t\/\/\t\tor an array of class names.\n\t\t\/\/\n\t\t\/\/ removeClassStr: String|Array?\n\t\t\/\/\t\tA String class name to remove, or several space-separated class names,\n\t\t\/\/\t\tor an array of class names.\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t|\tdojo.replaceClass(\"someNode\", \"add1 add2\", \"remove1 remove2\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tReplace all classes with addMe\n\t\t\/\/\t|\tdojo.replaceClass(\"someNode\", \"addMe\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\tAvailable in `dojo.NodeList()` for multiple toggles\n\t\t\/\/\t|\tdojo.query(\".findMe\").replaceClass(\"addMe\", \"removeMe\");\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.toggleClass = function(node, classStr, condition){\n\t\t\/\/ summary:\n\t\t\/\/\t\tAdds a class to node if not present, or removes if present.\n\t\t\/\/\t\tPass a boolean condition if you want to explicitly add or remove.\n\t\t\/\/      Returns the condition that was specified directly or indirectly.\n\t\t\/\/\n\t\t\/\/ node: String|DOMNode\n\t\t\/\/\t\tString ID or DomNode reference to toggle a class string\n\t\t\/\/\n\t\t\/\/ classStr: String|Array\n\t\t\/\/\t\tA String class name to toggle, or several space-separated class names,\n\t\t\/\/\t\tor an array of class names.\n\t\t\/\/\n\t\t\/\/ condition:\n\t\t\/\/\t\tIf passed, true means to add the class, false means to remove.\n\t\t\/\/      Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t|\tdojo.toggleClass(\"someNode\", \"hovered\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tForcefully add a class\n\t\t\/\/\t|\tdojo.toggleClass(\"someNode\", \"hovered\", true);\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tAvailable in `dojo.NodeList()` for multiple toggles\n\t\t\/\/\t|\tdojo.query(\".toggleMe\").toggleClass(\"toggleMe\");\n\t};\n\t=====*\/\n\n\tvar cls, \/\/ exports object\n\t\tspaces = \/\\s+\/, a1 = [\"\"];\n\n\tfunction str2array(s){\n\t\tif(typeof s == \"string\" || s instanceof String){\n\t\t\tif(s && !spaces.test(s)){\n\t\t\t\ta1[0] = s;\n\t\t\t\treturn a1;\n\t\t\t}\n\t\t\tvar a = s.split(spaces);\n\t\t\tif(a.length && !a[0]){\n\t\t\t\ta.shift();\n\t\t\t}\n\t\t\tif(a.length && !a[a.length - 1]){\n\t\t\t\ta.pop();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t\/\/ assumed to be an array\n\t\tif(!s){\n\t\t\treturn [];\n\t\t}\n\t\treturn array.filter(s, function(x){ return x; });\n\t}\n\n\t\/* Part II of classList-based implementation is preserved here for posterity\n\tif(has(\"dom-classList\")){\n\t\t\/\/ new classList version\n\t\tcls = {\n\t\t\tcontains: function containsClass(node, classStr){\n\t\t\t\tvar clslst = classStr && dom.byId(node)[classList];\n\t\t\t\treturn clslst && clslst.contains(classStr); \/\/ Boolean\n\t\t\t},\n\n\t\t\tadd: function addClass(node, classStr){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\tnode[classList].add(classStr[i]);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tremove: function removeClass(node, classStr){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tif(classStr === undefined){\n\t\t\t\t\tnode[className] = \"\";\n\t\t\t\t}else{\n\t\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\t\tnode[classList].remove(classStr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\treplace: function replaceClass(node, addClassStr, removeClassStr){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tif(removeClassStr === undefined){\n\t\t\t\t\tnode[className] = \"\";\n\t\t\t\t}else{\n\t\t\t\t\tremoveClassStr = str2array(removeClassStr);\n\t\t\t\t\tfor(var i = 0, len = removeClassStr.length; i < len; ++i){\n\t\t\t\t\t\tnode[classList].remove(removeClassStr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddClassStr = str2array(addClassStr);\n\t\t\t\tfor(i = 0, len = addClassStr.length; i < len; ++i){\n\t\t\t\t\tnode[classList].add(addClassStr[i]);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\ttoggle: function toggleClass(node, classStr, condition){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tif(condition === undefined){\n\t\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\t\tnode[classList].toggle(classStr[i]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcls[condition ? \"add\" : \"remove\"](node, classStr);\n\t\t\t\t}\n\t\t\t\treturn condition;   \/\/ Boolean\n\t\t\t}\n\t\t}\n\t}\n\t*\/\n\n\t\/\/ regular DOM version\n\tvar fakeNode = {};  \/\/ for effective replacement\n\tcls = {\n\t\tcontains: function containsClass(\/*DomNode|String*\/node, \/*String*\/classStr){\n\t\t\treturn ((\" \" + dom.byId(node)[className] + \" \").indexOf(\" \" + classStr + \" \") >= 0); \/\/ Boolean\n\t\t},\n\n\t\tadd: function addClass(\/*DomNode|String*\/node, \/*String|Array*\/classStr){\n\t\t\tnode = dom.byId(node);\n\t\t\tclassStr = str2array(classStr);\n\t\t\tvar cls = node[className], oldLen;\n\t\t\tcls = cls ? \" \" + cls + \" \" : \" \";\n\t\t\toldLen = cls.length;\n\t\t\tfor(var i = 0, len = classStr.length, c; i < len; ++i){\n\t\t\t\tc = classStr[i];\n\t\t\t\tif(c && cls.indexOf(\" \" + c + \" \") < 0){\n\t\t\t\t\tcls += c + \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(oldLen < cls.length){\n\t\t\t\tnode[className] = cls.substr(1, cls.length - 2);\n\t\t\t}\n\t\t},\n\n\t\tremove: function removeClass(\/*DomNode|String*\/node, \/*String|Array?*\/classStr){\n\t\t\tnode = dom.byId(node);\n\t\t\tvar cls;\n\t\t\tif(classStr !== undefined){\n\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\tcls = \" \" + node[className] + \" \";\n\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\tcls = cls.replace(\" \" + classStr[i] + \" \", \" \");\n\t\t\t\t}\n\t\t\t\tcls = lang.trim(cls);\n\t\t\t}else{\n\t\t\t\tcls = \"\";\n\t\t\t}\n\t\t\tif(node[className] != cls){ node[className] = cls; }\n\t\t},\n\n\t\treplace: function replaceClass(\/*DomNode|String*\/node, \/*String|Array*\/addClassStr, \/*String|Array?*\/removeClassStr){\n\t\t\tnode = dom.byId(node);\n\t\t\tfakeNode[className] = node[className];\n\t\t\tcls.remove(fakeNode, removeClassStr);\n\t\t\tcls.add(fakeNode, addClassStr);\n\t\t\tif(node[className] !== fakeNode[className]){\n\t\t\t\tnode[className] = fakeNode[className];\n\t\t\t}\n\t\t},\n\n\t\ttoggle: function toggleClass(\/*DomNode|String*\/node, \/*String|Array*\/classStr, \/*Boolean?*\/condition){\n\t\t\tnode = dom.byId(node);\n\t\t\tif(condition === undefined){\n\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\tfor(var i = 0, len = classStr.length, c; i < len; ++i){\n\t\t\t\t\tc = classStr[i];\n\t\t\t\t\tcls[cls.contains(node, c) ? \"remove\" : \"add\"](node, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcls[condition ? \"add\" : \"remove\"](node, classStr);\n\t\t\t}\n\t\t\treturn condition;   \/\/ Boolean\n\t\t}\n\t};\n\n\treturn cls;\n});\n","dependencies":["dojo\/_base\/lang","dojo\/_base\/array","dojo\/dom"]},"dojo\/dom-construct":{"id":"dojo\/dom-construct","url":"\/home\/arian\/www\/MooTools\/dojo\/dom-construct.js","package":"dojo","amd":true,"content":"define([\".\/_base\/kernel\", \".\/_base\/sniff\", \".\/_base\/window\", \".\/dom\", \".\/dom-attr\", \".\/on\"],\n\t\tfunction(dojo, has, win, dom, attr, on){\n\t\/\/ module:\n\t\/\/\t\tdojo\/dom-construct\n\t\/\/ summary:\n\t\/\/\t\tThis module defines the core dojo DOM construction API.\n\n\t\/*=====\n\tdojo.toDom = function(frag, doc){\n\t\t\/\/ summary:\n\t\t\/\/\t\tinstantiates an HTML fragment returning the corresponding DOM.\n\t\t\/\/ frag: String\n\t\t\/\/\t\tthe HTML fragment\n\t\t\/\/ doc: DocumentNode?\n\t\t\/\/\t\toptional document to use when creating DOM nodes, defaults to\n\t\t\/\/\t\tdojo.doc if not specified.\n\t\t\/\/ returns: DocumentFragment\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tCreate a table row:\n\t\t\/\/\t|\tvar tr = dojo.toDom(\"<tr><td>First!<\/td><\/tr>\");\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._toDom = function(frag, doc){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.toDom`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.place = function(node, refNode, position){\n\t\t\/\/ summary:\n\t\t\/\/\t\tAttempt to insert node into the DOM, choosing from various positioning options.\n\t\t\/\/\t\tReturns the first argument resolved to a DOM node.\n\t\t\/\/\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tid or node reference, or HTML fragment starting with \"<\" to place relative to refNode\n\t\t\/\/\n\t\t\/\/ refNode: DOMNode|String\n\t\t\/\/\t\tid or node reference to use as basis for placement\n\t\t\/\/\n\t\t\/\/ position: String|Number?\n\t\t\/\/\t\tstring noting the position of node relative to refNode or a\n\t\t\/\/\t\tnumber indicating the location in the childNodes collection of refNode.\n\t\t\/\/\t\tAccepted string values are:\n\t\t\/\/\t|\t* before\n\t\t\/\/\t|\t* after\n\t\t\/\/\t|\t* replace\n\t\t\/\/\t|\t* only\n\t\t\/\/\t|\t* first\n\t\t\/\/\t|\t* last\n\t\t\/\/\t\t\"first\" and \"last\" indicate positions as children of refNode, \"replace\" replaces refNode,\n\t\t\/\/\t\t\"only\" replaces all children.  position defaults to \"last\" if not specified\n\t\t\/\/\n\t\t\/\/ returns: DOMNode\n\t\t\/\/\t\tReturned values is the first argument resolved to a DOM node.\n\t\t\/\/\n\t\t\/\/\t\t.place() is also a method of `dojo.NodeList`, allowing `dojo.query` node lookups.\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tPlace a node by string id as the last child of another node by string id:\n\t\t\/\/\t|\tdojo.place(\"someNode\", \"anotherNode\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tPlace a node by string id before another node by string id\n\t\t\/\/\t|\tdojo.place(\"someNode\", \"anotherNode\", \"before\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tCreate a Node, and place it in the body element (last child):\n\t\t\/\/\t|\tdojo.place(\"<div><\/div>\", dojo.body());\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tPut a new LI as the first child of a list by id:\n\t\t\/\/\t|\tdojo.place(\"<li><\/li>\", \"someUl\", \"first\");\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.create = function(tag, attrs, refNode, pos){\n\t\t\/\/ summary:\n\t\t\/\/\t\tCreate an element, allowing for optional attribute decoration\n\t\t\/\/\t\tand placement.\n\t\t\/\/\n\t\t\/\/ description:\n\t\t\/\/\t\tA DOM Element creation function. A shorthand method for creating a node or\n\t\t\/\/\t\ta fragment, and allowing for a convenient optional attribute setting step,\n\t\t\/\/\t\tas well as an optional DOM placement reference.\n\t\t\/\/|\n\t\t\/\/\t\tAttributes are set by passing the optional object through `dojo.setAttr`.\n\t\t\/\/\t\tSee `dojo.setAttr` for noted caveats and nuances, and API if applicable.\n\t\t\/\/|\n\t\t\/\/\t\tPlacement is done via `dojo.place`, assuming the new node to be the action\n\t\t\/\/\t\tnode, passing along the optional reference node and position.\n\t\t\/\/\n\t\t\/\/ tag: DOMNode|String\n\t\t\/\/\t\tA string of the element to create (eg: \"div\", \"a\", \"p\", \"li\", \"script\", \"br\"),\n\t\t\/\/\t\tor an existing DOM node to process.\n\t\t\/\/\n\t\t\/\/ attrs: Object\n\t\t\/\/\t\tAn object-hash of attributes to set on the newly created node.\n\t\t\/\/\t\tCan be null, if you don't want to set any attributes\/styles.\n\t\t\/\/\t\tSee: `dojo.setAttr` for a description of available attributes.\n\t\t\/\/\n\t\t\/\/ refNode: DOMNode?|String?\n\t\t\/\/\t\tOptional reference node. Used by `dojo.place` to place the newly created\n\t\t\/\/\t\tnode somewhere in the dom relative to refNode. Can be a DomNode reference\n\t\t\/\/\t\tor String ID of a node.\n\t\t\/\/\n\t\t\/\/ pos: String?\n\t\t\/\/\t\tOptional positional reference. Defaults to \"last\" by way of `dojo.place`,\n\t\t\/\/\t\tthough can be set to \"first\",\"after\",\"before\",\"last\", \"replace\" or \"only\"\n\t\t\/\/\t\tto further control the placement of the new node relative to the refNode.\n\t\t\/\/\t\t'refNode' is required if a 'pos' is specified.\n\t\t\/\/\n\t\t\/\/ returns: DOMNode\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tCreate a DIV:\n\t\t\/\/\t|\tvar n = dojo.create(\"div\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tCreate a DIV with content:\n\t\t\/\/\t|\tvar n = dojo.create(\"div\", { innerHTML:\"<p>hi<\/p>\" });\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tPlace a new DIV in the BODY, with no attributes set\n\t\t\/\/\t|\tvar n = dojo.create(\"div\", null, dojo.body());\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tCreate an UL, and populate it with LI's. Place the list as the first-child of a\n\t\t\/\/\t\tnode with id=\"someId\":\n\t\t\/\/\t|\tvar ul = dojo.create(\"ul\", null, \"someId\", \"first\");\n\t\t\/\/\t|\tvar items = [\"one\", \"two\", \"three\", \"four\"];\n\t\t\/\/\t|\tdojo.forEach(items, function(data){\n\t\t\/\/\t|\t\tdojo.create(\"li\", { innerHTML: data }, ul);\n\t\t\/\/\t|\t});\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tCreate an anchor, with an href. Place in BODY:\n\t\t\/\/\t|\tdojo.create(\"a\", { href:\"foo.html\", title:\"Goto FOO!\" }, dojo.body());\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tCreate a `dojo.NodeList()` from a new element (for syntatic sugar):\n\t\t\/\/\t|\tdojo.query(dojo.create('div'))\n\t\t\/\/\t|\t\t.addClass(\"newDiv\")\n\t\t\/\/\t|\t\t.onclick(function(e){ console.log('clicked', e.target) })\n\t\t\/\/\t|\t\t.place(\"#someNode\"); \/\/ redundant, but cleaner.\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo.empty = function(node){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tsafely removes all children of the node.\n\t\t\t\/\/ node: DOMNode|String\n\t\t\t\/\/\t\ta reference to a DOM node or an id.\n\t\t\t\/\/ example:\n\t\t\t\/\/\t\tDestroy node's children byId:\n\t\t\t\/\/\t|\tdojo.empty(\"someId\");\n\t\t\t\/\/\n\t\t\t\/\/ example:\n\t\t\t\/\/\t\tDestroy all nodes' children in a list by reference:\n\t\t\t\/\/\t|\tdojo.query(\".someNode\").forEach(dojo.empty);\n\t}\n\t=====*\/\n\n\t\/*=====\n\tdojo.destroy = function(node){\n\t\t\/\/ summary:\n\t\t\/\/\t\tRemoves a node from its parent, clobbering it and all of its\n\t\t\/\/\t\tchildren.\n\t\t\/\/\n\t\t\/\/ description:\n\t\t\/\/\t\tRemoves a node from its parent, clobbering it and all of its\n\t\t\/\/\t\tchildren. Function only works with DomNodes, and returns nothing.\n\t\t\/\/\n\t\t\/\/ node: DOMNode|String\n\t\t\/\/\t\tA String ID or DomNode reference of the element to be destroyed\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tDestroy a node byId:\n\t\t\/\/\t|\tdojo.destroy(\"someId\");\n\t\t\/\/\n\t\t\/\/ example:\n\t\t\/\/\t\tDestroy all nodes in a list by reference:\n\t\t\/\/\t|\tdojo.query(\".someNode\").forEach(dojo.destroy);\n\t};\n\t=====*\/\n\n\t\/*=====\n\tdojo._destroyElement = function(node){\n\t\t\/\/ summary:\n\t\t\/\/\t\tExisting alias for `dojo.destroy`. Deprecated, will be removed in 2.0.\n\t};\n\t=====*\/\n\n\t\/\/ support stuff for dojo.toDom\n\tvar tagWrap = {\n\t\t\toption: [\"select\"],\n\t\t\ttbody: [\"table\"],\n\t\t\tthead: [\"table\"],\n\t\t\ttfoot: [\"table\"],\n\t\t\ttr: [\"table\", \"tbody\"],\n\t\t\ttd: [\"table\", \"tbody\", \"tr\"],\n\t\t\tth: [\"table\", \"thead\", \"tr\"],\n\t\t\tlegend: [\"fieldset\"],\n\t\t\tcaption: [\"table\"],\n\t\t\tcolgroup: [\"table\"],\n\t\t\tcol: [\"table\", \"colgroup\"],\n\t\t\tli: [\"ul\"]\n\t\t},\n\t\treTag = \/<\\s*([\\w\\:]+)\/,\n\t\tmasterNode = {}, masterNum = 0,\n\t\tmasterName = \"__\" + dojo._scopeName + \"ToDomId\",\n\t\tctr; \/\/ the result object\n\n\t\/\/ generate start\/end tag strings to use\n\t\/\/ for the injection for each special tag wrap case.\n\tfor(var param in tagWrap){\n\t\tif(tagWrap.hasOwnProperty(param)){\n\t\t\tvar tw = tagWrap[param];\n\t\t\ttw.pre = param == \"option\" ? '<select multiple=\"multiple\">' : \"<\" + tw.join(\"><\") + \">\";\n\t\t\ttw.post = \"<\/\" + tw.reverse().join(\"><\/\") + \">\";\n\t\t\t\/\/ the last line is destructive: it reverses the array,\n\t\t\t\/\/ but we don't care at this point\n\t\t}\n\t}\n\n\tfunction _insertBefore(\/*DomNode*\/node, \/*DomNode*\/ref){\n\t\tvar parent = ref.parentNode;\n\t\tif(parent){\n\t\t\tparent.insertBefore(node, ref);\n\t\t}\n\t}\n\n\tfunction _insertAfter(\/*DomNode*\/node, \/*DomNode*\/ref){\n\t\t\/\/ summary:\n\t\t\/\/\t\tTry to insert node after ref\n\t\tvar parent = ref.parentNode;\n\t\tif(parent){\n\t\t\tif(parent.lastChild == ref){\n\t\t\t\tparent.appendChild(node);\n\t\t\t}else{\n\t\t\t\tparent.insertBefore(node, ref.nextSibling);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar _destroyContainer = null,\n\t\t_destroyDoc;\n\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\ton(window, \"unload\", function(){\n\t\t_destroyContainer = null; \/\/prevent IE leak\n\t});\n\t\/\/>>excludeEnd(\"webkitMobile\");\n\n\tctr = {\n\t\ttoDom: function toDom(frag, doc){\n\t\t\tdoc = doc || win.doc;\n\t\t\tvar masterId = doc[masterName];\n\t\t\tif(!masterId){\n\t\t\t\tdoc[masterName] = masterId = ++masterNum + \"\";\n\t\t\t\tmasterNode[masterId] = doc.createElement(\"div\");\n\t\t\t}\n\n\t\t\t\/\/ make sure the frag is a string.\n\t\t\tfrag += \"\";\n\n\t\t\t\/\/ find the starting tag, and get node wrapper\n\t\t\tvar match = frag.match(reTag),\n\t\t\t\ttag = match ? match[1].toLowerCase() : \"\",\n\t\t\t\tmaster = masterNode[masterId],\n\t\t\t\twrap, i, fc, df;\n\t\t\tif(match && tagWrap[tag]){\n\t\t\t\twrap = tagWrap[tag];\n\t\t\t\tmaster.innerHTML = wrap.pre + frag + wrap.post;\n\t\t\t\tfor(i = wrap.length; i; --i){\n\t\t\t\t\tmaster = master.firstChild;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tmaster.innerHTML = frag;\n\t\t\t}\n\n\t\t\t\/\/ one node shortcut => return the node itself\n\t\t\tif(master.childNodes.length == 1){\n\t\t\t\treturn master.removeChild(master.firstChild); \/\/ DOMNode\n\t\t\t}\n\n\t\t\t\/\/ return multiple nodes as a document fragment\n\t\t\tdf = doc.createDocumentFragment();\n\t\t\twhile(fc = master.firstChild){ \/\/ intentional assignment\n\t\t\t\tdf.appendChild(fc);\n\t\t\t}\n\t\t\treturn df; \/\/ DOMNode\n\t\t},\n\n\t\tplace: function place(\/*DOMNode|String*\/node, \/*DOMNode|String*\/refNode, \/*String|Number?*\/position){\n\t\t\trefNode = dom.byId(refNode);\n\t\t\tif(typeof node == \"string\"){ \/\/ inline'd type check\n\t\t\t\tnode = \/^\\s*<\/.test(node) ? ctr.toDom(node, refNode.ownerDocument) : dom.byId(node);\n\t\t\t}\n\t\t\tif(typeof position == \"number\"){ \/\/ inline'd type check\n\t\t\t\tvar cn = refNode.childNodes;\n\t\t\t\tif(!cn.length || cn.length <= position){\n\t\t\t\t\trefNode.appendChild(node);\n\t\t\t\t}else{\n\t\t\t\t\t_insertBefore(node, cn[position < 0 ? 0 : position]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tswitch(position){\n\t\t\t\t\tcase \"before\":\n\t\t\t\t\t\t_insertBefore(node, refNode);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"after\":\n\t\t\t\t\t\t_insertAfter(node, refNode);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"replace\":\n\t\t\t\t\t\trefNode.parentNode.replaceChild(node, refNode);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"only\":\n\t\t\t\t\t\tdojo.empty(refNode);\n\t\t\t\t\t\trefNode.appendChild(node);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"first\":\n\t\t\t\t\t\tif(refNode.firstChild){\n\t\t\t\t\t\t\t_insertBefore(node, refNode.firstChild);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\/\/ else fallthrough...\n\t\t\t\t\tdefault: \/\/ aka: last\n\t\t\t\t\t\trefNode.appendChild(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node; \/\/ DomNode\n\t\t},\n\n\t\tcreate: function create(\/*DOMNode|String*\/tag, \/*Object*\/attrs, \/*DOMNode?|String?*\/refNode, \/*String?*\/pos){\n\t\t\tvar doc = win.doc;\n\t\t\tif(refNode){\n\t\t\t\trefNode = dom.byId(refNode);\n\t\t\t\tdoc = refNode.ownerDocument;\n\t\t\t}\n\t\t\tif(typeof tag == \"string\"){ \/\/ inline'd type check\n\t\t\t\ttag = doc.createElement(tag);\n\t\t\t}\n\t\t\tif(attrs){ attr.set(tag, attrs); }\n\t\t\tif(refNode){ ctr.place(tag, refNode, pos); }\n\t\t\treturn tag; \/\/ DomNode\n\t\t},\n\n\t\tempty:\n\t\t\t\/\/>>excludeStart(\"webkitMobile\", kwArgs.webkitMobile);\n\t\t\thas(\"ie\") ? function(node){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tfor(var c; c = node.lastChild;){ \/\/ intentional assignment\n\t\t\t\t\tdojo.destroy(c);\n\t\t\t\t}\n\t\t\t} :\n\t\t\t\/\/>>excludeEnd(\"webkitMobile\");\n\t\t\tfunction(node){\n\t\t\t\tdom.byId(node).innerHTML = \"\";\n\t\t\t},\n\n\t\tdestroy: function destroy(\/*DOMNode|String*\/node){\n\t\t\tnode = dom.byId(node);\n\t\t\ttry{\n\t\t\t\tvar doc = node.ownerDocument;\n\t\t\t\t\/\/ cannot use _destroyContainer.ownerDocument since this can throw an exception on IE\n\t\t\t\tif(!_destroyContainer || _destroyDoc != doc){\n\t\t\t\t\t_destroyContainer = doc.createElement(\"div\");\n\t\t\t\t\t_destroyDoc = doc;\n\t\t\t\t}\n\t\t\t\t_destroyContainer.appendChild(node.parentNode ? node.parentNode.removeChild(node) : node);\n\t\t\t\t\/\/ NOTE: see http:\/\/trac.dojotoolkit.org\/ticket\/2931. This may be a bug and not a feature\n\t\t\t\t_destroyContainer.innerHTML = \"\";\n\t\t\t}catch(e){\n\t\t\t\t\/* squelch *\/\n\t\t\t}\n\t\t}\n\t};\n\n\treturn ctr;\n});\n","dependencies":["dojo\/_base\/kernel","dojo\/_base\/sniff","dojo\/_base\/window","dojo\/dom","dojo\/dom-attr","dojo\/on"]},"dojo\/_base\/unload":{"id":"dojo\/_base\/unload","url":"\/home\/arian\/www\/MooTools\/dojo\/_base\/unload.js","package":"dojo","amd":true,"content":"define([\".\/kernel\", \".\/connect\"], function(dojo) {\n\t\/\/ module:\n\t\/\/\t\tdojo\/unload\n\t\/\/ summary:\n\t\/\/\t\tThis module contains the document and window unload detection API.\n\n\tvar win = window;\n\n\t\/*=====\n\t\tdojo.windowUnloaded = function(){\n\t\t\t\/\/ summary:\n\t\t\t\/\/\t\tsignal fired by impending window destruction. You may use\n\t\t\t\/\/\t\tdojo.addOnWindowUnload() to register a listener for this\n\t\t\t\/\/\t\tevent. NOTE: if you wish to dojo.connect() to this method\n\t\t\t\/\/\t\tto perform page\/application cleanup, be aware that this\n\t\t\t\/\/\t\tevent WILL NOT fire if no handler has been registered with\n\t\t\t\/\/\t\tdojo.addOnWindowUnload. This behavior started in Dojo 1.3.\n\t\t\t\/\/\t\tPrevious versions always triggered dojo.windowUnloaded. See\n\t\t\t\/\/\t\tdojo.addOnWindowUnload for more info.\n\t\t};\n\t=====*\/\n\n\tdojo.addOnWindowUnload = function(\/*Object?|Function?*\/obj, \/*String|Function?*\/functionName){\n\t\t\/\/ summary:\n\t\t\/\/\t\tregisters a function to be triggered when window.onunload\n\t\t\/\/\t\tfires.\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tThe first time that addOnWindowUnload is called Dojo\n\t\t\/\/\t\twill register a page listener to trigger your unload\n\t\t\/\/\t\thandler with. Note that registering these handlers may\n\t\t\/\/\t\tdestory \"fastback\" page caching in browsers that support\n\t\t\/\/\t\tit. Be careful trying to modify the DOM or access\n\t\t\/\/\t\tJavaScript properties during this phase of page unloading:\n\t\t\/\/\t\tthey may not always be available. Consider\n\t\t\/\/\t\tdojo.addOnUnload() if you need to modify the DOM or do\n\t\t\/\/\t\theavy JavaScript work since it fires at the eqivalent of\n\t\t\/\/\t\tthe page's \"onbeforeunload\" event.\n\t\t\/\/ example:\n\t\t\/\/\t| dojo.addOnWindowUnload(functionPointer)\n\t\t\/\/\t| dojo.addOnWindowUnload(object, \"functionName\");\n\t\t\/\/\t| dojo.addOnWindowUnload(object, function(){ \/* ... *\/});\n\n\t\tif (!dojo.windowUnloaded) {\n\t\t\tdojo.connect(win, \"unload\", (dojo.windowUnloaded= function(){}));\n\t\t}\n\t\tdojo.connect(win, \"unload\", obj, functionName);\n\t};\n\n\tdojo.addOnUnload = function(\/*Object?|Function?*\/obj, \/*String|Function?*\/functionName){\n\t\t\/\/ summary:\n\t\t\/\/\t\tregisters a function to be triggered when the page unloads.\n\t\t\/\/\tdescription:\n\t\t\/\/\t\tThe first time that addOnUnload is called Dojo will\n\t\t\/\/\t\tregister a page listener to trigger your unload handler\n\t\t\/\/\t\twith.\n\t\t\/\/\n\t\t\/\/\t\tIn a browser enviroment, the functions will be triggered\n\t\t\/\/\t\tduring the window.onbeforeunload event. Be careful of doing\n\t\t\/\/\t\ttoo much work in an unload handler. onbeforeunload can be\n\t\t\/\/\t\ttriggered if a link to download a file is clicked, or if\n\t\t\/\/\t\tthe link is a javascript: link. In these cases, the\n\t\t\/\/\t\tonbeforeunload event fires, but the document is not\n\t\t\/\/\t\tactually destroyed. So be careful about doing destructive\n\t\t\/\/\t\toperations in a dojo.addOnUnload callback.\n\t\t\/\/\n\t\t\/\/\t\tFurther note that calling dojo.addOnUnload will prevent\n\t\t\/\/\t\tbrowsers from using a \"fast back\" cache to make page\n\t\t\/\/\t\tloading via back button instantaneous.\n\t\t\/\/ example:\n\t\t\/\/\t| dojo.addOnUnload(functionPointer)\n\t\t\/\/\t| dojo.addOnUnload(object, \"functionName\")\n\t\t\/\/\t| dojo.addOnUnload(object, function(){ \/* ... *\/});\n\n\t\tdojo.connect(win, \"beforeunload\", obj, functionName);\n\t};\n\n\treturn {\n\t\taddOnWindowUnload: dojo.addOnWindowUnload,\n\t\taddOnUnload: dojo.addOnUnload\n\t};\n});","dependencies":["dojo\/_base\/kernel","dojo\/_base\/connect"]}}